<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>EoN &#8212; Epidemics on Networks 0.93 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.93',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Epidemics on Networks 0.93 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for EoN</h1><div class="highlight"><pre>
<span></span><span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">EoN (Epidemics on Networks)</span>

<span class="sd">EoN is a Python package for the simulation of epidemics on networks </span>
<span class="sd">and ODE models of disease spread.</span>

<span class="sd">The algorithms are based on the book</span>
<span class="sd">        </span>
<span class="sd">`Mathematics of epidemics on networks: from exact to approximate </span>
<span class="sd">models`</span>
<span class="sd">by Kiss, Miller &amp; Simon</span>
<span class="sd">        http://www.springer.com/book/9783319508047</span>
<span class="sd">        </span>
<span class="sd">Please cite the book if using these algorithms</span>

<span class="sd">For simulations, we assume that input networks are **NetworkX** </span>
<span class="sd">graphs; see https://networkx.github.io/</span>



<span class="sd">EoN consists of two sets of algorithms.  </span>

<span class="sd">- The first deals with simulation of epidemics on networks.  The most significant of these are `fast_SIS` and `fast_SIR` which significantly outperform Gillespie algorithms (also included).  These algorithms are discussed in more detail in the appendix of the book.</span>


<span class="sd">- The second deals with solution of systems of equations derived in the book.  For these it is possible to either provide the degree distribution, or simply use a network and let the code determine the degree distribution.</span>


<span class="sd">- There are a few additional algorithms which are not described in the book, but which we believe will be useful. Most notably, the function `visualize` which creates a sequence of images of a network which are appropriate for creating a movie showing disease spread.</span>

<span class="sd">Distributed under MIT license.  See :download:`license.txt&lt;../license.txt&gt;` for full details.</span>


<span class="sd">Auxiliary functions</span>
<span class="sd">-------------------</span>
<span class="sd">We start with a few useful auxiliary functions</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;warning - EoN is currently under significant development.  Interface&quot;</span>
      <span class="o">+</span><span class="s2">&quot; may change with little if any warning until version 1.0&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning - testing in Python 3 is limited&quot;</span><span class="p">)</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Joel C. Miller, Istvan Z. Kiss, and Peter Simon&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.93&quot;</span>

<span class="c1">#__all__ = </span>

<span class="k">class</span> <span class="nc">EoNError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    this will be the basic error type for EoN</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">_get_rate_functions</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">transmission_weight</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">recovery_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Arguments:</span>
<span class="sd">        G : networkx Graph</span>
<span class="sd">            the graph disease spread on</span>

<span class="sd">        tau : number</span>
<span class="sd">            disease parameter giving edge transmission rate (subject to edge scaling)</span>

<span class="sd">        gamma : number (default None)</span>
<span class="sd">            disease parameter giving typical recovery rate, </span>
<span class="sd">        </span>
<span class="sd">        transmission_weight : string (default None)</span>
<span class="sd">            `G.edge[u][v][transmission_weight]` scales up or down the recovery rate.</span>

<span class="sd">        recovery_weight : string       (default None)</span>
<span class="sd">            a label for a weight given to the nodes to scale their </span>
<span class="sd">            recovery rates</span>
<span class="sd">                `gamma_i = G.node[i][recovery_weight]*gamma`</span>
<span class="sd">    Returns:</span>
<span class="sd">        : trans_rate_fxn, rec_rate_fxn</span>
<span class="sd">            Two functions such that </span>
<span class="sd">            - `trans_rate_fxn(u,v)` is the transmission rate from u to v and</span>
<span class="sd">            - `rec_rate_fxn(u)` is the recovery rate of u.</span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">transmission_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_rate_fxn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate_fxn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">transmission_weight</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">recovery_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rec_rate_fxn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rec_rate_fxn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_weight</span><span class="p">]</span>


    <span class="k">return</span> <span class="n">trans_rate_fxn</span><span class="p">,</span> <span class="n">rec_rate_fxn</span>



<span class="kn">import</span> <span class="nn">EoN.simulation</span>
<span class="kn">from</span> <span class="nn">EoN.simulation</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">EoN.analytic</span>
<span class="kn">from</span> <span class="nn">EoN.analytic</span> <span class="k">import</span> <span class="o">*</span>



<div class="viewcode-block" id="subsample"><a class="viewcode-back" href="../documentation.html#EoN.subsample">[docs]</a><span class="k">def</span> <span class="nf">subsample</span><span class="p">(</span><span class="n">report_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">status1</span><span class="p">,</span> <span class="n">status2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">status3</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given </span>
<span class="sd">      S, I, and/or R as lists of numbers of nodes of the given status</span>
<span class="sd">      at given times</span>

<span class="sd">    returns them </span>
<span class="sd">      subsampled at specific report_times.</span>
<span class="sd">    </span>

<span class="sd">    :INPUTS:</span>

<span class="sd">    report_times : iterable (ordered)</span>
<span class="sd">                   times at which we want to know state of system</span>
<span class="sd">                   </span>
<span class="sd">    times : iterable (ordered)</span>
<span class="sd">            times at which we have the system state (assumed no change </span>
<span class="sd">            between these times)</span>
<span class="sd">            </span>
<span class="sd">    statusX (X one of 1, 2 or 3) : iterable (order corresponds to times)</span>
<span class="sd">                          generally S, I, or R</span>
<span class="sd">                          number of nodes in given status.</span>
<span class="sd">    :RETURNS:</span>

<span class="sd">    If only status1 is defined</span>
<span class="sd">        report_status1 : scipy array gives status1 subsampled just at </span>
<span class="sd">                         report_times.</span>
<span class="sd">                     </span>
<span class="sd">    If more are defined then it returns a list, either</span>
<span class="sd">        [report_status1, report_status2]</span>
<span class="sd">    or</span>
<span class="sd">        [report_status1, report_status2, report_status3]</span>

<span class="sd">    :SAMPLE USE:</span>

<span class="sd">    ::</span>

<span class="sd">        import networkx as nx</span>
<span class="sd">        import EoN</span>
<span class="sd">        import scipy</span>
<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        &quot;&quot;&quot; in this example we will run 100 stochastic simulations.</span>
<span class="sd">            Each simulation will produce output at a different set</span>
<span class="sd">            of times.  In order to calculate an average we will use</span>
<span class="sd">            subsample to find the epidemic sizes at a specific set</span>
<span class="sd">            of times given by report_times.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        G = nx.fast_gnp_random_graph(10000,0.001)</span>
<span class="sd">        tau = 1.</span>
<span class="sd">        gamma = 1.</span>
<span class="sd">        report_times = scipy.linspace(0,5,101)</span>
<span class="sd">        Ssum = scipy.zeros(len(report_times))</span>
<span class="sd">        Isum = scipy.zeros(len(report_times))</span>
<span class="sd">        Rsum = scipy.zeros(len(report_times))</span>
<span class="sd">        iterations = 100</span>
<span class="sd">        for counter in range(iterations): </span>
<span class="sd">            t, S, I, R = EoN.fast_SIR(G, tau, gamma, initial_infecteds = range(10))</span>
<span class="sd">            #t, S, I, and R have an entry for every single event.</span>
<span class="sd">            newS, newI, newR = EoN.subsample(report_times, t, S, I, R)</span>
<span class="sd">            #could also do: newI = EoN.subsample(report_times, t, I)</span>
<span class="sd">            plt.plot(report_times, newS, linewidth=1, alpha = 0.4)</span>
<span class="sd">            plt.plot(report_times, newI, linewidth=1, alpha = 0.4)</span>
<span class="sd">            plt.plot(report_times, newR, linewidth=1, alpha = 0.4)</span>
<span class="sd">            Ssum += newS</span>
<span class="sd">            Isum += newI</span>
<span class="sd">            Rsum += newR</span>
<span class="sd">        Save = Ssum / float(iterations)</span>
<span class="sd">        Iave = Isum / float(iterations)</span>
<span class="sd">        Rave = Rsum / float(iterations)</span>
<span class="sd">        plt.plot(report_times, Save, &quot;--&quot;, linewidth = 5, label = &quot;average&quot;)</span>
<span class="sd">        plt.plot(report_times, Iave, &quot;--&quot;, linewidth = 5)</span>
<span class="sd">        plt.plot(report_times, Rave, &quot;--&quot;, linewidth = 5)</span>
<span class="sd">        plt.legend(loc = &quot;upper right&quot;)</span>
<span class="sd">        plt.savefig(&quot;tmp.pdf&quot;)</span>

<span class="sd">    If only one of the sample times is given then returns just that.</span>

<span class="sd">    If report_times goes longer than times, then this simply assumes the </span>
<span class="sd">    system freezes in the final state.</span>
<span class="sd">    </span>
<span class="sd">    This uses a recursive approach if multiple arguments are defined.</span>


<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">report_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;report_times[0]&lt;times[0]&quot;</span><span class="p">)</span>
        
    <span class="n">report_status1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">next_report_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_observation_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">next_report_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">report_times</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">next_observation_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="ow">and</span> \
              <span class="n">times</span><span class="p">[</span><span class="n">next_observation_index</span><span class="p">]</span><span class="o">&lt;=</span> <span class="n">report_times</span><span class="p">[</span><span class="n">next_report_index</span><span class="p">]:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">status1</span><span class="p">[</span><span class="n">next_observation_index</span><span class="p">]</span>
            <span class="n">next_observation_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">report_status1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">next_report_index</span> <span class="o">+=</span><span class="mi">1</span>
        
    <span class="n">report_status1</span><span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">report_status1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">status2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">status3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">report_status2</span><span class="p">,</span> <span class="n">report_status3</span> <span class="o">=</span> <span class="n">subsample</span><span class="p">(</span><span class="n">report_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">status2</span><span class="p">,</span> <span class="n">status3</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">report_status1</span><span class="p">,</span> <span class="n">report_status2</span><span class="p">,</span> <span class="n">report_status3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">report_status2</span> <span class="o">=</span> <span class="n">subsample</span><span class="p">(</span><span class="n">report_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">status2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">report_status1</span><span class="p">,</span> <span class="n">report_status2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">report_status1</span></div>



<div class="viewcode-block" id="get_time_shift"><a class="viewcode-back" href="../documentation.html#EoN.get_time_shift">[docs]</a><span class="k">def</span> <span class="nf">get_time_shift</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Identifies the first time at which L crosses a threshold.  </span>
<span class="sd">    Useful for shifting times.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        times : list or scipy array (ordered)</span>
<span class="sd">            the times we have observations</span>
<span class="sd">        L : a list or scipy array</span>
<span class="sd">            order of L corresponds to times</span>
<span class="sd">        threshold : number</span>
<span class="sd">            a threshold value</span>

<span class="sd">    Returns:</span>
<span class="sd">        : </span>
<span class="sd">        t : number</span>
<span class="sd">            the first time at which L reaches or exceeds a threshold.</span>

<span class="sd">    :SAMPLE USE:</span>

<span class="sd">    ::</span>

<span class="sd">        import networkx as nx</span>
<span class="sd">        import EoN</span>
<span class="sd">        import scipy</span>
<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        &quot;&quot;&quot; in this example we will run 20 stochastic simulations.</span>
<span class="sd">            We will produce one plot showing the unshifted</span>
<span class="sd">            curves and one with them shifted so that t=0 when 1%</span>
<span class="sd">            are in the I class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        N=1000000</span>
<span class="sd">        kave = 10.</span>
<span class="sd">        G = nx.fast_gnp_random_graph(N,kave/(N-1.))</span>
<span class="sd">        tau = 1.</span>
<span class="sd">        gamma = 1.</span>
<span class="sd">        report_times = scipy.linspace(0,5,101)</span>
<span class="sd">        Ssum = scipy.zeros(len(report_times))</span>
<span class="sd">        Isum = scipy.zeros(len(report_times))</span>
<span class="sd">        Rsum = scipy.zeros(len(report_times))</span>
<span class="sd">        iterations = 20</span>
<span class="sd">        for counter in range(iterations):</span>
<span class="sd">            R=[0]</span>
<span class="sd">            while R[-1]&lt;1000: #if an epidemic doesn&#39;t happen, repeat</span>
<span class="sd">                t, S, I, R = EoN.fast_SIR(G, tau, gamma)</span>
<span class="sd">            plt.plot(t, I, linewidth = 1, color = &#39;gray&#39;, alpha=0.4)</span>
<span class="sd">            tshift = EoN.get_time_shift(t, I, 0.01*kave)</span>
<span class="sd">            plt.plot(t-tshift, I, color = &#39;red&#39;, linewidth = 1, alpha = 0.4)</span>
<span class="sd">        plt.savefig(&quot;tmp.pdf&quot;)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">t</span></div>



<div class="viewcode-block" id="visualize"><a class="viewcode-back" href="../documentation.html#EoN.visualize">[docs]</a><span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">plot_times</span><span class="p">,</span> <span class="n">infection_times</span><span class="p">,</span> <span class="n">recovery_times</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                <span class="n">SIR</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filetype</span> <span class="o">=</span> <span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="n">filenamebase</span> <span class="o">=</span> <span class="s1">&#39;tmp&#39;</span><span class="p">,</span> 
                <span class="n">colorS</span> <span class="o">=</span> <span class="s1">&#39;#009a80&#39;</span><span class="p">,</span> <span class="n">colorI</span> <span class="o">=</span> <span class="s1">&#39;#ff2020&#39;</span><span class="p">,</span> 
                <span class="n">colorR</span> <span class="o">=</span> <span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">show_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot_args</span> <span class="o">=</span> <span class="p">()):</span>
    <span class="sd">r&#39;&#39;&#39; </span>
<span class="sd">    Creates a set of plots showing statuses of nodes at different times.  By </span>
<span class="sd">    default, the plot for t = 1.3 would be put into &quot;tmp1p3.png&quot;</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        G : NetworkX Graph</span>
<span class="sd">        </span>
<span class="sd">        plot_times : list (or array, maybe even a set)</span>
<span class="sd">            collection of times to output plot</span>
<span class="sd">        </span>
<span class="sd">        infection_times : dict</span>
<span class="sd">            infection_times[node] is a list of times (if SIS) or the time (if </span>
<span class="sd">            SIR) of infection of node.  If node is never infected, </span>
<span class="sd">            it does not appear in dict and is assumed susceptible throughout.</span>
<span class="sd">            </span>
<span class="sd">        recovery_times : dict</span>
<span class="sd">            see infection_times, except this has time(s) of recovery.</span>
<span class="sd">            </span>
<span class="sd">        pos : dict, optional</span>
<span class="sd">            the positions to plot nodes of G.  By default spring_layout is used.</span>
<span class="sd">        </span>
<span class="sd">        SIR : boolean, default True</span>
<span class="sd">            True if the simulation is SIR, False if it is SIS.</span>
<span class="sd">            </span>
<span class="sd">        filetype : string (default &#39;png&#39;)</span>
<span class="sd">            the type of figure to make.</span>
<span class="sd">            </span>
<span class="sd">        filenamebase : string (default &#39;tmp&#39;)</span>
<span class="sd">            base name for output plot file names.</span>
<span class="sd">            </span>
<span class="sd">        colorS : default &#39;#009a80&#39;</span>
<span class="sd">            something that will be interpreted as a color by matplotlib.  </span>
<span class="sd">            Used to plot susceptible nodes.  Note, if using RGB as a tuple</span>
<span class="sd">            of length 3, if there are 3 susceptible nodes, the tuple will</span>
<span class="sd">            be interpreted as 3 different colors to use.</span>
<span class="sd">            </span>
<span class="sd">        colorI : default &#39;#ff2020&#39;</span>
<span class="sd">            see colorS</span>
<span class="sd">            </span>
<span class="sd">        colorR : default &#39;gray&#39;</span>
<span class="sd">            see colorS</span>
<span class="sd">            </span>
<span class="sd">        show_edges : Boolean, default True</span>
<span class="sd">            whether the edges should be plotted</span>
<span class="sd">            </span>
<span class="sd">        plot_args : tuple, default ()</span>
<span class="sd">            arguments to be passed to the networkx drawing commands</span>
<span class="sd">            draw_networkx_nodes and draw_networkx_edges.</span>
<span class="sd">         </span>
<span class="sd">         </span>
<span class="sd">    :SAMPLE USE:</span>

<span class="sd">    ::</span>

<span class="sd">        import EoN</span>
<span class="sd">        import networkx as nx</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        </span>
<span class="sd">        G = nx.fast_gnp_random_graph(100,0.06)</span>
<span class="sd">        plot_times = scipy.linspace(0,10,101) #0, 0.1, 0.2, ..., 10</span>
<span class="sd">        </span>
<span class="sd">        #let&#39;s create 101 figures for an SIS epidemic</span>
<span class="sd">        times, S, I, inf_times, rec_times = EoN.fast_SIS(G, 1., 1., return_full_data=True)</span>
<span class="sd">        EoN.visualize(G, plot_times, inf_times, rec_times, filenamebase = &#39;tmpSIS&#39;, SIR = False)</span>
<span class="sd">        </span>
<span class="sd">        #let&#39;s create 101 figures for an SIR epidemic</span>
<span class="sd">        times, S, I, R, inf_time, rec_time = EoN.fast_SIR(G, 1., 1., return_full_data=True)</span>
<span class="sd">        EoN.visualize(G, plot_times, inf_time, filenamebase = &#39;tmpSIR&#39;, rec_time)</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        
    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">plot_times</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">R</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">infection_times</span> <span class="ow">or</span> <span class="n">infection_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">&gt;</span><span class="n">time</span><span class="p">:</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">recovery_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">&gt;</span><span class="n">time</span><span class="p">:</span>
                    <span class="n">I</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">R</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>    
        <span class="k">else</span><span class="p">:</span> <span class="c1">#SIS</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">infection_times</span> <span class="ow">or</span> <span class="n">infection_times</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">time</span><span class="p">:</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#has been infected at least once. I&#39;m not taking advantage of ordering of lists. </span>
                    <span class="n">time_of_last_inf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">inftime</span> <span class="k">for</span> <span class="n">inftime</span> <span class="ow">in</span> <span class="n">infection_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">if</span> <span class="n">inftime</span><span class="o">&lt;=</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">recovery_times</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">time</span><span class="p">:</span>
                        <span class="n">time_of_last_rec</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rectime</span> <span class="k">for</span> <span class="n">rectime</span> <span class="ow">in</span> <span class="n">recovery_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">if</span> <span class="n">rectime</span><span class="o">&lt;=</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">time_of_last_rec</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">time_of_last_rec</span><span class="o">&lt;</span><span class="n">time_of_last_inf</span><span class="p">:</span> <span class="c1">#most recent thing was infection</span>
                        <span class="n">I</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#most recent thing was recovery.</span>
                        <span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span> <span class="o">=</span> <span class="n">colorS</span><span class="p">,</span> <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="o">*</span><span class="n">plot_args</span><span class="p">)</span>            
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span> <span class="o">=</span> <span class="n">colorI</span><span class="p">,</span> <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="o">*</span><span class="n">plot_args</span><span class="p">)</span>            
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span> <span class="o">=</span> <span class="n">colorR</span><span class="p">,</span> <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="o">*</span><span class="n">plot_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_edges</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">plot_args</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filenamebase</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">filetype</span><span class="p">)</span></div>
                

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">These are the systems I want to include based on their numbering in the </span>
<span class="sd">book:</span>

<span class="sd">coded (3.7) SIS individual based</span>
<span class="sd">(3.30) SIR individual based</span>
<span class="sd">NOT coded (3.26) SIS pair based</span>
<span class="sd">(3.39) SIR pair based</span>

<span class="sd">chapter 4?</span>

<span class="sd">(5.13) SIS heterogeneous pairwise</span>
<span class="sd">(5.15) SIR heterogeneous pairwise</span>
<span class="sd">(5.18) SIS compact pairwise</span>
<span class="sd">(5.19) SIR compact pairwise</span>
<span class="sd">(5.20) SIS super compact pairwise</span>
<span class="sd">(5.22) SIR super compact pairwise</span>
<span class="sd">(5.36) SIS effective degree</span>
<span class="sd">(5.38) SIR effective degree</span>
<span class="sd">(5.43) SIR compact effective degree</span>
<span class="sd">(5.44) SIS compact effective degree = SIS compact pairwise</span>

<span class="sd">(6.2) Epidemic probability discrete time</span>
<span class="sd">(6.3) Epidemic probability continuous time</span>
<span class="sd">(6.5) Epidemic probability non-Markovian</span>
<span class="sd">(6.6) Epidemic size discrete time</span>
<span class="sd">(6.7) Epidemic size continuous time</span>
<span class="sd">(6.8) Epidemic size non-Markovian</span>
<span class="sd">(6.10) Epidemic size discrete time (large IC)</span>
<span class="sd">(6.11) Discrete-time EBCM model</span>
<span class="sd">(6.12) Continuous time EBCM model</span>

<span class="sd">(8.1) SIS pairwise contact conserving rewiring</span>
<span class="sd">(8.5) SIS eff. deg. contact conserving rewiring</span>
<span class="sd">(8.7) SIS pairwise random activation/deletion</span>
<span class="sd">(8.13) SIS eff. deg. random activation/deletion</span>
<span class="sd">(8.15) SIS pairwise link-status dependent act/del</span>
<span class="sd">(8.16) SIS link deactivation-activation on fixed networks.</span>
<span class="sd">(8.19) EBCM dynamic network</span>

<span class="sd">(9.5) SI^{K}R multistage pairwise for homogeneous</span>
<span class="sd">(9.27) SIR pairwise, constant infection duration.</span>
<span class="sd">(9.35) SIR homogeneous pairwise, general recovery</span>
<span class="sd">(9.36) SIR EBCM non-Markovian trans/recovery</span>

<span class="sd">add models that take in graph, measure degree distribution and run EBCM</span>
<span class="sd">similarly for EBCM with neighbor degrees (see barabasi_SIR.py)</span>

<span class="sd">consider explicitly defining toast graph etc.</span>
<span class="sd">&#39;&#39;&#39;</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Epidemics on Networks 0.93 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Joel Miller, Istvan Kiss, Peter Simon.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>