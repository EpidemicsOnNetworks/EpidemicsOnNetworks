<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>EoN &#8212; Epidemics on Networks 0.9 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Epidemics on Networks 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for EoN</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">epidemicsonnetworks -- EoN</span>

<span class="sd">&quot;Epidemics on Networks&quot;</span>

<span class="sd">    EoN is a Python package for the simulation of epidemics on networks </span>
<span class="sd">    and ODE models of disease spread.</span>

<span class="sd">    The algorithms are based on the book:</span>
<span class="sd">        Mathematics of epidemics on networks: from exact to approximate </span>
<span class="sd">            models</span>
<span class="sd">        By: </span>
<span class="sd">            Kiss, Miller &amp; Simon</span>
<span class="sd">        More information at </span>
<span class="sd">            https://EpidemicsOnNetworks.github.io/EpidemicsOnNetworks/</span>
<span class="sd">    Please cite the book if using these algorithms</span>

<span class="sd">    For simulations, we assume that input networks are **NetworkX** </span>
<span class="sd">    graphs; see https://networkx.github.io/</span>



<span class="sd">This is a preliminary version of the code:</span>
<span class="sd">  - The algorithms have not been tested in Python 3 (tested only in 2.7)</span>

<span class="sd">  - At present the ODE models are not fully tested.</span>

<span class="sd">  - Additional algorithms may be added beyond those in the book.</span>






<span class="sd">Distributed under MIT license.  See license.txt for full details.</span>

<span class="sd">&#39;&#39;&#39;</span>


<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="k">import</span> <span class="n">shift</span>


<span class="c1">#######################</span>
<span class="c1">#                     #</span>
<span class="c1">#   Auxiliary stuff   #</span>
<span class="c1">#                     #</span>
<span class="c1">#######################</span>
<div class="viewcode-block" id="EoNError"><a class="viewcode-back" href="../methods.html#EoN.EoNError">[docs]</a><span class="k">class</span> <span class="nc">EoNError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    this will be the basic error type for EoN</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="Event"><a class="viewcode-back" href="../methods.html#EoN.Event">[docs]</a><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1">#for fast_SIR and fast_SIS</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    This class is used in event-driven simulations (fast_SIR and </span>
<span class="sd">    fast_SIS) as an event which will be put into a priority queue.  </span>
<span class="sd">    </span>
<span class="sd">    It is sortable based on event time.</span>
<span class="sd">        </span>
<span class="sd">    I wonder about whether it would be better to do this as a dict.</span>
<span class="sd">    </span>
<span class="sd">    The ability to sort based on time is why I am leaving it as a class.</span>
<span class="sd">    </span>
<span class="sd">    An alternative would be to give it a time, a function to call, and </span>
<span class="sd">    arguments for the function.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">source</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">action</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span> <span class="c1">#not needed for fast_SIR or recoveries</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span> <span class="c1">#used to sort Q</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span></div>
    

<span class="k">class</span> <span class="nc">_ListDict_</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    The Gillespie algorithm with rejection-sampling will involve a step </span>
<span class="sd">    that samples a random element from the set.  This is slow in Python.  </span>
<span class="sd">    So I&#39;m introducing a new class based on a stack overflow answer by</span>
<span class="sd">    Amber (http://stackoverflow.com/users/148870/amber) </span>
<span class="sd">    for a question by</span>
<span class="sd">    tba (http://stackoverflow.com/users/46521/tba) </span>
<span class="sd">    found at</span>
<span class="sd">    http://stackoverflow.com/a/15993515/2966723</span>

<span class="sd">    Based on some limited tests (in some perhaps-atypical networks),</span>
<span class="sd">    the benefit appears to be pretty small.  It may be worth creating </span>
<span class="sd">    this data structure in C, but I doubt it.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item_to_position</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">item_to_position</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item_to_position</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">item_to_position</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">last_item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_item</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">item_to_position</span><span class="p">[</span><span class="n">last_item</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span>

    <span class="k">def</span> <span class="nf">choose_random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>



<div class="viewcode-block" id="my_odeint"><a class="viewcode-back" href="../methods.html#EoN.my_odeint">[docs]</a><span class="k">def</span> <span class="nf">my_odeint</span><span class="p">(</span><span class="n">dfunc</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">r&#39;&#39;&#39;For some of the systems odeint will switch to the BDF solver.</span>
<span class="sd">    In large enough systems, it then gets stuck trying to estimate the </span>
<span class="sd">    Jacobian.</span>

<span class="sd">    This routine has identical inputs to integrate.odeint, but relies on </span>
<span class="sd">    integrate.ode.  It avoids BDF.</span>

<span class="sd">    In particular, this seems to be important for SIS heterogeneous </span>
<span class="sd">    pairwise where the number of equations is very large.  I have found </span>
<span class="sd">    that near equilibrium, this often is interpreted as being a stiff </span>
<span class="sd">    system and it switches to bdf, which requires calculating a </span>
<span class="sd">    Jacobian.  In some systems this is impractically large.</span>
<span class="sd">    </span>
<span class="sd">    See this question: </span>
<span class="sd">        http://stackoverflow.com/q/40317096/2966723,</span>
<span class="sd">    with the answer by </span>
<span class="sd">        Phillip: http://stackoverflow.com/users/1881610/phillip</span>
<span class="sd">        </span>
<span class="sd">    INPUT and OUTPUT are as integrate.odeint</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">ode</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">dfunc</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">r</span><span class="o">.</span><span class="n">set_integrator</span><span class="p">(</span><span class="s1">&#39;vode&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;adams&#39;</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">set_initial_value</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">V</span><span class="o">=</span><span class="p">[</span><span class="n">V0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">V</span></div>


<div class="viewcode-block" id="get_Nk_and_IC_as_arrays"><a class="viewcode-back" href="../methods.html#EoN.get_Nk_and_IC_as_arrays">[docs]</a><span class="k">def</span> <span class="nf">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given the graph and initial proportion infected this finds the </span>
<span class="sd">    initial conditions and number of nodes of each degree as needed</span>
<span class="sd">    by many of the differential equations models.</span>
<span class="sd">    </span>
<span class="sd">    INPUT</span>
<span class="sd">    -----</span>
<span class="sd">    G : networkx graph</span>
<span class="sd">    rho : number between 0 and 1</span>
<span class="sd">          fraction of nodes to infect at time 0.</span>
<span class="sd">    SIR : boolean</span>
<span class="sd">          says whether the system will be SIR or SIS.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    Nk : scipy array</span>
<span class="sd">         NUMBER (not proportion) of nodes of each degree.</span>
<span class="sd">    Sk0 : scipy array</span>
<span class="sd">          NUMBER of susceptible nodes of each degree at t=0, </span>
<span class="sd">          = (1-rho)Nk</span>
<span class="sd">    Ik0 : scipy array    </span>
<span class="sd">          NUMBER of infected nodes of each degree at t=0,   </span>
<span class="sd">          = rho Nk</span>
<span class="sd">    if SIR, also returns</span>
<span class="sd">    Rk0 : scipy array</span>
<span class="sd">          NUMBER of recovered nodes of each degree at t=0,    </span>
<span class="sd">          = 0 Nk</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">degree_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degree_count</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">degree_count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">Sk0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">Nk</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">Nk</span>
    <span class="n">Rk0</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">Nk</span>
    
    <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span></div>

<div class="viewcode-block" id="get_NkNl_and_IC_as_arrays"><a class="viewcode-back" href="../methods.html#EoN.get_NkNl_and_IC_as_arrays">[docs]</a><span class="k">def</span> <span class="nf">get_NkNl_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">withKs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    In some of the differential equations models, we need to know how</span>
<span class="sd">    many edges exist between nodes of given degrees in a graph.  </span>
<span class="sd">    </span>
<span class="sd">    This finds that and the initial conditions for numbers of the</span>
<span class="sd">    various edges assuming a fraction rho is initially infected.</span>
<span class="sd">    </span>
<span class="sd">    INPUT</span>
<span class="sd">    -----</span>
<span class="sd">    G : networkx graph</span>
<span class="sd">    rho : number between 0 and 1</span>
<span class="sd">          fraction of nodes to infect at time 0.</span>
<span class="sd">    withKs : boolean</span>
<span class="sd">             flag to say whether we are restricting our attention to </span>
<span class="sd">             just those degrees observed in the network or to all </span>
<span class="sd">             degrees.</span>
<span class="sd">             If True, </span>
<span class="sd">                 then we only consider those degrees that are observed.</span>
<span class="sd">             If False, </span>
<span class="sd">                 then we treat it as if all degrees from 0 to kmax are </span>
<span class="sd">                 observed.</span>
<span class="sd">    SIR : boolean</span>
<span class="sd">          says whether the system will be SIR or SIS.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    NkNl : 2D scipy array</span>
<span class="sd">         NUMBER (not proportion) of edges between each pair of degrees.</span>
<span class="sd">    SkSl0 : 2D scipy array</span>
<span class="sd">          initial NUMBER of edges between pair of susceptibel nodes of </span>
<span class="sd">          each degree type.</span>
<span class="sd">          = (1-rho)^2 NkNl</span>
<span class="sd">    SkIl0 : 2D scipy array    </span>
<span class="sd">          initial NUMBER of edges from a susceptible to an infected node </span>
<span class="sd">          of the given degrees.</span>
<span class="sd">          = rho(1-rho) NkNl</span>

<span class="sd">    if not SIR, also returns</span>
<span class="sd">    IkIl0 : 2D scipy array</span>
<span class="sd">          initial NUMBER of edges between 2 infected nodes.  This is not </span>
<span class="sd">          needed for SIR model.</span>
<span class="sd">          = rho^2*NkNl</span>

<span class="sd">    if withKs, also returns</span>
<span class="sd">    Ks : scipy array</span>
<span class="sd">         The observed degrees in the population.</span>
<span class="sd">    &#39;&#39;&#39;</span> 
    <span class="k">if</span> <span class="n">withKs</span><span class="p">:</span>
        <span class="n">Ks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="n">klength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">klength</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">NkNl</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">klength</span><span class="p">,</span><span class="n">klength</span><span class="p">))</span>
    <span class="n">NkNl</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">klength</span><span class="p">,</span><span class="n">klength</span><span class="p">))</span>
    <span class="n">NkNl</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">klength</span><span class="p">,</span><span class="n">klength</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">NkNl</span><span class="p">[</span><span class="n">Ks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)][</span><span class="n">Ks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">NkNl</span><span class="p">[</span><span class="n">Ks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">l</span><span class="p">)][</span><span class="n">Ks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">SkSl0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">NkNl</span>
    <span class="n">SkIl0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">NkNl</span>
    <span class="n">IkIl0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">NkNl</span>
    <span class="k">if</span> <span class="n">withKs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span></div>

<div class="viewcode-block" id="get_Pk"><a class="viewcode-back" href="../methods.html#EoN.get_Pk">[docs]</a><span class="k">def</span> <span class="nf">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Used in several places so that we can input a graph and then we </span>
<span class="sd">    can call the methods that depend on the degree distribution</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : networkx Graph</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">         Pk[k] is the proportion of nodes with degree k.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">degree_count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">degree_count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">degree_count</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">Pk</span></div>

<div class="viewcode-block" id="get_Psi"><a class="viewcode-back" href="../methods.html#EoN.get_Psi">[docs]</a><span class="k">def</span> <span class="nf">get_Psi</span><span class="p">(</span><span class="n">Pk</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given a degree distribution (as a dict), returns the function psi</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">         Pk[k] is the proportion of nodes with degree k.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    psi : function.</span>
<span class="sd">          psi(x) = \sum_k Pk[k] x^k</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">Pkarray</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Pk</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Pkarray</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_PsiPrime"><a class="viewcode-back" href="../methods.html#EoN.get_PsiPrime">[docs]</a><span class="k">def</span> <span class="nf">get_PsiPrime</span><span class="p">(</span><span class="n">Pk</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given a degree distribution (as a dict) returns the function</span>
<span class="sd">    dPsi(x)/dx</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">         Pk[k] is the proportion of nodes with degree k.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    psiPrime : function.</span>
<span class="sd">          \sum_k k Pk[k] x^{k-1}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">Pkarray</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Pk</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>

    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Pkarray</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="get_PsiDPrime"><a class="viewcode-back" href="../methods.html#EoN.get_PsiDPrime">[docs]</a><span class="k">def</span> <span class="nf">get_PsiDPrime</span><span class="p">(</span><span class="n">Pk</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given a degree distribution (as a dict) returns the function </span>
<span class="sd">    </span>
<span class="sd">    d^2Psi(x)/dx^2</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">         Pk[k] is the proportion of nodes with degree k.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    psiDPrime : function.</span>
<span class="sd">          \sum_k k(k-1)Pk[k] x^{k-2}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">Pkarray</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Pk</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Pkarray</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="subsample"><a class="viewcode-back" href="../methods.html#EoN.subsample">[docs]</a><span class="k">def</span> <span class="nf">subsample</span><span class="p">(</span><span class="n">report_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">status1</span><span class="p">,</span> <span class="n">status2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">status3</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given </span>
<span class="sd">      S, I, and/or R as lists (or other iterable) of numbers of nodes of</span>
<span class="sd">      given status at given times</span>
<span class="sd">    returns them </span>
<span class="sd">      subsampled at specific report_times.</span>
<span class="sd">      </span>
<span class="sd">    If more than one is given, does so as a list in order given, but </span>
<span class="sd">        skipping whichever was not included (if any not included)</span>
<span class="sd">    If only one is given then returns just that.</span>

<span class="sd">    If report_times goes longer than times, then this simply assumes the </span>
<span class="sd">    system freezes in the final state.</span>
<span class="sd">    </span>
<span class="sd">    This uses a recursive approach if multiple arguments are defined.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    report_times : iterable (ordered)</span>
<span class="sd">                   times at which we want to know state of system</span>
<span class="sd">    times : iterable (ordered)</span>
<span class="sd">            times at which we have the system state (assumed no change </span>
<span class="sd">            between these times)</span>
<span class="sd">    statusX (X one of 1, 2 or 3) : iterable (order corresponds to times)</span>
<span class="sd">                          generally S, I, or R</span>
<span class="sd">                          number of nodes in given status.</span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    If only status1 is defined</span>
<span class="sd">        report_status1 : scipy array gives status1 subsampled just at </span>
<span class="sd">                         report_times.</span>
<span class="sd">                     </span>
<span class="sd">    If more are defined then it returns a list, either</span>
<span class="sd">        [report_status1, report_status2]</span>
<span class="sd">    or</span>
<span class="sd">        [report_status1, report_status2, report_status3]</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">report_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;report_times[0]&lt;times[0]&quot;</span><span class="p">)</span>
        
    <span class="n">report_status1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">next_report_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_observation_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">next_report_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">report_times</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">next_observation_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="ow">and</span> \
              <span class="n">times</span><span class="p">[</span><span class="n">next_observation_index</span><span class="p">]</span><span class="o">&lt;=</span> <span class="n">report_times</span><span class="p">[</span><span class="n">next_report_index</span><span class="p">]:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">status1</span><span class="p">[</span><span class="n">next_observation_index</span><span class="p">]</span>
            <span class="n">next_observation_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">report_status1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">next_report_index</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">status2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">status3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">report_status2</span><span class="p">,</span> <span class="n">report_status3</span> <span class="o">=</span> <span class="n">subsample</span><span class="p">(</span><span class="n">report_times</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">status2</span><span class="p">,</span> <span class="n">status3</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">report_status1</span><span class="p">,</span> <span class="n">report_status2</span><span class="p">,</span> <span class="n">report_status3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">report_status1</span><span class="p">,</span> <span class="n">report_status2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">report_status1</span></div>



<div class="viewcode-block" id="get_time_shift"><a class="viewcode-back" href="../methods.html#EoN.get_time_shift">[docs]</a><span class="k">def</span> <span class="nf">get_time_shift</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Identifies the first time at which L crosses a threshold.  </span>
<span class="sd">    Useful for shifting times.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    times : list or scipy array (ordered)</span>
<span class="sd">            the times we have observations</span>
<span class="sd">    L : a list or scipy array</span>
<span class="sd">        order of L corresponds to times</span>
<span class="sd">    threshold : number</span>
<span class="sd">        a threshold value</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    t : number</span>
<span class="sd">        the first time at which L reaches or exceeds a threshold.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">t</span></div>



<span class="c1">##########################</span>
<span class="c1">#                        #</span>
<span class="c1">#    SIMULATION CODE     #</span>
<span class="c1">#                        #</span>
<span class="c1">##########################</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The code in the region below is used for stochastic simulation of </span>
<span class="sd">    epidemics on networks</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">_simple_test_transmission_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.8 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this test_transmission function for basic_discrete_SIR_epidemic.</span>

<span class="sd">    This handles the simple case where transmission occurs with </span>
<span class="sd">    probability p.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    u : node</span>
<span class="sd">        the infected node</span>
<span class="sd">    v : node</span>
<span class="sd">        the susceptible node</span>
<span class="sd">    p : number between 0 and 1</span>
<span class="sd">        the transmission probability</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    True if u will infect v (given opportunity)</span>
<span class="sd">    False otherwise</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">&lt;</span><span class="n">p</span>


<div class="viewcode-block" id="discrete_SIR_epidemic"><a class="viewcode-back" href="../methods.html#EoN.discrete_SIR_epidemic">[docs]</a><span class="k">def</span> <span class="nf">discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> 
                <span class="n">test_transmission</span><span class="o">=</span><span class="n">_simple_test_transmission_</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> 
                <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_discrete_SIR_epidemic</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.8 of Kiss, Miller, &amp; Simon.  Please cite the book</span>
<span class="sd">    if using this algorithm.</span>

<span class="sd">    Return details of epidemic curve from a discrete time simulation.</span>
<span class="sd">    </span>
<span class="sd">    It assumes that individuals are infected for exactly one unit of </span>
<span class="sd">    time and then recover with immunity.</span>

<span class="sd">    This is defined to handle a user-defined function</span>
<span class="sd">        test_transmission(node1,node2,*args)</span>
<span class="sd">    which determines whether transmission occurs.</span>

<span class="sd">    So elaborate rules can be created as desired by the user.</span>

<span class="sd">    By default it uses </span>
<span class="sd">        _simple_test_transmission_</span>
<span class="sd">    in which case args should be entered as (p,)</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G: NetworkX Graph (or some other structure which quacks like a </span>
<span class="sd">        NetworkX Graph)</span>
<span class="sd">        The network on which the epidemic will be simulated.</span>
<span class="sd">        </span>
<span class="sd">    test_transmission: function(u,v,*args)</span>
<span class="sd">        (see below for args definition)</span>
<span class="sd">        A function that determines whether u transmits to v.</span>
<span class="sd">        It returns True if transmission happens and False otherwise.</span>
<span class="sd">        The default will return True with probability p, where args=(p,)</span>

<span class="sd">        This function can be user-defined.</span>
<span class="sd">        It is called like:</span>
<span class="sd">            test_transmission(u,v,*args)</span>
<span class="sd">        Note that if args is not entered, then args=(), and this call is </span>
<span class="sd">        equivalent to</span>
<span class="sd">            test_transmission(u,v)</span>

<span class="sd">    args: a list or tuple</span>
<span class="sd">        The arguments of test_transmission coming after the nodes.  If </span>
<span class="sd">        simply having transmission with probability p it should be </span>
<span class="sd">        entered as </span>
<span class="sd">            args=(p,)   </span>
<span class="sd">        [note the comma is needed to tell Python that this is really a </span>
<span class="sd">        tuple]</span>

<span class="sd">    initial_infecteds: node or iterable of nodes (default is None)</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>

<span class="sd">    return_node_data: boolean  (default False)</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">            individual node should be returned.</span>
<span class="sd">        It is returned in the form of two dicts, </span>
<span class="sd">            infection_time and recovery_time</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ------------</span>
<span class="sd">    if return_node_data is False:</span>
<span class="sd">       the scipy arrays: t, S, I, R</span>
<span class="sd">    else:</span>
<span class="sd">       the scipy arrays: t, S, I, R </span>
<span class="sd">       and the dicts infection_time and recovery_time</span>

<span class="sd">    these arrays give all the times observed and the number in each </span>
<span class="sd">    state at each time.  The dicts give times at which each node changed </span>
<span class="sd">    status.</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    t, S, I, R = EoN.discrete_SIR_epidemic(G, args = (0.6,), </span>
<span class="sd">                                            initial_infecteds=range(20))</span>
<span class="sd">    plt.plot(t,S)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Because this sample uses the defaults, it is equivalent to a call to </span>
<span class="sd">    basic_discrete_SIR_epidemic</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="n">infection_time</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">recovery_time</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>
    <span class="n">infecteds</span> <span class="o">=</span> <span class="n">initial_infecteds</span>

    <span class="n">N</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">infecteds</span><span class="p">)]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">infecteds</span><span class="p">)]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">susceptible</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>  
    <span class="c1">#above line is equivalent to u.susceptible=True for all nodes.</span>
    
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">infecteds</span><span class="p">:</span>
        <span class="n">susceptible</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">infecteds</span><span class="p">:</span>
        <span class="n">new_infecteds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">infecteds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">susceptible</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">test_transmission</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                    <span class="n">new_infecteds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">susceptible</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">return_node_data</span><span class="p">:</span>
                <span class="n">infection_time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">recovery_time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">infecteds</span> <span class="o">=</span> <span class="n">new_infecteds</span>
        <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">infecteds</span><span class="p">))</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
               <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">infection_time</span><span class="p">,</span> <span class="n">recovery_time</span></div>



<div class="viewcode-block" id="basic_discrete_SIR_epidemic"><a class="viewcode-back" href="../methods.html#EoN.basic_discrete_SIR_epidemic">[docs]</a><span class="k">def</span> <span class="nf">basic_discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_basic_discrete_SIR_epidemic   </span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.8 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this algorithm.</span>

<span class="sd">    Does a simulation of the simple case of all nodes transmitting</span>
<span class="sd">    with probability p independently to each neighbor and then</span>
<span class="sd">    recovering.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    p : number</span>
<span class="sd">        transmission probability</span>
<span class="sd">    initial_infecteds: node or iterable of nodes  (default None)</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    return_node_data: boolean (default False)</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, </span>
<span class="sd">            infection_time and recovery_time</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_node_data is False:</span>
<span class="sd">        the scipy arrays: t, S, I, R</span>
<span class="sd">    else:</span>
<span class="sd">        the scipy arrays: t, S, I, R </span>
<span class="sd">        and the dicts infection_time and recovery_time</span>

<span class="sd">    these scipy arrays give all the times observed and the number in </span>
<span class="sd">    each state at each time.  The dicts give times at which each node </span>
<span class="sd">    changed status.</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    t, S, I, R = EoN.basic_discrete_SIR_epidemic(G, 0.6)</span>
<span class="sd">    plt.plot(t,S)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    This sample may be boring if the randomly chosen initial infection</span>
<span class="sd">    doesn&#39;t trigger an epidemic.</span>

<span class="sd">&#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">_simple_test_transmission_</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,),</span> 
                                    <span class="n">initial_infecteds</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="percolate_network"><a class="viewcode-back" href="../methods.html#EoN.percolate_network">[docs]</a><span class="k">def</span> <span class="nf">percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1">#tested indirectly in test_basic_discrete_SIR_epidemic   </span>

    <span class="sd">r&#39;&#39;&#39;From figure 6.10 of Kiss, Miller, &amp; Simon.  Please cite the book</span>
<span class="sd">    if using this algorithm.</span>

<span class="sd">    Performs bond percolation on the network G, keeping edges with </span>
<span class="sd">    probability p</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">    p : number between 0 and 1</span>
<span class="sd">        the probability of keeping edge</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    H : NetworkX Graph</span>
<span class="sd">        A network with same nodes as G, but with each edge retained </span>
<span class="sd">        independently with probability p.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    H = EoN.percolate_network(G, 0.6)</span>


<span class="sd">    H is now a graph with 60% of the edges of G</span>
<span class="sd">&#39;&#39;&#39;</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">&lt;</span><span class="n">p</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>

<span class="k">def</span> <span class="nf">_edge_exists_</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure 6.10 of Kiss, Miller, &amp; Simon.  Please cite the book</span>
<span class="sd">    if using this algorithm.</span>

<span class="sd">    Tests whether H has an edge from u to v.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    u : node</span>
<span class="sd">    v : node</span>
<span class="sd">    H : graph</span>

<span class="sd">    RETURNS  H.has_edge(u,v)</span>
<span class="sd">    -------</span>
<span class="sd">    True : if H has the edge</span>
<span class="sd">    False : if H does not have the edge</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="percolation_based_discrete_SIR_epidemic"><a class="viewcode-back" href="../methods.html#EoN.percolation_based_discrete_SIR_epidemic">[docs]</a><span class="k">def</span> <span class="nf">percolation_based_discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> 
                                            <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                            <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_basic_discrete_SIR_epidemic   </span>
    <span class="sd">r&#39;&#39;&#39;From figure 6.10 of Kiss, Miller, &amp; Simon.  Please cite the book</span>
<span class="sd">    if using this algorithm.</span>

<span class="sd">    </span>
<span class="sd">    The simple case of all nodes transmitting with probability p </span>
<span class="sd">    independently to each neighbor and then recovering, but using a </span>
<span class="sd">    percolation-based approach.  </span>
<span class="sd">    </span>
<span class="sd">    See basic_discrete_SIR_epidemic which should produce equivalent </span>
<span class="sd">    outputs.  </span>
<span class="sd">    </span>
<span class="sd">    That algorithm will be faster than this one.  </span>
<span class="sd">    </span>
<span class="sd">    The value of this function is that by performing many simulations we </span>
<span class="sd">    can see that the outputs of the two are equivalent.  </span>
<span class="sd">    </span>
<span class="sd">    This algorithm leads to a better understanding of the theory.</span>


<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    p : number</span>
<span class="sd">        transmission probability</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, </span>
<span class="sd">             infection_time and recovery_time</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ------------</span>
<span class="sd">    if return_node_data is False:</span>
<span class="sd">        the lists: t, S, I, R</span>
<span class="sd">    else:</span>
<span class="sd">        the lists: t, S, I, R </span>
<span class="sd">        and the dicts infection_time and recovery_time</span>

<span class="sd">    these lists give all the times observed and the number in each state </span>
<span class="sd">        at each time.  </span>
<span class="sd">    The dicts give times at which each node changed status.</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    t, S, I, R = EoN.percolation_based_discrete_SIR_epidemic(G, p)</span>
<span class="sd">    plt.plot(t,S)</span>
<span class="sd">    </span>
<span class="sd">    This is equivalent to basic_discrete_epidemic (but many simulations</span>
<span class="sd">        may be needed before it&#39;s clear, since these are stochastic)</span>

<span class="sd">&#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">discrete_SIR_epidemic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">_edge_exists_</span><span class="p">,</span> <span class="p">[</span><span class="n">H</span><span class="p">],</span> <span class="n">initial_infecteds</span><span class="p">,</span> 
                                    <span class="n">return_node_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimate_SIR_prob_size"><a class="viewcode-back" href="../methods.html#EoN.estimate_SIR_prob_size">[docs]</a><span class="k">def</span> <span class="nf">estimate_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1">#tested in test_estimate_SIR_prob_size</span>
    <span class="sd">r&#39;&#39;&#39;From figure 6.12 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    Provies an estimate of epidemic probability and size assuming a </span>
<span class="sd">    fixed transmission probability p.  </span>
<span class="sd">    </span>
<span class="sd">    The estimate is found by performing bond percolation and then </span>
<span class="sd">    finding the largest connected component in the remaining network.  </span>
<span class="sd">    </span>
<span class="sd">    This assumes that there is a single giant component above threshold.  </span>

<span class="sd">    It will not be an appropriate measure if the network is made up of </span>
<span class="sd">    several densely connected components with very weak connections </span>
<span class="sd">    between these components.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    p : number</span>
<span class="sd">        transmission probability</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    PE, AR : </span>
<span class="sd">        (numbers) estimates of the probability and proportion </span>
<span class="sd">           infected (attack rate) in epidemics</span>
<span class="sd">        (the two are equal, but each given for consistency with </span>
<span class="sd">           estimate_directed_SIR_prob_size)</span>
<span class="sd">          </span>
<span class="sd">            </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    PE, AR = EoN.estimate_SIR_prob_size(G, 0.6)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="k">for</span> <span class="n">CC</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">H</span><span class="p">)))</span>
    <span class="n">returnval</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">returnval</span><span class="p">,</span> <span class="n">returnval</span></div>


<div class="viewcode-block" id="directed_percolate_network"><a class="viewcode-back" href="../methods.html#EoN.directed_percolate_network">[docs]</a><span class="k">def</span> <span class="nf">directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="c1">#indirectly tested in test_estimate_SIR_prob_size</span>
    <span class="sd">r&#39;&#39;&#39;From figure 6.13 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.  </span>
<span class="sd">    </span>
<span class="sd">    This adds node and edge attributes in the percolated network which </span>
<span class="sd">    are not at present in the figure in the book.  </span>
<span class="sd">    </span>
<span class="sd">    This option is discussed in the text.</span>
<span class="sd">    </span>
<span class="sd">    This performs directed percolation corresponding to an SIR epidemic</span>
<span class="sd">    assuming that transmission is at rate tau and recovery at rate </span>
<span class="sd">    gamma</span>

<span class="sd">    SEE ALSO</span>
<span class="sd">    --------</span>
<span class="sd">    nonMarkov_directed_percolate_network which allows for more complex</span>
<span class="sd">    transmission and recovery rules.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    tau : number</span>
<span class="sd">        transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">        recovery rate</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    H : networkx DiGraph  (directed graph)</span>
<span class="sd">        a u-&gt;v edge exists in H if u would transmit to v if ever </span>
<span class="sd">        infected.</span>
<span class="sd">        </span>
<span class="sd">        The edge has a time attribute (time_to_infect) which gives the </span>
<span class="sd">        delay from infection of u until transmission occurs.</span>
<span class="sd">        </span>
<span class="sd">        Each node u has a time attribute (duration) which gives the </span>
<span class="sd">        duration of its infectious period.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    H = EoN.directed_percolate_network(G, 2, 1)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">time_to_infect</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_to_infect</span><span class="o">&lt;</span><span class="n">duration</span><span class="p">:</span>
                <span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">delay</span><span class="o">=</span><span class="n">time_to_infect</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>
                
<span class="k">def</span> <span class="nf">_out_component_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    rather than following the pseudocode in figure 6.15 of </span>
<span class="sd">        Kiss, Miller &amp; Simon,</span>
<span class="sd">    this uses a built-in Networkx command.  </span>

<span class="sd">    finds the set of nodes (including source) which are reachable from </span>
<span class="sd">    nodes in source.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    source : either a node or an iterable of nodes (set, list, tuple)</span>
<span class="sd">        The nodes from which the infections start.  We assume no node</span>
<span class="sd">        will ever have a name that is an iterable of other node names.</span>
<span class="sd">        It will run, but may not use source user expects.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    reachable_nodes : set</span>
<span class="sd">        the set of nodes reachable from source (including source).</span>


<span class="sd">    Warning: if the graph G has nodes like 1, 2, 3, and (1,2,3), then a</span>
<span class="sd">        source of (1,2,3) is potentially ambiguous.  It will interpret</span>
<span class="sd">        the source as the single node (1,2,3)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">source</span><span class="p">):</span> 
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        
    <span class="n">reachable_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">:</span>
        <span class="n">reachable_nodes</span> <span class="o">=</span> <span class="n">reachable_nodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                                        <span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">reachable_nodes</span>

<span class="k">def</span> <span class="nf">_in_component_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    creates the _in_component_ by basically reversing _out_component_.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    target : a target node (or iterable of target nodes)</span>
<span class="sd">        The node whose infection we are interested in.</span>

<span class="sd">        In principle target could be an iterable, but in this case we </span>
<span class="sd">        would be finding those possible sources whose infection leads to </span>
<span class="sd">        infection of at least one target, not all.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    source_nodes : (set)</span>
<span class="sd">        the set of nodes (including target) from which target is </span>
<span class="sd">        reachable</span>

<span class="sd">    Warning: if the graph G has nodes like 1, 2, 3, and (1,2,3), then a</span>
<span class="sd">        target of (1,2,3) is potentially ambiguous.  It will interpret</span>
<span class="sd">        the target as the single node (1,2,3)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
        <span class="c1">#potential bug if for example G has  nodes like 1, 2, 3, and </span>
        <span class="c1">#(1,2,3).  Then a target of (1,2,3) is ambiguous</span>
        <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">target</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">source_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">:</span>
        <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">source_nodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">source_nodes</span>


<div class="viewcode-block" id="get_infected_nodes"><a class="viewcode-back" href="../methods.html#EoN.get_infected_nodes">[docs]</a><span class="k">def</span> <span class="nf">get_infected_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.15 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this algorithm</span>

<span class="sd">    Finds all eventually infected nodes in a simulation, assuming that </span>
<span class="sd">    the intial infecteds are as given and transmission occurs with rate </span>
<span class="sd">    tau and recovery with rate gamma.  </span>
<span class="sd">    </span>
<span class="sd">    Uses a percolation-based approach.</span>

<span class="sd">    Note that the output of this algorithm is stochastic.</span>
<span class="sd">    </span>
<span class="sd">    This code has similar run-time whether an epidemic occurs or not.</span>
<span class="sd">    There are much faster ways to implement an algorithm giving the same </span>
<span class="sd">    output, for example by actually running an epidemic.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    tau : number</span>
<span class="sd">        transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">        recovery rate</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    infected_nodes : set</span>
<span class="sd">        the set of nodes infected eventually in a simulation.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    finalR = EoN.get_infected_nodes(G, 2, 1, initial_infecteds=[0, 5])</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    finds the nodes infected if 0 and 5 are the initial nodes infected</span>
<span class="sd">    and tau=2, gamma=1</span>
<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="n">infected_nodes</span> <span class="o">=</span> <span class="n">_out_component_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">infected_nodes</span></div>


<div class="viewcode-block" id="estimate_directed_SIR_prob_size"><a class="viewcode-back" href="../methods.html#EoN.estimate_directed_SIR_prob_size">[docs]</a><span class="k">def</span> <span class="nf">estimate_directed_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="c1">#tested in test_estimate_SIR_prob_size</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Predicts probability and attack rate assuming continuous-time </span>
<span class="sd">    Markovian SIR disease on network G</span>
<span class="sd">    </span>
<span class="sd">    SEE ALSO</span>
<span class="sd">    --------</span>
<span class="sd">    estimate_nonMarkov_SIR_prob_size which handles nonMarkovian versions</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The network the disease will transmit through.</span>
<span class="sd">    tau : number</span>
<span class="sd">        transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">        recovery rate</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    PE, AR  :  numbers (between 0 and 1)</span>
<span class="sd">        Estimates of epidemic probability and attack rate found by </span>
<span class="sd">        performing directed percolation, finding largest strongly </span>
<span class="sd">        connected component and finding its in/out components.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.003)</span>
<span class="sd">    PE, AR = EoN.estimate_directed_SIR_prob_size(G, 2, 1)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">H</span> <span class="o">=</span> <span class="n">directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimate_SIR_prob_size_from_dir_perc</span><span class="p">(</span><span class="n">H</span><span class="p">)</span></div>

<div class="viewcode-block" id="estimate_SIR_prob_size_from_dir_perc"><a class="viewcode-back" href="../methods.html#EoN.estimate_SIR_prob_size_from_dir_perc">[docs]</a><span class="k">def</span> <span class="nf">estimate_SIR_prob_size_from_dir_perc</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
    <span class="c1">#indirectly tested in test_estimate_SIR_prob_size</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.17 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this algorithm</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    H:  directed graph (assumed to be from directed percolation on </span>
<span class="sd">        previous graph G)</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    PE, AR  :  numbers</span>
<span class="sd">        Estimates of epidemic probability and attack rate found by </span>
<span class="sd">        finding largest strongly connected component and finding in/out </span>
<span class="sd">        components.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.003)</span>
<span class="sd">    H = some_user_defined_operation_to_do_percolation(G, argument)</span>
<span class="sd">    PE, AR = EoN.estimate_SIR_prob_size_from_dir_perc(H)</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">Hscc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">nx</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">H</span><span class="p">)),</span> <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Hscc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">#random.choice(Hscc)</span>
    <span class="n">inC</span> <span class="o">=</span> <span class="n">_in_component_</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="c1">#includes both H_{IN} and H_{SCC}</span>
    <span class="n">outC</span> <span class="o">=</span> <span class="n">_out_component_</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="c1">#includes both H_{OUT} and H_{SCC}</span>
    <span class="n">N</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>
    <span class="n">PE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inC</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">AR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outC</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="k">return</span> <span class="n">PE</span><span class="p">,</span> <span class="n">AR</span></div>
 
<div class="viewcode-block" id="estimate_nonMarkov_SIR_prob_size"><a class="viewcode-back" href="../methods.html#EoN.estimate_nonMarkov_SIR_prob_size">[docs]</a><span class="k">def</span> <span class="nf">estimate_nonMarkov_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> 
                                        <span class="n">transmission</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The input graph</span>

<span class="sd">    xi : dict</span>
<span class="sd">        xi[u] gives all necessary information to determine what u&#39;s </span>
<span class="sd">        infectiousness is.</span>
<span class="sd">    zeta : dict</span>
<span class="sd">        zeta[v] gives everything needed about v&#39;s susceptibility</span>

<span class="sd">    transmission : user-defined function</span>
<span class="sd">        transmission(xi[u], zeta[v]) determines whether u transmits to </span>
<span class="sd">        v.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    PE, AR  :  numbers (between 0 and 1)</span>
<span class="sd">        Estimates of epidemic probability and attack rate found by </span>
<span class="sd">        finding largest strongly connected component and finding in/out </span>
<span class="sd">        components.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    #mimicking the standard version with transmission rate tau</span>
<span class="sd">    #and recovery rate gamma</span>
<span class="sd">    </span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import random</span>
<span class="sd">    from collections import defaultdict</span>
<span class="sd">    </span>
<span class="sd">    G=nx.fast_gnp_random_graph(1000,0.002)</span>
<span class="sd">    tau = 2</span>
<span class="sd">    gamma = 1</span>

<span class="sd">    xi = {node:random.expovariate(gamma) for node in G.nodes()}  </span>
<span class="sd">    #xi[node] is duration of infection of node.</span>
<span class="sd">        </span>
<span class="sd">    zeta = defaultdict(lambda : tau) #every node has zeta=tau, so same </span>
<span class="sd">                                     #transmission rate</span>
<span class="sd">    </span>
<span class="sd">    def my_transmission(infection_duration, trans_rate):</span>
<span class="sd">        #infect if duration is longer than time to infection.</span>
<span class="sd">        if infection_duration &gt; random.expovariate(trans_rate):</span>
<span class="sd">            return True</span>
<span class="sd">        else:  </span>
<span class="sd">            return False</span>
<span class="sd">    </span>
<span class="sd">    PE, AR = EoN.estimate_nonMarkov_SIR_prob_size(G, xi, zeta, </span>
<span class="sd">                                                    my_transmission)</span>
<span class="sd">        </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">nonMarkov_directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> <span class="n">transmission</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimate_SIR_prob_size_from_dir_perc</span><span class="p">(</span><span class="n">H</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="nonMarkov_directed_percolate_network"><a class="viewcode-back" href="../methods.html#EoN.nonMarkov_directed_percolate_network">[docs]</a><span class="k">def</span> <span class="nf">nonMarkov_directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> <span class="n">transmission</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure 6.18 of Kiss, Miller, &amp; Simon.  </span>
<span class="sd">    Please cite the book if using this algorithm.</span>

<span class="sd">    xi and zeta are dictionaries of whatever data is needed so that </span>
<span class="sd">    xi[u] and zeta[v] </span>
<span class="sd">    are enough to determine the probability of a u-v transmission.</span>

<span class="sd">    transmissision is a user-defined function taking xi[u] and zeta[v] </span>
<span class="sd">    and returning True if a transmission would occur</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">        The input graph</span>

<span class="sd">    xi : dict</span>
<span class="sd">        xi[u] gives all necessary information to determine what us </span>
<span class="sd">        infectiousness is.</span>
<span class="sd">    zeta : dict</span>
<span class="sd">        zeta[v] gives everything needed about vs susceptibility</span>

<span class="sd">    transmission : user-defined function</span>
<span class="sd">        transmission(xi[u], zeta[v]) determines whether u transmits to </span>
<span class="sd">        v.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    networkx DiGraph (directed graph) H.  </span>
<span class="sd">    Edge u,v exists in H if it will transmit given the opportunity.</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    for now, I&#39;m being lazy.  </span>
<span class="sd">    Look at the sample for estimate_nonMarkov_SIR_prob_size to infer it.</span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">H</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">transmission</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">zeta</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>
                <span class="n">H</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>
    
    
    
    
<span class="c1">### Code starting here does event-driven simulations###</span>

<span class="k">def</span> <span class="nf">_find_trans_SIR_</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">pred_inf_time</span><span class="p">,</span> 
                        <span class="n">cutoff_time</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure A.4 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this algorithm.</span>

<span class="sd">    This involves a couple additional dicts because the pseudocode is </span>
<span class="sd">    written as if the nodes are a separate class.  </span>
<span class="sd">    </span>
<span class="sd">    I find it easier to have a dict for that since I don&#39;t have control </span>
<span class="sd">    over the input graph.</span>

<span class="sd">    Determines if a transmission from source to target will occur and if</span>
<span class="sd">    so puts into Q</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    Q : A priority queue of events</span>
<span class="sd">    t : current time</span>
<span class="sd">    tau : transmission rate</span>
<span class="sd">    source : infected node that may transmit</span>
<span class="sd">    target : the possibly susceptible node that may receive a </span>
<span class="sd">             transmission</span>
<span class="sd">    status : a dict giving the current status of every node</span>
<span class="sd">    pred_inf_time : a dict giving a predicted infection time of </span>
<span class="sd">                    susceptible nodes (defaults to inf)</span>
<span class="sd">    cutoff_time : either tmax or rec_time[source], whichever is first.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    Nothing returned</span>

<span class="sd">    MODIFIES</span>
<span class="sd">    --------</span>
<span class="sd">    Q : Adds transmission events to Q</span>
<span class="sd">    pred_inf_time : updates predicted infection time of target.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">inf_time</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">delay</span>
        <span class="k">if</span> <span class="n">inf_time</span><span class="o">&lt;</span> <span class="n">cutoff_time</span> <span class="ow">and</span> <span class="n">inf_time</span> <span class="o">&lt;</span> <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">inf_time</span><span class="p">,</span> <span class="s1">&#39;transmit&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
            <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">inf_time</span>

<span class="k">def</span> <span class="nf">_process_trans_SIR_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">,</span> 
                            <span class="n">pred_inf_time</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmax</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    From figure A.3 of Kiss, Miller, &amp; Simon.  Please cite the book if </span>
<span class="sd">    using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">    event : event</span>
<span class="sd">         has details on node and time</span>
<span class="sd">    times : list</span>
<span class="sd">        list of times at which events have happened</span>
<span class="sd">    S, I, R : lists</span>
<span class="sd">        lists of numbers of nodes of each status at each time</span>
<span class="sd">    Q : heapq heap</span>
<span class="sd">        the queue of events</span>
<span class="sd">    status : dict</span>
<span class="sd">        dictionary giving status of each node</span>
<span class="sd">    rec_time : dict</span>
<span class="sd">        dictionary giving recovery time of each node</span>
<span class="sd">    pred_inf_time : dict</span>
<span class="sd">        dictionary giving predicted infeciton time of nodes </span>
<span class="sd">    tmax : number</span>
<span class="sd">        max time allowed</span>
<span class="sd">    tau : number</span>
<span class="sd">        transmission rate (from node)</span>
<span class="sd">    gamma : number</span>
<span class="sd">        recovery rate (of node)</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    nothing returned</span>

<span class="sd">    MODIFIES</span>
<span class="sd">    --------</span>
<span class="sd">    status : updates status of newly infected node</span>
<span class="sd">    rec_time : adds recovery time for node</span>
<span class="sd">    times : appends time of event</span>
<span class="sd">    S : appends new S (reduced by 1 from last)</span>
<span class="sd">    I : appends new I (increased by 1)</span>
<span class="sd">    R : appends new R (same as last)</span>
<span class="sd">    Q : adds recovery and transmission events for newly infected node.</span>
<span class="sd">    pred_inf_time : updated for nodes that will receive transmission</span>
<span class="sd">                    update happens in _find_trans_SIR_</span>

<span class="sd">    Entry requirement:</span>
<span class="sd">    -------</span>
<span class="sd">    Only enter this if the node is SUSCEPTIBLE and is becoming INFECTED.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">node</span>  <span class="c1">#The node that is receiving transmission</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>  <span class="c1">#current time</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
    <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span> 
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one less susceptible</span>
    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one more infected</span>
    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">#no change to recovered</span>
    <span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">:</span>
        <span class="n">newevent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="s1">&#39;recover&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">newevent</span><span class="p">)</span>
    <span class="n">cutoff_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tmax</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">_find_trans_SIR_</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">pred_inf_time</span><span class="p">,</span> 
                            <span class="n">cutoff_time</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_process_recovery_SIR_</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.3 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    event : event</span>
<span class="sd">         has details on node and time</span>
<span class="sd">    times : list</span>
<span class="sd">        list of times at which events have happened</span>
<span class="sd">    S, I, R : lists</span>
<span class="sd">        lists of numbers of nodes of each status at each time</span>
<span class="sd">    status : dict</span>
<span class="sd">        dictionary giving status of each node</span>


<span class="sd">    RETURNS</span>
<span class="sd">    ----------</span>
<span class="sd">    Nothing</span>

<span class="sd">    MODIFIES</span>
<span class="sd">    ----------</span>
<span class="sd">    status : updates status of newly recovered node</span>
<span class="sd">    times : appends time of event</span>
<span class="sd">    S : appends new S (same as last)</span>
<span class="sd">    I : appends new I (decreased by 1)</span>
<span class="sd">    R : appends new R (increased by 1)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">node</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">#no change to number susceptible</span>
    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one less infected</span>
    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one more recovered</span>
    <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;R&#39;</span>
    
    
<div class="viewcode-block" id="fast_SIR"><a class="viewcode-back" href="../methods.html#EoN.fast_SIR">[docs]</a><span class="k">def</span> <span class="nf">fast_SIR</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                <span class="n">tmax</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">),</span> <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_SIR_dynamics</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.2 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    fast SIR simulation assuming exponentially distributed infection and</span>
<span class="sd">    recovery times</span>
<span class="sd">    </span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">       The underlying network</span>
<span class="sd">    tau : number</span>
<span class="sd">       transmission rate per edge</span>
<span class="sd">    gamma : number</span>
<span class="sd">       recovery rate per node</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    tmax : number</span>
<span class="sd">       maximum time after which simulation will stop.</span>
<span class="sd">       default float(&#39;Inf&#39;) to set to infinity.  </span>
<span class="sd">       Okay for SIR, not for SIS.</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, infection_time and </span>
<span class="sd">        recovery_time.</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    times, S, I, R : each a scipy array</span>
<span class="sd">         giving times and number in each status for corresponding time</span>

<span class="sd">    OR if return_node_data=True:</span>
<span class="sd">    times, S, I, R, infection_time, recovery_time</span>
<span class="sd">         first four are scipy arrays as above.  New objects are dicts</span>
<span class="sd">         with entries just for those nodes that were infected ever</span>
<span class="sd">         infection_time[node] is time of infection</span>
<span class="sd">         recovery_time[node] is time of recovery</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([1,5,10]*100000)</span>
<span class="sd">    initial_size = 10000</span>
<span class="sd">    gamma = 1.</span>
<span class="sd">    tau = 0.3</span>
<span class="sd">    t, S, I, R = EoN.fast_SIR(G, tau, gamma, </span>
<span class="sd">                                initial_infecteds = range(initial_size))</span>
<span class="sd">                                </span>
<span class="sd">    plt.plot(t, I)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>


    <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span><span class="c1">#an empty heap</span>
        
    <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#node status defaults to &#39;S&#39;</span>
    <span class="n">rec_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#node recovery time defaults to -1</span>
    <span class="n">pred_inf_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">))</span> 
    <span class="c1">#infection time defaults to \infty  --- this could be set to tmax, </span>
    <span class="c1">#probably with a slight improvement to performance.</span>
    <span class="c1">#Note that if node becomes infected, pred_inf_time is actually inf_time</span>
    <span class="c1">#and similarly for rec_time rec_time is correct.  </span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
        <span class="n">newevent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;transmit&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">newevent</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;transmit&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> 
                <span class="n">_process_trans_SIR_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                                    <span class="n">rec_time</span><span class="p">,</span> <span class="n">pred_inf_time</span><span class="p">,</span>  <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_process_recovery_SIR_</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="c1">#the initial infections were treated as ordinary infection events at </span>
    <span class="c1">#time 0.</span>
    <span class="c1">#So each initial infection added an entry at time 0 to lists.</span>
    <span class="c1">#We&#39;d like to get rid these excess events.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):]</span>
    <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):]</span>
    <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):]</span>
    <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="c1"># ignoring initial value entered.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#strip pred_inf_time and rec_time down to just the </span>
        <span class="c1">#    values for nodes that became infected</span>
        <span class="n">infection_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">time</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">time</span><span class="p">)</span>     
                            <span class="ow">in</span> <span class="n">pred_inf_time</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> 
                            <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;S&#39;</span><span class="p">}</span>
        <span class="n">recovery_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">time</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">time</span><span class="p">)</span> 
                            <span class="ow">in</span> <span class="n">rec_time</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span><span class="s1">&#39;S&#39;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">infection_time</span><span class="p">,</span> <span class="n">recovery_time</span></div>

<div class="viewcode-block" id="fast_nonMarkov_SIR"><a class="viewcode-back" href="../methods.html#EoN.fast_nonMarkov_SIR">[docs]</a><span class="k">def</span> <span class="nf">fast_nonMarkov_SIR</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">process_trans</span> <span class="o">=</span> <span class="n">_process_trans_SIR_</span><span class="p">,</span> 
                        <span class="n">args</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">tmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">),</span> <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                        <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    A modification of the algorithm in figure A.2 of Kiss, Miller, &amp; </span>
<span class="sd">    Simon to allow for user-defined rules governing time of </span>
<span class="sd">    transmission.  </span>
<span class="sd">    </span>
<span class="sd">    Please cite the book if using this algorithm.</span>

<span class="sd">    This is useful if the transmission rule is non-Markovian in time, or</span>
<span class="sd">    for more elaborate models.  </span>
<span class="sd">    </span>
<span class="sd">    For example if there is a mass action style transmission this can be</span>
<span class="sd">    incorporated into the process_trans command defined by user.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : Networkx Graph</span>
<span class="sd">    </span>
<span class="sd">    process_trans : a function that handles a transmission event.</span>
<span class="sd">                    Called by </span>
<span class="sd">                        process_trans(G, event, times, S, I, R, Q, </span>
<span class="sd">                           status, rec_time, pred_inf_time, tmax, *args)</span>
<span class="sd">                    must update :   status, rec_time, times, S, I, R,</span>
<span class="sd">                    must also update : Q, pred_inf_time.</span>
<span class="sd">                    In updating these last two, it calculates the </span>
<span class="sd">                       recovery time, and adds the event to Q.  </span>
<span class="sd">                    It then calculates predicted times of transmission </span>
<span class="sd">                       to neighbors.  </span>
<span class="sd">                    If before current earliest prediction, it will add</span>
<span class="sd">                       appropriate transmission event to Q and update </span>
<span class="sd">                       this prediction.</span>
<span class="sd">                       </span>
<span class="sd">    args: The final arguments going into process_trans.  </span>
<span class="sd">          If there is some reason to collect data about node that is </span>
<span class="sd">          only calculated when transmission occurs it can modify a dict </span>
<span class="sd">          or something similar that is passed as an argument.</span>
<span class="sd">    </span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, infection_time and </span>
<span class="sd">        recovery_time.</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time</span>

<span class="sd">    </span>
<span class="sd">         If Q is defined:</span>
<span class="sd">             Then initial_infecteds consists of those nodes infected </span>
<span class="sd">             **PRIOR** to t=0.  </span>
<span class="sd">             Those infected at t=0 will be handled by being in Q </span>
<span class="sd">             already.</span>
<span class="sd">    tmax : (default infinity)</span>
<span class="sd">        final time</span>
<span class="sd">    return_node_data : boolean (default False)</span>
<span class="sd">    Q : If user wants to predefine some events, this can be done.  This </span>
<span class="sd">        can be input as a heap or as a list (it will be heapified and </span>
<span class="sd">        modified).</span>
<span class="sd">        </span>
<span class="sd">        User should understand the Event class and use it.  </span>
<span class="sd">        </span>
<span class="sd">        Currently there is no guarantee this is properly supported,</span>
<span class="sd">        so much so that right now I&#39;m going to force the user to edit </span>
<span class="sd">        the source code before trying it.  </span>
<span class="sd">        </span>
<span class="sd">        I am reasonably confident it will work.</span>

<span class="sd">        When Q is input, initial_infecteds should be the of nodes in </span>
<span class="sd">        I class **PRIOR** to t=0, and the events in Q must have all of </span>
<span class="sd">        their recoveries.  </span>
<span class="sd">        </span>
<span class="sd">        The best way to handle nodes that should be already recovered is </span>
<span class="sd">        to put them in initial_infecteds and give them a recovery event </span>
<span class="sd">        at t=0.</span>


<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    times, S, I, R : each a scipy array</span>
<span class="sd">         giving times and number in each status for corresponding time</span>

<span class="sd">    OR if return_node_data=True:</span>
<span class="sd">    times, S, I, R, infection_time, recovery_time</span>
<span class="sd">         first four are scipy arrays as above.  New objects are dicts</span>
<span class="sd">         with entries just for those nodes that were infected ever</span>
<span class="sd">         infection_time[node] is time of infection</span>
<span class="sd">         recovery_time[node] is time of recovery</span>

<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">process_trans</span> <span class="o">==</span> <span class="n">_process_trans_SIR_</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>  
            <span class="c1">#better be able to make args be two floats.</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;if using default for fast_nonMarkov_SIR, then </span><span class="se">\</span>
<span class="s2">                            args should be (tau,gamma)</span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                            Consider just using fast_SIR.&quot;</span><span class="p">)</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#node status defaults to &#39;S&#39;</span>
    <span class="n">rec_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#node recovery time defaults to -1</span>
    <span class="n">pred_inf_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">))</span> 
        <span class="c1">#infection time defaults to \infty  --- this could be set to tmax, </span>
        <span class="c1">#probably with a slight improvement to performance.</span>
    
    <span class="k">if</span> <span class="n">Q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
        <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
            <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
            <span class="n">newevent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;transmit&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">newevent</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;inputting Q is not currently tested.</span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                        Email joel.c.miller.research@gmail.com for help.</span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">                        I believe this code will work, but you will need to </span><span class="se">\</span>
<span class="s2">                        delete this message.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#assuming that input Q has this </span>
                                    <span class="c1">#taken care of </span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
            <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
            <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;transmit&#39;</span> <span class="ow">and</span> \
                            <span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="o">&lt;</span><span class="n">pred_inf_time</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">pred_inf_time</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;recover&#39;</span><span class="p">:</span>
                <span class="n">rec_time</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>            
        <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
        
    
    <span class="c1">#Note that when finally infected, pred_inf_time is correct</span>
    <span class="c1">#and rec_time is correct.  </span>
    <span class="c1">#So if return_node_data is true, these are correct</span>

    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;transmit&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> 
                <span class="n">process_trans</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                                <span class="n">rec_time</span><span class="p">,</span> <span class="n">pred_inf_time</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_process_recovery_SIR_</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
               <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#strip pred_inf_time and rec_time down to just the values for nodes </span>
        <span class="c1">#that became infected</span>
        <span class="n">infection_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">time</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> 
                            <span class="n">pred_inf_time</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;S&#39;</span><span class="p">}</span>
        <span class="n">recovery_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">time</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> 
                                <span class="n">rec_time</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span><span class="s1">&#39;S&#39;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">infection_time</span><span class="p">,</span> <span class="n">recovery_time</span></div>


<span class="k">def</span> <span class="nf">_process_trans_SIS_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                        <span class="n">rec_time</span><span class="p">,</span> <span class="n">tmax</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.5 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">    event: event</span>
<span class="sd">        has details on node and time</span>
<span class="sd">    tau : number</span>
<span class="sd">        transmission rate (from node)</span>
<span class="sd">    gamma : number</span>
<span class="sd">        recovery rate (of node)</span>
<span class="sd">    times : list</span>
<span class="sd">        list of times at which events have happened</span>
<span class="sd">    S, I: lists</span>
<span class="sd">        lists of numbers of nodes of each status at each time</span>
<span class="sd">    Q : heapq heap</span>
<span class="sd">        the queue of events</span>
<span class="sd">    status : dict</span>
<span class="sd">        dictionary giving status of each node</span>
<span class="sd">    rec_time : dict</span>
<span class="sd">        dictionary giving recovery time of each node</span>
<span class="sd">    pred_inf_time : dict</span>
<span class="sd">        dictionary giving predicted infeciton time of nodes </span>
<span class="sd">    tmax : max time allowed</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    nothing returned</span>

<span class="sd">    MODIFIES</span>
<span class="sd">    --------</span>
<span class="sd">    status : updates status of newly infected node</span>
<span class="sd">    rec_time : adds recovery time for node</span>
<span class="sd">    times : appends time of event</span>
<span class="sd">    S : appends new S (reduced by 1 from last)</span>
<span class="sd">    I : appends new I (increased by 1)</span>
<span class="sd">    Q : adds recovery and transmission events for newly infected node.</span>

<span class="sd">    Entry requirement:</span>
<span class="sd">    -------</span>
<span class="sd">    Only enter this if the node is SUSCEPTIBLE and is becoming INFECTED.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">node</span>  <span class="c1">#The node that is receiving transmission</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>  <span class="c1">#current time</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
    <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one more infected</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one less susceptible</span>
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">:</span>
        <span class="n">newevent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">rec_time</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="s1">&#39;recover&#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">newevent</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">_find_next_trans_SIS_</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_find_next_trans_SIS_</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">,</span> 
                            <span class="n">tmax</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.3 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>


<span class="sd">    determines if a transmission from source to target will occur and if </span>
<span class="sd">    so puts into Q</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    Q : A priority queue of events</span>
<span class="sd">    t : current time</span>
<span class="sd">    tau : transmission rate</span>
<span class="sd">    source : infected node that may transmit</span>
<span class="sd">    target : the possibly susceptible node that may receive a </span>
<span class="sd">             transmission</span>
<span class="sd">    status : a dict giving the current status of every node</span>
<span class="sd">    rec_time : a dict giving the recovery time of every node that has </span>
<span class="sd">               been infected.  </span>
<span class="sd">    tmax : max time for simulation.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    nothing returned</span>

<span class="sd">    MODIFIES</span>
<span class="sd">    --------</span>
<span class="sd">    Q : if a transmission time is potentially valid, add the first </span>
<span class="sd">        event.</span>
<span class="sd">        when this transmission occurs later we will consider adding </span>
<span class="sd">        another event.</span>
<span class="sd">        note that the event includes the source, so we can later check </span>
<span class="sd">        if same source will transmit again.</span>

<span class="sd">    Entry requirement:</span>
<span class="sd">    -------</span>
<span class="sd">    Only enter this if the source node is INFECTED.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">&lt;</span><span class="n">rec_time</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span> 
        <span class="c1">#if target is susceptible, then rec_time[target]&lt;time</span>
        <span class="n">transmission_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">target</span><span class="p">])</span> \
                            <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transmission_time</span> <span class="o">&lt;</span> <span class="n">rec_time</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="ow">and</span> <span class="n">transmission_time</span><span class="o">&lt;</span><span class="n">tmax</span><span class="p">:</span>
            <span class="n">newEvent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">transmission_time</span><span class="p">,</span> <span class="s1">&#39;transmit&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">newEvent</span><span class="p">)</span>


 
<span class="k">def</span> <span class="nf">_process_recovery_SIS_</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.4 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">node</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>

    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1">#no change to number susceptible</span>
    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#one less infected</span>
    <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span>




<div class="viewcode-block" id="fast_SIS"><a class="viewcode-back" href="../methods.html#EoN.fast_SIS">[docs]</a><span class="k">def</span> <span class="nf">fast_SIS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;From figure A.5 of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">       The underlying network</span>
<span class="sd">    tau : number</span>
<span class="sd">       transmission rate per edge</span>
<span class="sd">    gamma : number</span>
<span class="sd">       recovery rate per node</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, infection_time and </span>
<span class="sd">        recovery_time.</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    times, S, I : each a scipy array</span>
<span class="sd">         giving times and number in each status for corresponding time</span>

<span class="sd">    OR if return_node_data=True:</span>
<span class="sd">    times, S, I, infection_time, recovery_time</span>
<span class="sd">         first four are scipy arrays as above.  New objects are dicts</span>
<span class="sd">         with entries just for those nodes that were infected ever</span>
<span class="sd">         infection_time[node] is a list of times of infection</span>
<span class="sd">         recovery_time[node] is a list of times of recovery</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([1,5,10]*100000)</span>
<span class="sd">    initial_size = 10000</span>
<span class="sd">    gamma = 1.</span>
<span class="sd">    tau = 0.2</span>
<span class="sd">    t, S, I = EoN.fast_SIS(G, tau, gamma, tmax = 10,</span>
<span class="sd">                                initial_infecteds = range(initial_size))</span>
<span class="sd">                                </span>
<span class="sd">    plt.plot(t, I)</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>

    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#node status defaults to &#39;S&#39;</span>
    <span class="n">rec_time</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#node recovery time defaults to -1</span>
    <span class="n">rec_time</span><span class="p">[</span><span class="s1">&#39;initial_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">infection_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span> <span class="c1">#defaults to empty list</span>
    <span class="n">recovery_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>

    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
        <span class="n">newevent</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;transmit&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;initial_condition&#39;</span><span class="p">)</span>
        <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newevent</span><span class="p">)</span>  <span class="c1">#okay to append rather than heappush since </span>
                            <span class="c1">#all are at same time</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="o">&lt;=</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">node</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;transmit&#39;</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">source</span>
            <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">_process_trans_SIS_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> 
                                    <span class="n">status</span><span class="p">,</span> <span class="n">rec_time</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>
                <span class="n">infection_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">source</span> <span class="o">!=</span> <span class="s1">&#39;initial_condition&#39;</span><span class="p">:</span>
                <span class="n">_find_next_trans_SIS_</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                                        <span class="n">rec_time</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_process_recovery_SIS_</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
            <span class="n">recovery_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">infection_times</span><span class="p">,</span> <span class="n">recovery_times</span></div>



<span class="c1">#someday it might be nice to add a non-Markovian SIS version here</span>




<span class="c1">#####Now dealing with Gillespie code#####</span>

<span class="k">def</span> <span class="nf">_Gillespie_Initialize_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="p">,</span> <span class="n">infection_times</span><span class="p">,</span> 
                            <span class="n">return_node_data</span><span class="p">,</span> <span class="n">SIR</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Initializes the network&#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">)]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">)]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#by default all are susceptible</span>
    <span class="n">infected</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">)</span>
    <span class="n">infected_neighbor_count</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span><span class="c1">#</span>
    <span class="n">risk_group</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="n">_ListDict_</span><span class="p">())</span> 
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
        <span class="n">status</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;I&#39;</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                                                                    <span class="n">neighbor</span><span class="p">)</span>
                <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">initial_infecteds</span><span class="p">:</span>
            <span class="n">infection_times</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> \
                <span class="n">risk_group</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> \
                <span class="n">risk_group</span>
    
<span class="k">def</span> <span class="nf">_Gillespie_Infect_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">current_time</span><span class="p">,</span> 
                        <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                        <span class="n">infection_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Chooses the node to infect.</span>

<span class="sd">    First chooses which risk_group the node is in.  </span>
<span class="sd">    Then choose the node.</span>

<span class="sd">    An alternative which may be cleaner (not sure about faster?) is to </span>
<span class="sd">    create a data type which tracks maximum risk.  </span>
<span class="sd">    </span>
<span class="sd">    Then choose a random node and do a rejection sampling step.  </span>
<span class="sd">    </span>
<span class="sd">    If rejected, then select again.  </span>
<span class="sd">    </span>
<span class="sd">    May need a very careful rejection sampling to account for repeated </span>
<span class="sd">    selection.  </span>
<span class="sd">    </span>
<span class="sd">    We could probably define this as a method of the class.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">r</span><span class="o">-=</span> <span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1">#we&#39;ve got n now</span>

    <span class="n">recipient</span> <span class="o">=</span> <span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">choose_random</span><span class="p">()</span>
        <span class="c1">#OLD VERSION choose random element from dict</span>
        <span class="c1">#based on http://stackoverflow.com/a/24949742/2966723</span>
        <span class="c1">#question by http://stackoverflow.com/users/2237265/jamyn</span>
        <span class="c1">#answer by http://stackoverflow.com/users/642757/scott-ritchie</span>
        <span class="c1">#</span>
        <span class="c1">#CURRENT VERSION</span>
        <span class="c1">#http://stackoverflow.com/a/15993515/2966723</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="n">recipient</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
    <span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">recipient</span><span class="p">)</span>
    <span class="n">infected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recipient</span><span class="p">)</span>
    <span class="n">infection_times</span><span class="p">[</span><span class="n">recipient</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
    <span class="n">status</span><span class="p">[</span><span class="n">recipient</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;I&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SIR</span><span class="p">:</span>
        <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">recipient</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;S&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
    
            

<span class="k">def</span> <span class="nf">_Gillespie_Recover_SIR_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">current_time</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
                            <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span><span class="p">,</span> 
                            <span class="n">recovery_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39; Changes: S, I, R, infected, times&#39;&#39;&#39;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">infected</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">infected</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">infected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">infected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">infected</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> 
            <span class="c1">#http://stackoverflow.com/a/14088129/2966723</span>
    <span class="n">recovering_node</span> <span class="o">=</span> <span class="n">infected</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">status</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;R&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">recovering_node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="c1">#neighbor susceptible, </span>
                                    <span class="c1">#its risk just got smaller</span>
            <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>            
    <span class="k">if</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="n">recovery_times</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_Gillespie_Recover_SIS_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">current_time</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                            <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span><span class="p">,</span> 
                            <span class="n">recovery_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39; x&#39;&#39;&#39;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">infected</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">infected</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">infected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">infected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">infected</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> 
                    <span class="c1">#http://stackoverflow.com/a/14088129/2966723</span>
    <span class="n">recovering_node</span> <span class="o">=</span> <span class="n">infected</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">status</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;S&#39;</span>
    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
    <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">recovering_node</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">recovering_node</span><span class="p">:</span>
	    <span class="k">continue</span>  <span class="c1">#Deals with selfloops</span>
                <span class="c1">#there is probably a good way to count the </span>
                <span class="c1">#number of infected neighbors</span>
        <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#neighbor susceptible, its risk just got smaller</span>
            <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">risk_group</span><span class="p">[</span><span class="n">infected_neighbor_count</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                                                            <span class="n">recovering_node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="n">recovery_times</span><span class="p">[</span><span class="n">recovering_node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>

<div class="viewcode-block" id="Gillespie_SIR"><a class="viewcode-back" href="../methods.html#EoN.Gillespie_SIR">[docs]</a><span class="k">def</span> <span class="nf">Gillespie_SIR</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">),</span> 
                    <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_SIR_dynamics</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Performs a Gillespie-based SIR simulation.</span>

<span class="sd">    Assumes that the network is unweighted.  </span>
<span class="sd">    </span>
<span class="sd">    Thus the risks are quantized: equal to tau times the number of </span>
<span class="sd">    infected neighbors of a node.</span>
<span class="sd">    </span>
<span class="sd">    This would not be as good if the edges were weighted, but we could </span>
<span class="sd">    put the at_risk nodes into bands.</span>
<span class="sd">    </span>
<span class="sd">    At present the network is treated as unweighted, so the possible </span>
<span class="sd">    risk rates are discretized.</span>
<span class="sd">    </span>
<span class="sd">    The event-driven simulation is almost certainly faster in all cases, </span>
<span class="sd">    and the benefit would increase if the network were weighted.  </span>
<span class="sd">    </span>
<span class="sd">    I think the coding would also be easier.</span>

<span class="sd">    SEE ALSO</span>
<span class="sd">    --------</span>
<span class="sd">    fast_SIR which has the same inputs but uses a different method to </span>
<span class="sd">    run much faster</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">       The underlying network</span>
<span class="sd">    tau : number</span>
<span class="sd">       transmission rate per edge</span>
<span class="sd">    gamma : number</span>
<span class="sd">       recovery rate per node</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, infection_time and </span>
<span class="sd">        recovery_time.</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time.</span>

<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([1,5,10]*100000)</span>
<span class="sd">    initial_size = 10000</span>
<span class="sd">    gamma = 1.</span>
<span class="sd">    tau = 0.3</span>
<span class="sd">    t, S, I, R = EoN.fast_SIR(G, tau, gamma, </span>
<span class="sd">                                initial_infecteds = range(initial_size))</span>
<span class="sd">                                </span>
<span class="sd">    plt.plot(t, I)</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">infection_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span> <span class="c1">#defaults to an empty list for each node</span>
    <span class="n">recovery_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>

    <span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1">#just to avoid integer division problems.</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>

    <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span> <span class="o">=</span> \
                    <span class="n">_Gillespie_Initialize_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="p">,</span> 
                                            <span class="n">infection_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">)</span>

    <span class="n">total_trans_rate</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> 
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">total_rec_rate</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">infected</span><span class="p">)</span>
    <span class="n">total_rate</span> <span class="o">=</span> <span class="n">total_rec_rate</span> <span class="o">+</span> <span class="n">total_trans_rate</span>
    <span class="n">next_time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">total_rate</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">next_time</span><span class="o">&lt;</span><span class="n">tmax</span> <span class="ow">and</span> <span class="n">infected</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="n">total_rate</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">&lt;</span><span class="n">total_rec_rate</span><span class="p">:</span>
            <span class="c1">#a recovery occurs</span>
            <span class="n">_Gillespie_Recover_SIR_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">next_time</span><span class="p">,</span> 
                                    <span class="n">status</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> 
                                    <span class="n">risk_group</span><span class="p">,</span> <span class="n">recovery_times</span><span class="p">,</span> 
                                    <span class="n">return_node_data</span><span class="p">)</span>
            <span class="n">total_rec_rate</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#an infection occurs</span>
            <span class="n">_Gillespie_Infect_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">next_time</span><span class="p">,</span> 
                                <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                                <span class="n">infection_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">total_trans_rate</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> 
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="n">total_rec_rate</span> <span class="o">+</span> <span class="n">total_trans_rate</span>
        <span class="k">if</span> <span class="n">total_rate</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>  
            <span class="n">next_time</span> <span class="o">+=</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">total_rate</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#need to change data type of infection_times and recovery_times</span>
        <span class="n">infection_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">infection_times</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">recovery_time</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">recovery_times</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">infection_time</span><span class="p">,</span> <span class="n">recovery_time</span></div>



<div class="viewcode-block" id="Gillespie_SIS"><a class="viewcode-back" href="../methods.html#EoN.Gillespie_SIS">[docs]</a><span class="k">def</span> <span class="nf">Gillespie_SIS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                    <span class="n">return_node_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    This could be made more efficient if we divide the at_risk nodes </span>
<span class="sd">    into groups based on how at risk they are. </span>
<span class="sd">    </span>
<span class="sd">    This would not be as good if the edges were weighted, but we could </span>
<span class="sd">    put the at_risk nodes into bands.</span>

<span class="sd">    Warning: self-edges will cause this to die.  </span>
<span class="sd">    You can remove self-edges by G.remove_edges_from(G.selfloop_edges())</span>

<span class="sd">    SEE ALSO</span>
<span class="sd">    --------</span>
<span class="sd">    fast_SIS which has the same inputs but uses a much faster method.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : NetworkX Graph</span>
<span class="sd">       The underlying network</span>
<span class="sd">    tau : number</span>
<span class="sd">       transmission rate per edge</span>
<span class="sd">    gamma : number</span>
<span class="sd">       recovery rate per node</span>
<span class="sd">    initial_infecteds: node or iterable of nodes</span>
<span class="sd">       if a single node, then this node is initially infected</span>
<span class="sd">       if an iterable, then whole set is initially infected</span>
<span class="sd">       if None, then a randomly chosen node is initially infected.</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    return_node_data: boolean</span>
<span class="sd">        Tells whether the infection and recovery times of each </span>
<span class="sd">        individual node should be returned.  </span>
<span class="sd">        It is returned in the form of two dicts, infection_time and </span>
<span class="sd">        recovery_time.</span>
<span class="sd">        infection_time[node] is the time of infection and </span>
<span class="sd">        recovery_time[node] is the recovery time.</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([1,5,10]*100000)</span>
<span class="sd">    initial_size = 10000</span>
<span class="sd">    gamma = 1.</span>
<span class="sd">    tau = 0.2</span>
<span class="sd">    t, S, I = EoN.Gillespie_SIS(G, tau, gamma, tmax = 20,</span>
<span class="sd">                                initial_infecteds = range(initial_size))</span>
<span class="sd">                                </span>
<span class="sd">    plt.plot(t, I)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">infection_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span> <span class="c1">#defaults to an empty list </span>
    <span class="n">recovery_times</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[])</span>  <span class="c1">#for each node</span>

    <span class="n">tau</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1">#just to avoid integer division problems.</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">initial_infecteds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">initial_infecteds</span><span class="p">):</span>
        <span class="n">initial_infecteds</span><span class="o">=</span><span class="p">[</span><span class="n">initial_infecteds</span><span class="p">]</span>

    <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span> <span class="o">=</span> \
                <span class="n">_Gillespie_Initialize_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">initial_infecteds</span><span class="p">,</span>  <span class="n">infection_times</span><span class="p">,</span>  
                                        <span class="n">return_node_data</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#note that at this point times, S, and I must all be lists </span>
    <span class="c1">#since we will be appending to them</span>

    <span class="n">total_trans_rate</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> 
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">total_rec_rate</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">infected</span><span class="p">)</span>
    <span class="n">total_rate</span> <span class="o">=</span> <span class="n">total_rec_rate</span> <span class="o">+</span> <span class="n">total_trans_rate</span>
    <span class="n">next_time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">total_rate</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">next_time</span><span class="o">&lt;</span><span class="n">tmax</span> <span class="ow">and</span> <span class="n">infected</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="n">total_rate</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">&lt;</span><span class="n">total_rec_rate</span><span class="p">:</span>
            <span class="c1">#a recovery occurs</span>
            <span class="n">_Gillespie_Recover_SIS_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">next_time</span><span class="p">,</span> 
                                    <span class="n">status</span><span class="p">,</span> <span class="n">infected_neighbor_count</span><span class="p">,</span> 
                                    <span class="n">risk_group</span><span class="p">,</span> <span class="n">recovery_times</span><span class="p">,</span> 
                                    <span class="n">return_node_data</span><span class="p">)</span>
            <span class="n">total_rec_rate</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#an infection occurs</span>
            <span class="n">_Gillespie_Infect_</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="p">[],</span> <span class="n">times</span><span class="p">,</span> <span class="n">infected</span><span class="p">,</span> <span class="n">next_time</span><span class="p">,</span> 
                                <span class="n">infected_neighbor_count</span><span class="p">,</span> <span class="n">risk_group</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> 
                                <span class="n">infection_times</span><span class="p">,</span> <span class="n">return_node_data</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#updates variables as needed and calculates new max_trans_rate</span>
        <span class="n">total_trans_rate</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">risk_group</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> 
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">risk_group</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="n">total_rec_rate</span> <span class="o">+</span> <span class="n">total_trans_rate</span>
        <span class="k">if</span> <span class="n">total_rate</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">next_time</span> <span class="o">+=</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">total_rate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1">#occurs if everyone recovered</span>
            <span class="n">next_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">)</span>
        <span class="c1">#        print next_time, I[-1]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_node_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                <span class="n">infection_times</span><span class="p">,</span> <span class="n">recovery_times</span></div>




<span class="c1">##################</span>
<span class="c1">#                #</span>
<span class="c1">#    ODE CODE    #</span>
<span class="c1">#                #</span>
<span class="c1">##################</span>
<span class="sd">&#39;&#39;&#39;All system numbers below are based on the current draft of the book.  </span>
<span class="sd">They are subject to change&#39;&#39;&#39;</span>

<span class="sd">&#39;&#39;&#39;Code will be ordered so that when SIS and SIR versions both exist, </span>
<span class="sd">the corresponding functions are adjacent to each other.&#39;&#39;&#39;</span>



<span class="c1">########      INDIVIDUAL BASED code -</span>
<span class="c1">########  given node and who its neighbors are, we track probability of</span>
<span class="c1">########  having given status based on probabilities of neighbors.  Assumes</span>
<span class="c1">########  independence.</span>
    
<span class="k">def</span> <span class="nf">_dSIS_individual_based_</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span><span class="n">Y</span><span class="p">)):</span>
        <span class="c1">#This would probably be faster if it were done as a</span>
        <span class="c1">#matrix multiplication, but then I&#39;d need to have</span>
        <span class="c1">#the matrix Gij explicitly included.  Perhaps that</span>
        <span class="c1">#would be better.  Networkx has something to create</span>
        <span class="c1">#numpy sparse matrices.  Perhaps that works?</span>
        <span class="c1">#No plan to do premature optimization.  Let&#39;s get it</span>
        <span class="c1">#working and then see if it&#39;s slow.</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">nbr</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Y</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">nbr</span><span class="p">]</span> 
                            <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">-</span> <span class="n">rec_rate</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">*</span><span class="n">Yi</span>
    <span class="k">return</span> <span class="n">dY</span>

<span class="k">def</span> <span class="nf">_dSIR_individual_based_</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> 
                            <span class="n">rec_rate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;    &lt;\dot{X}_i&gt; = - tau sum_j g_{ij} &lt;Xi&gt;&lt;Yj&gt;</span>
<span class="sd">    &lt;\dot{Y}_i&gt; = tau sum_j g_{ij} &lt;Xi&gt;&lt;Yj&gt; - gamma_i &lt;Y_i&gt;</span>
<span class="sd">    Z_i = 1-X_i-Y_i</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)):</span>
        <span class="c1">#This would probably be faster if it were done as a</span>
        <span class="c1">#matrix multiplication, but then I&#39;d need to have</span>
        <span class="c1">#the matrix Gij explicitly included.  Perhaps that</span>
        <span class="c1">#would be better.  Networkx has something to create</span>
        <span class="c1">#numpy sparse matrices.  Perhaps that works?</span>
        <span class="c1">#No plan to do premature optimization.  Let&#39;s get it</span>
        <span class="c1">#working and then see if it&#39;s slow.</span>
        
        <span class="n">dX</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Xi</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">nbr</span><span class="p">)</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">nbr</span><span class="p">]]</span> 
                                <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>  <span class="o">-</span><span class="n">dX</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">rec_rate</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">*</span><span class="n">Yi</span>
    <span class="n">dV</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dX</span><span class="p">,</span><span class="n">dY</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dV</span><span class="p">)</span>

<div class="viewcode-block" id="SIS_individual_based"><a class="viewcode-back" href="../methods.html#EoN.SIS_individual_based">[docs]</a><span class="k">def</span> <span class="nf">SIS_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                            <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                            <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_SIS_individual_based</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (3.7) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    See also:</span>
<span class="sd">    Hadjichrysanthou and Sharkey</span>
<span class="sd">    Epidemic control analysis: Desigining targeted intervention </span>
<span class="sd">        strategies against epidemics propagated on contact networks,</span>
<span class="sd">    Journal of Theoretical Biology</span>

<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    </span>
<span class="sd">    Y0 : scipy array</span>
<span class="sd">         the array of initial infection probabilities</span>

<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>

<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>

<span class="sd">    gamma : number      (default None)</span>
<span class="sd">            global recovery rate </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>

<span class="sd">    tmin : number       (default 0)</span>
<span class="sd">           minimum report time</span>

<span class="sd">    tmax : number       (default 100)</span>
<span class="sd">           maximum report time</span>

<span class="sd">    tcount : integer       (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    edge_label : string       (default None)</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>

<span class="sd">    recovery_label : string       (default None)</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">                G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error.</span>

<span class="sd">    return_full_data       (default False)</span>
<span class="sd">            If True, returns times, Ss, Is</span>
<span class="sd">            if False, returns times, S, I</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ---------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        returns times, Ss, Is</span>
<span class="sd">           where times is a scipy array of times, Ss is a 2D scipy array</span>
<span class="sd">           Ss[i,j] gives probability nodelist[i] is susceptible at time</span>
<span class="sd">           times[j].</span>
<span class="sd">           Similarly for Is.</span>
<span class="sd">    if return_full data is False:</span>
<span class="sd">        returns times, S, I</span>
<span class="sd">             all are scipy arrays.  gives times, and expected number </span>
<span class="sd">             susceptible and expected number infected.</span>
<span class="sd">             </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN as EoN</span>
<span class="sd">    import scipy</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([3,10]*1000)</span>
<span class="sd">    nodelist = G.nodes()</span>
<span class="sd">    N = G.order()</span>
<span class="sd">    rho = 1./N</span>
<span class="sd">    Y = rho*scipy.ones(N)</span>
<span class="sd">    t, S, I = EoN.SIS_individual_based(G, nodelist, Y, 0.3, gamma=1, </span>
<span class="sd">                tmax = 20)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need gamma or recovery_label defined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;only one of gamma and recovery_label can be defined.&quot;</span><span class="p">)</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">edge_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_individual_based_</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span>  
                                    <span class="n">args</span> <span class="o">=</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">))</span>
    <span class="n">Is</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Ss</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Is</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Is</span> 
    
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">Ss</span><span class="p">,</span> <span class="n">Is</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ss</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Is</span><span class="p">)</span></div>


<div class="viewcode-block" id="SIR_individual_based"><a class="viewcode-back" href="../methods.html#EoN.SIR_individual_based">[docs]</a><span class="k">def</span> <span class="nf">SIR_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                            <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                            <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes System (3.30) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    See also:</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    G : Networkx graph</span>

<span class="sd">    X0 : scipy array</span>
<span class="sd">         the array of initial susceptibility probabilities</span>
<span class="sd">    Y0 : scipy array</span>
<span class="sd">         the array of initial infection probabilities</span>

<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in X0 and Y0</span>

<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>

<span class="sd">    gamma : number      (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>

<span class="sd">    tmin : number       (default 0)</span>
<span class="sd">           minimum report time</span>

<span class="sd">    tmax : number       (default 100)</span>
<span class="sd">           maximum report time</span>

<span class="sd">    tcount : integer       (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    edge_label : string       (default None)</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>

<span class="sd">    recovery_label : string       (default None)</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error</span>

<span class="sd">    return_full_data       (default False)</span>
<span class="sd">            If True, returns times, S, I, R, Ss, Is, Rs</span>
<span class="sd">            if False, returns times, S, I, R</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ---------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        returns times, Ss, Is, Rs</span>
<span class="sd">           where times is a scipy array of times, Ss is a 2D scipy array</span>
<span class="sd">           Ss[i,j] gives probability nodelist[i] is susceptible at time</span>
<span class="sd">           times[j].</span>
<span class="sd">           Similarly for Is ans Rs</span>
<span class="sd">    if return_full data is False:</span>
<span class="sd">        returns times, S, I, R</span>
<span class="sd">             all are scipy arrays.  gives times, and expected number </span>
<span class="sd">             susceptible, expected number infected, and expected number</span>
<span class="sd">             recovered</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import scipy</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([3,10]*10000)</span>
<span class="sd">    tau = 0.3</span>
<span class="sd">    gamma = 1</span>
<span class="sd">    N = G.order()</span>
<span class="sd">    rho = 1./N</span>

<span class="sd">    nodelist = G.nodes()</span>
<span class="sd">    X = (1-rho)*scipy.ones(N)</span>
<span class="sd">    Y = rho*scipy.ones(N)</span>
<span class="sd">    </span>
<span class="sd">    t, S, I, R = EoN.SIR_individual_based(G, nodelist, X, Y, tau, gamma=gamma, tmax = 20)</span>
<span class="sd">    plt.plot(t,I)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need gamma or recovery_label defined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;only one of gamma and recovery_label can be defined.&quot;</span><span class="p">)</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">edge_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>

    <span class="n">index_of_node</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">):</span>
        <span class="n">index_of_node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X0</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">V0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">,</span><span class="n">Y0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_individual_based_</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> 
                                    <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">))</span>
    <span class="n">Ss</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Ss</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Is</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Is</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Rs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Ss</span> <span class="o">-</span> <span class="n">Is</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Rs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Ss</span><span class="p">,</span> <span class="n">Is</span><span class="p">,</span> <span class="n">Rs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<div class="viewcode-block" id="SIS_individual_based_pure_IC"><a class="viewcode-back" href="../methods.html#EoN.SIS_individual_based_pure_IC">[docs]</a><span class="k">def</span> <span class="nf">SIS_individual_based_pure_IC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">index_nodes</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (3.7) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    The difference between this and SIS_individual_based is that this </span>
<span class="sd">    one assumes a &quot;pure initial condition&quot;, that is, we know exactly </span>
<span class="sd">    what the statuses of the nodes are at the initial time.  </span>
<span class="sd">    </span>
<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    index_nodes : list or set</span>
<span class="sd">      the set of nodes initially infected</span>
<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>
<span class="sd">    gamma : number      (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>

<span class="sd">    tmin : number       (default 0)</span>
<span class="sd">           minimum report time</span>

<span class="sd">    tmax : number       (default 100)</span>
<span class="sd">           maximum report time</span>

<span class="sd">    tcount : integer       (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    edge_label : string       (default None)</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>

<span class="sd">    recovery_label : string       (default None)</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error</span>

<span class="sd">    return_full_data : boolean      (default False)</span>


<span class="sd">    RETURNS:</span>
<span class="sd">    --------</span>
<span class="sd">            if return_full_data is True,</span>
<span class="sd">                returns times, Ss, Is</span>
<span class="sd">            if return_full_data is False,</span>
<span class="sd">                returns times, S, I</span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import scipy</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    </span>
<span class="sd">    G = nx.configuration_model([3,10]*1000)</span>
<span class="sd">    nodelist = G.nodes()</span>
<span class="sd">    index_nodes = range(100)</span>
<span class="sd">    t, S, I = EoN.SIS_individual_based(G, index_nodes, nodelist, 0.3,  </span>
<span class="sd">                gamma=1, tmax = 20)</span>
<span class="sd">    plt.plot(t,I)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#make Y0[u] be 1 if infected 0 if not</span>
    <span class="n">Y0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">index_nodes</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">SIS_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span>
                                <span class="n">edge_label</span><span class="p">,</span> <span class="n">recovery_label</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span></div>
        



<div class="viewcode-block" id="SIR_individual_based_pure_IC"><a class="viewcode-back" href="../methods.html#EoN.SIR_individual_based_pure_IC">[docs]</a><span class="k">def</span> <span class="nf">SIR_individual_based_pure_IC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">index_nodes</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">initial_susceptible</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (3.30) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    The difference between this and SIR_individual_based is that this </span>
<span class="sd">    one assumes a &quot;pure initial condition&quot;, that is, we know exactly </span>
<span class="sd">    what the statuses of the nodes are at the initial time.</span>
<span class="sd">    </span>
<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    index_nodes : list or set</span>
<span class="sd">      the set of nodes initially infected</span>
<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>
<span class="sd">    gamma : number      (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>
<span class="sd">    initial_susceptible : list or set  (default None)</span>
<span class="sd">      initially susceptible nodes</span>
<span class="sd">      if equal to None, then all non-index nodes are initially </span>
<span class="sd">      susceptible.</span>
<span class="sd">    tmin : number       (default 0)</span>
<span class="sd">           minimum report time</span>

<span class="sd">    tmax : number       (default 100)</span>
<span class="sd">           maximum report time</span>

<span class="sd">    tcount : integer       (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    edge_label : string       (default None)</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>

<span class="sd">    recovery_label : string       (default None)</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error</span>

<span class="sd">    return_full_data : boolean      (default False)</span>

<span class="sd">    RETURNS:</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True,</span>
<span class="sd">        returns times, S, I, R, Ss, Is, Rs</span>
<span class="sd">    if return_full_data is False,</span>
<span class="sd">        returns times, S, I, R</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="c1">#make Y0[u] be 1 if infected 0 if not</span>
    <span class="n">Y0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">index_nodes</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">initially_susceptible</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span> <span class="o">-</span> <span class="n">Y0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">initially_susceptible</span> <span class="k">else</span> <span class="mi">0</span> 
                            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">SIR_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> 
                                    <span class="n">tcount</span><span class="p">,</span> <span class="n">edge_label</span><span class="p">,</span> <span class="n">recovery_label</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="p">)</span></div>

<span class="c1">########   PAIR BASED</span>

<span class="k">def</span> <span class="nf">_dSIS_pair_based_</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} &lt;XiYj&gt;  -  gamma_i &lt;Yi&gt;</span>
<span class="sd">    &lt;\dot{XY}_ij&gt; = tau sum_{k \neq i} g_{jk} &lt;XiXj&gt;&lt;XjYk&gt;/&lt;Xj&gt;</span>
<span class="sd">                   - tau sum_{k neq j} g_{ik} &lt;YkXi&gt;&lt;XiYj&gt;/&lt;Xi&gt;</span>
<span class="sd">                   - tau g_{ij}&lt;XiYj&gt; - gamma_j &lt;XiYj&gt;  </span>
<span class="sd">                   + ***gamma_i &lt;YiYj&gt;***</span>
<span class="sd">    &lt;\dot{XX}_ij&gt; = - tau sum_{k\neq i} g_{jk} &lt;XiXj&gt;&lt;XjYk&gt;/&lt;Xj&gt;</span>
<span class="sd">                    - tau sum_{k neq j} g_{ik} &lt;YkXi&gt;&lt;XiXj&gt;/&lt;Xi&gt;</span>
<span class="sd">                    + **** \gamma_i &lt;YiXj&gt; + gamma_j &lt;XiYj&gt;****</span>

<span class="sd">    &lt;Xi&gt;=1-&lt;Yi&gt;</span>
<span class="sd">    &lt;YiYj&gt; = 1 - &lt;XiXj&gt; - &lt;XiYj&gt; - &lt;XjYi&gt;</span>
<span class="sd">    &lt;YiXj&gt; = &lt;XjYi&gt;</span>

<span class="sd">    (Starred terms differ from SIR)</span>
<span class="sd">    </span>
<span class="sd">    The equations as coded involve all pairs rather than just the</span>
<span class="sd">    pairs that are in edges.  Those that are not part of an edge are</span>
<span class="sd">    set to zero and their derivatives are zero.  So the code could run</span>
<span class="sd">    faster if we took these out of the calculation.  That is a</span>
<span class="sd">    potential future improvement.</span>

<span class="sd">    I think for most cases this is a small contribution.</span>
<span class="sd">    All derivatives are initialized to 0, and then the loop only makes </span>
<span class="sd">    changes for those terms where an edge exists.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1">#infecteds</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">Y</span>    <span class="c1">#susceptibles</span>
    <span class="n">Xinv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span> 
            <span class="c1">#there are places where we divide by X[i] which may = 0.</span>
            <span class="c1">#In those cases the numerator is (very) 0, so it&#39;s easier</span>
            <span class="c1">#to set this up as mult by inverse with a dummy value when</span>
            <span class="c1">#it is 1/0.</span>
    <span class="n">Yinv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>
    
    <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:]</span>

    <span class="n">XY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="n">XX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    

    <span class="n">YX</span> <span class="o">=</span> <span class="n">XY</span><span class="o">.</span><span class="n">T</span>   <span class="c1">#not really needed, </span>
                <span class="c1">#but helps keep consistent with equations as written.</span>

    <span class="n">YY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">XY</span><span class="o">-</span><span class="n">XX</span><span class="o">-</span><span class="n">YX</span>

    <span class="n">dY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dXY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">dXX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    
    <span class="c1">#I could make the below more efficient, but I think this sequence of for </span>
    <span class="c1"># loops is easier to read, or at least understand.</span>
    <span class="c1">#I expect this isn&#39;t the bottleneck.  </span>
    <span class="c1">#Will avoid (premature) optimization for now.</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            
            <span class="n">dXY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span>  <span class="o">-</span> <span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> \
                            <span class="o">+</span> <span class="n">rec_rate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">YY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">dXX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span>  <span class="n">rec_rate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">YX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">rec_rate</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="c1">#all the pure pairs are dealt with.  Now the triples</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span> <span class="c1">#skip these</span>
                    <span class="k">continue</span>
                <span class="c1">#so w != v. </span>
                <span class="n">k</span><span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>

                <span class="n">dXY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  \
                            <span class="o">-</span>  <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">YX</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dXX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> \
                            <span class="o">-</span>  <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">YX</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">dXY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dXX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">dV</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dY</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">dXY</span><span class="p">,</span> <span class="n">dXX</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dV</span>

<span class="k">def</span> <span class="nf">_dSIR_pair_based_</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &lt;\dot{X}_i&gt; = -tau sum_j g_{ij} &lt;XiYj&gt;</span>
<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} &lt;XiYj&gt;  -  gamma_i &lt;Y_i&gt;</span>
<span class="sd">    &lt;\dot{XY}_ij&gt; = tau sum_{k \neq i} g_{jk} &lt;XiXj&gt;&lt;XjYk&gt;/&lt;Xj&gt;</span>
<span class="sd">                   - tau sum_{k neq j} g_{ik} &lt;YkXi&gt;&lt;XiYj&gt;/&lt;Xi&gt;</span>
<span class="sd">                   - tau g_{ij}&lt;XiYj&gt; - gamma_j &lt;XiYj&gt; </span>
<span class="sd">    &lt;\dot{XX}_ij&gt; = -tau sum_{k\neq j} gik &lt;YkXi&gt;&lt;XiXj&gt;/&lt;Xi&gt;</span>
<span class="sd">                    -tau sum_{k neq i} gjk &lt;XiXj&gt;&lt;XjYk&gt;/&lt;Xj&gt;</span>
<span class="sd">    &lt;&gt;</span>
<span class="sd">    The equations as coded involve all pairs rather than just the</span>
<span class="sd">    pairs that are in edges.  Those that are not part of an edge are</span>
<span class="sd">    set to zero and their derivatives are zero.  So the code could run</span>
<span class="sd">    faster if we took these out of the calculation. I think for most</span>
<span class="sd">    cases this is a small contribution.  Before I forced the initial</span>
<span class="sd">    conditions for these nonedges to be 0, they caused quite a bit of</span>
<span class="sd">    numerical headaches.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="c1">#susceptibles</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="c1">#infecteds</span>
    <span class="n">Xinv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span> 
            <span class="c1">#there are places where we divide by X[i] which may = 0.</span>
            <span class="c1">#In those cases the numerator is (very) 0, so it&#39;s easier</span>
            <span class="c1">#to set this up as mult by inverse with a dummy value when</span>
            <span class="c1">#it is 1/0.</span>
    <span class="n">Yinv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span> <span class="k">if</span> <span class="n">v</span><span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">])</span>
    
    <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:]</span>

    <span class="c1">#print X.shape, Y.shape, XY.shape, XX.shape, N</span>
    <span class="n">XY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="n">XX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    

    <span class="n">YX</span> <span class="o">=</span> <span class="n">XY</span><span class="o">.</span><span class="n">T</span>   <span class="c1">#not really needed, </span>
                <span class="c1">#but helps keep consistent with equations as written.</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dXY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">dXX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    
    <span class="c1">#I could make the below more efficient, </span>
    <span class="c1">#but I think this sequence of for loops is easier to read, </span>
    <span class="c1">#or at least understand.</span>
    <span class="c1">#I expect it to run quickly regardless.  Will avoid (premature) </span>
    <span class="c1">#optimization for now.</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">dX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            
            <span class="n">dXY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span>  <span class="o">-</span> <span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> 

            <span class="c1">#all the pure pairs are dealt with.  Now the triples</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span> <span class="c1">#skip these</span>
                    <span class="k">continue</span>
                <span class="c1">#so w != u.  </span>
                <span class="n">k</span><span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                <span class="c1">#i corresponds to u, j to v and k to w.</span>
                <span class="n">dXY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  
                <span class="n">dXX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">continue</span> <span class="c1">#skip these</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                <span class="n">dXY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span>  <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">YX</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">XY</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dXX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span>  <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">YX</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Xinv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">dXY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dXX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">dV</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dX</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dY</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">dXY</span><span class="p">,</span> <span class="n">dXX</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dV</span>


<div class="viewcode-block" id="SIS_pair_based"><a class="viewcode-back" href="../methods.html#EoN.SIS_pair_based">[docs]</a><span class="k">def</span> <span class="nf">SIS_pair_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">XY0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">XX0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Encodes System (3.26) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    This system solves equations for an SIS disease model spreading on a </span>
<span class="sd">    given graph.  </span>
<span class="sd">    </span>
<span class="sd">    It captures the dependence with pairs, but not triples.</span>

<span class="sd">    It does not include corrections for triangles (or any other cycles).  </span>
<span class="sd">    </span>
<span class="sd">    The corrections for triangles are provided in the text, but not </span>
<span class="sd">    implemented here.</span>

<span class="sd">    There are some inefficiencies in the implementation:</span>
<span class="sd">        we track all pairs, rather than just those pairs in edges, but </span>
<span class="sd">        this is unlikely to significantly affect the calculation time.  </span>
<span class="sd">        </span>
<span class="sd">        This makes it much easier to vectorize things.</span>
<span class="sd">        </span>
<span class="sd">        We track pairs in both directions: e.g., XX[1,2] and XX[2,1].</span>


<span class="sd">    INPUT:</span>
<span class="sd">    ------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>
<span class="sd">    Y0 : scipy array</span>
<span class="sd">         the array of initial infection probabilities for each node in </span>
<span class="sd">         order as in nodelist</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>
<span class="sd">    gamma : number (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>
<span class="sd">    XY0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XY0[i,j] is probability node i is susceptible and j is </span>
<span class="sd">            infected.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">            randomly according to Y0.</span>
<span class="sd">    XX0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XX0[i,j] is probability nodes i and j are susceptible.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">            randomly according to Y0.</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    edge_label : string</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>
<span class="sd">    recovery_label : string</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error.</span>
<span class="sd">    return_full_data : boolean      (default False)</span>
<span class="sd">            if True:</span>
<span class="sd">                returns times, S, I, R, Xs, Ys, Zs, XY, XX</span>
<span class="sd">            if False:</span>
<span class="sd">                returns times, S, I, R</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        returns times, S, I, Xs, Ys, XY, XX</span>
<span class="sd">    if False:</span>
<span class="sd">        returns times, S, I</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.004)</span>
<span class="sd">    nodelist = G.nodes()</span>
<span class="sd">    Y0 = scipy.array([1 if node&lt;10 else 0 for node in nodelist]) #infect first 10</span>
<span class="sd">    t, S, I = EoN.SIS_pair_based(G, nodelist, Y0, 2, 0.5, tmax = 4, tcount = 101)</span>
<span class="sd">    plt.plot(t,I)</span>
<span class="sd">    </span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need gamma or recovery_label defined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;only one of gamma and recovery_label can be defined.&quot;</span><span class="p">)</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">edge_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>


    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y0</span><span class="p">)</span>
    <span class="n">X0</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">Y0</span>

    <span class="k">if</span> <span class="n">XY0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">XY0</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Y0</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">XY0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;incompatible lengths for XY0 and Y0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">XX0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">XX0</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">XX0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;incompatible lengths for XX0 and Y0&quot;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">XY0</span> <span class="o">=</span> <span class="n">XY0</span><span class="o">*</span><span class="n">A</span>  <span class="c1">#in principle the equations should still work for pairs not</span>
    <span class="n">XX0</span> <span class="o">=</span> <span class="n">XX0</span><span class="o">*</span><span class="n">A</span>  <span class="c1">#in an edge, but this led to the error with odeint.  </span>
                 <span class="c1">#Multiplying by A restricts attention just to present edges.</span>
    
    <span class="n">XY0</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">XX0</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">V0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Y0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">XX0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">index_of_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)}</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_pair_based_</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> 
                                    <span class="n">rec_rate</span><span class="p">))</span>
    <span class="n">Ys</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ys</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Xs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Ys</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">XY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="n">XX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">Ys</span><span class="p">,</span> <span class="n">XY</span><span class="p">,</span> <span class="n">XX</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>






<div class="viewcode-block" id="SIR_pair_based"><a class="viewcode-back" href="../methods.html#EoN.SIR_pair_based">[docs]</a><span class="k">def</span> <span class="nf">SIR_pair_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">XY0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">XX0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                    <span class="n">edge_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes System (3.39) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    This system solves equations for an SIR disease model spreading on a</span>
<span class="sd">    given graph.  It captures the dependence with pairs, but not </span>
<span class="sd">    triples.</span>
<span class="sd">    </span>
<span class="sd">    It will be exact for a tree.</span>

<span class="sd">    There are NO CORRECTIONS for the existence of TRIANGLES or any other</span>
<span class="sd">    CYCLES.</span>
<span class="sd">    </span>
<span class="sd">    Some corrections for triangles are provided in the text, but not </span>
<span class="sd">    implemented here.</span>
<span class="sd">    </span>
<span class="sd">    See also:</span>
<span class="sd">    Hadjichrysanthou and Sharkey</span>
<span class="sd">    Epidemic control analysis: Desigining targeted intervention </span>
<span class="sd">        strategies against epidemics propagated on contact networks,</span>
<span class="sd">    Journal of Theoretical Biology</span>
<span class="sd">    </span>

<span class="sd">    INPUT:</span>
<span class="sd">    ------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>
<span class="sd">    Y0 : scipy array</span>
<span class="sd">         the array of initial infection probabilities for each node in </span>
<span class="sd">         order as in nodelist</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>
<span class="sd">    gamma : number (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>
<span class="sd">    X0 : scipy array (default None)</span>
<span class="sd">            probability a random node is initially susceptible.</span>
<span class="sd">            the probability of initially recovered will be 1-X0-Y0.  By </span>
<span class="sd">            default we assume no initial recoveries, so X0=1-Y0 will be </span>
<span class="sd">            assumed in this case.</span>
<span class="sd">    XY0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XY0[i,j] is probability node i is susceptible and j is </span>
<span class="sd">                infected.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">                randomly according to Y0.</span>
<span class="sd">    XX0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XX0[i,j] is probability nodes i and j are susceptible.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">                randomly according to Y0.</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    edge_label : string</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_label] = g_{ij}</span>
<span class="sd">    recovery_label : string</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error.</span>
<span class="sd">    return_full_data : boolean      (default False)</span>
<span class="sd">            if True:</span>
<span class="sd">                returns times, S, I, R, Xs, Ys, Zs, XY, XX</span>
<span class="sd">            if False:</span>
<span class="sd">                returns times, S, I, R</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        returns times, S, I, R, Xs, Ys, Zs, XY, XX</span>
<span class="sd">    if False:</span>
<span class="sd">        returns times, S, I, R</span>

<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    G = nx.fast_gnp_random_graph(1000,0.004)</span>
<span class="sd">    nodelist = G.nodes()</span>
<span class="sd">    Y0 = scipy.array([1 if node&lt;10 else 0 for node in nodelist]) #infect first 10</span>
<span class="sd">    t, S, I, R = EoN.SIR_pair_based(G, nodelist, Y0, 2, 0.5, tmax = 4, tcount = 101)</span>
<span class="sd">    plt.plot(t,I)</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need gamma or recovery_label defined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;only one of gamma and recovery_label can be defined.&quot;</span><span class="p">)</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">edge_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">X0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">Y0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">XY0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">XY0</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">Y0</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">XY0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;incompatible lengths for XY0 and Y0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">XX0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">XX0</span> <span class="o">=</span> <span class="n">X0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">XX0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;incompatible lengths for XX0 and Y0&quot;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">XY0</span> <span class="o">=</span> <span class="n">XY0</span><span class="o">*</span><span class="n">A</span>  <span class="c1">#in principle the equations should still work for pairs not</span>
    <span class="n">XX0</span> <span class="o">=</span> <span class="n">XX0</span><span class="o">*</span><span class="n">A</span>  <span class="c1">#in an edge, but this led to the error with odeint.  </span>
                 <span class="c1">#Multiplying by A restricts attention just to present edges.</span>
    
    <span class="n">XY0</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">XX0</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">V0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">Y0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">XX0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#print V0.shape</span>
    <span class="n">index_of_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)}</span>
    <span class="c1">#    index_of_node = {}</span>
    <span class="c1">#    for i, node in enumerate(nodelist):</span>
    <span class="c1">#        index_of_node[node] = i</span>


    <span class="n">V</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_pair_based_</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> 
                                    <span class="n">rec_rate</span><span class="p">))</span>
    <span class="n">Xs</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Ys</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ys</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Zs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Xs</span><span class="o">-</span><span class="n">Ys</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Zs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:]</span>
        <span class="c1">#print len(XX)</span>
        <span class="n">XY</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="n">XX</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">Ys</span><span class="p">,</span> <span class="n">Zs</span><span class="p">,</span> <span class="n">XY</span><span class="p">,</span> <span class="n">XX</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<span class="k">def</span> <span class="nf">_dSIR_pair_based2_</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">,</span> 
                        <span class="n">index_of_edge</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">):</span>
    <span class="c1">#X, Y, XY, YX, XX</span>
    <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="n">E</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">edgelist</span><span class="p">)</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">Xinv</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        There are places where we divide by X[i] which may = 0.  </span>
<span class="sd">        </span>
<span class="sd">        In those cases the numerator is (very) 0, so it&#39;s easier</span>
<span class="sd">        to set this up as mult by inverse with a dummy value when it </span>
<span class="sd">        is 1/0.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">Yinv</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">Y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="c1">#Xinv = scipy.array([1/v if v!=0 else 0 for v in X]) </span>
    <span class="c1">#Yinv = scipy.array([1/v if v!=0 else 0 for v in Y])</span>
    
    <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">E</span><span class="p">]</span>
    <span class="n">YX</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">E</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">]</span>
    <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">:]</span>

    <span class="c1">#print X.shape, Y.shape, XY.shape, XX.shape, N</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">dXY</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">dYX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">dXX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">my_XY</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span> <span class="c1">#either XY[i,j] or YX[i,j], depending on which is defined.  </span>
                    <span class="c1">#Might be cleaner with Try, Except</span>
        <span class="k">if</span> <span class="n">index_of_edge</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_edge</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">XY</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_edge</span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">YX</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">my_YX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">my_XY</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">my_XX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index_of_edge</span><span class="o">.</span><span class="n">has_key</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_edge</span><span class="p">[(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_edge</span><span class="p">[(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">XX</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    
    <span class="c1">#I could make the below more efficient, but I think this sequence </span>
    <span class="c1">#of for loops is easier to read, or at least understand.</span>
    <span class="c1">#I expect it to run quickly regardless.  </span>
    <span class="c1">#Will avoid (premature) optimization for now.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">):</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
    <span class="k">for</span> <span class="n">edgeindex</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

        <span class="n">dX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> 
        <span class="n">dY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span>  

        <span class="n">dX</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">YX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span>
        <span class="n">dY</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">YX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span>

        <span class="n">dXY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span> <span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">XY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span>
        <span class="n">dYX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span> <span class="p">(</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">rec_rate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">YX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">==</span><span class="n">v</span><span class="p">:</span>  <span class="c1">#skip this case</span>
                <span class="k">continue</span>
            <span class="n">k</span><span class="o">=</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">dXY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">my_YX</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">my_XY</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">dYX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">my_XX</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">my_XY</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">dXX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">my_XX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> \
                                <span class="o">*</span> <span class="n">my_XY</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">==</span><span class="n">u</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1">#w transmits to v.</span>
            <span class="n">dXY</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">my_XX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">*</span><span class="n">my_XY</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">dYX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">my_XY</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">my_YX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">dXX</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">trans_rate</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">my_XX</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">my_XY</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">Xinv</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">dV</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dX</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="n">dXY</span><span class="p">,</span> <span class="n">dYX</span><span class="p">,</span> <span class="n">dXX</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dV</span>


<span class="k">def</span> <span class="nf">_SIR_pair_based_initialize_node_data</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">):</span>
    <span class="c1">#inputs must define either rho or Y0.  In first case nodelist is optional.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rho</span> <span class="ow">and</span> <span class="n">Y0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rho</span> <span class="ow">and</span> <span class="n">Y0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need rho or Y0 defined for initial condition, </span><span class="se">\</span>
<span class="s2">                        but not both&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;order in Y0 is ambiguous if nodelist is not given.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodelist</span><span class="p">:</span> <span class="c1">#then rho is defined but not Y0</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">rho</span><span class="p">:</span> <span class="c1">#Y0 not defined</span>
        <span class="n">Y0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">))</span>
        <span class="n">X0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">Y0</span> <span class="c1">#assume X0=0</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1">#Y0 is defined</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">X0</span><span class="p">:</span>
            <span class="n">X0</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">Y0</span>  <span class="c1">#assume Z0=0</span>
        <span class="c1">#otherwise X0 is given and Z0=1-X0-Y0</span>
    <span class="k">return</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span>

<span class="k">def</span> <span class="nf">_SIR_pair_based_initialize_edge_data</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">YX0</span><span class="p">,</span> 
                                            <span class="n">XX0</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">XY0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">YX0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">XX0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="n">XY0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">YX0</span> <span class="o">!=</span><span class="kc">None</span>  <span class="ow">or</span> <span class="n">XX0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>  
            <span class="c1">#at least one defined and one not defined</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;must define all of XY0, YX0, and XX0 or none of them&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edgelist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">XY0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;order in XY0, YX0, and XX0 is ambiguous if </span><span class="se">\</span>
<span class="s2">                            edgelist is not given.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">XY0</span><span class="p">:</span>
        <span class="c1">#test that XY0 &lt;= X0Y0, same for  YX0 and XX0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist</span><span class="p">):</span>
           <span class="n">i_u</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
           <span class="n">i_v</span> <span class="o">=</span> <span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
           <span class="k">if</span> <span class="n">XY0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span><span class="n">X0</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">*</span><span class="n">Y0</span><span class="p">[</span><span class="n">i_v</span><span class="p">]</span> <span class="ow">or</span> <span class="n">YX0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&gt;</span><span class="n">Y0</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="n">I_v</span><span class="p">]</span> \
                                <span class="ow">or</span> <span class="n">XX0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&gt;</span><span class="n">X0</span><span class="p">[</span><span class="n">i_u</span><span class="p">]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="n">i_v</span><span class="p">]:</span>
               <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;edge probabilities inconsistent with node </span><span class="se">\</span>
<span class="s2">                                probabilities&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">XY0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="o">*</span><span class="n">Y0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> 
                            <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edgelist</span><span class="p">])</span>
        <span class="n">YX0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Y0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> 
                            <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edgelist</span><span class="p">])</span>
        <span class="n">XX0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="o">*</span><span class="n">X0</span><span class="p">[</span><span class="n">index_of_node</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> 
                            <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edgelist</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">edgelist</span><span class="p">,</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">YX0</span><span class="p">,</span> <span class="n">XX0</span>

<span class="k">def</span> <span class="nf">_get_rate_functions</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">edge_rate_label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    INPUT:</span>
<span class="sd">    -----</span>
<span class="sd">    G : networkx Graph</span>
<span class="sd">        the graph disease spread on</span>
<span class="sd">    tau : number</span>
<span class="sd">        disease parameter giving edge transmission rate </span>
<span class="sd">        (subject to edge scaling)</span>
<span class="sd">    gamma : number (default None)</span>
<span class="sd">        disease parameter giving typical recovery rate, If given then </span>
<span class="sd">        recovery_label must be None</span>
<span class="sd">    recovery_label : key (default None)</span>
<span class="sd">        G.node[node][recovery_label] is recovery rate</span>
<span class="sd">    edge_rate_label : key (default None)</span>
<span class="sd">        G.edge[u][v][edge_rate_label] scales up or down the recovery </span>
<span class="sd">        rate.</span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">recovery_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;need exactly one of gamma and recovery_label defined.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">gamma</span><span class="p">:</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">gamma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rec_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">recovery_label</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">edge_rate_label</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">edge_rate_label</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans_rate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">tau</span>
    <span class="k">return</span> <span class="n">rec_rate</span><span class="p">,</span> <span class="n">trans_rate</span>
    
<div class="viewcode-block" id="SIR_pair_based2"><a class="viewcode-back" href="../methods.html#EoN.SIR_pair_based2">[docs]</a><span class="k">def</span> <span class="nf">SIR_pair_based2</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">Y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">XY0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">YX0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                    <span class="n">XX0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                    <span class="n">edge_rate_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recovery_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes System (3.39) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    This system solves equations for an SIR disease model spreading on a </span>
<span class="sd">    given graph.  It captures the dependence with pairs, but not </span>
<span class="sd">    triples.</span>

<span class="sd">    It will be exact for a tree.</span>

<span class="sd">    There are NO CORRECTIONS for the existence of TRIANGLES or any other </span>
<span class="sd">    CYCLES.</span>
<span class="sd">    </span>
<span class="sd">    Some corrections for triangles are provided in the text, but not </span>
<span class="sd">    implemented here.</span>

<span class="sd">    See also:</span>
<span class="sd">    Hadjichrysanthou and Sharkey</span>
<span class="sd">    Epidemic control analysis: Desigining targeted intervention </span>
<span class="sd">    strategies against epidemics propagated on contact networks,</span>
<span class="sd">    Journal of Theoretical Biology</span>

<span class="sd">    &lt;\dot{Y}_i&gt; = tau \sum_j g_{ij} &lt;XY&gt;&gt;  -  gamma_i &lt;Y_i&gt;</span>
<span class="sd">    &lt;\dot{XY}&gt; = tau sum_{k \neq i} g_{jk} &lt;XX&gt;&lt;XjYk&gt;/&lt;Xj&gt;</span>
<span class="sd">                   - tau sum_{k neq j} g_{ik} &lt;YkXi&gt;&lt;XY&gt;/&lt;Xi&gt;</span>
<span class="sd">                   - tau g_{ij}&lt;XY&gt; - gamma_j &lt;XIYj&gt; </span>
<span class="sd">    &lt;\dot{XX}&gt; = </span>
<span class="sd">    &lt;&gt;</span>
<span class="sd">    The equations as coded involve all pairs rather than just the pairs </span>
<span class="sd">    that are in edges.  </span>
<span class="sd">    </span>
<span class="sd">    Those that are not part of an edge are set to zero and their </span>
<span class="sd">    derivatives are zero.  </span>
<span class="sd">    </span>
<span class="sd">    So the code could run faster, but I think for most cases this is a </span>
<span class="sd">    small contribution.  </span>
<span class="sd">    </span>
<span class="sd">    Before I forced the initial conditions for these nonedges to be 0, </span>
<span class="sd">    they caused quite a bit of numerical headaches.</span>

<span class="sd">    -------</span>
<span class="sd">    G : Networkx graph</span>
<span class="sd">    nodelist : list</span>
<span class="sd">         list of nodes in G in the same order as in Y0</span>
<span class="sd">    Y0 : scipy array</span>
<span class="sd">         the array of initial infection probabilities for each node in </span>
<span class="sd">         order as in nodelist</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate of disease</span>
<span class="sd">    gamma : number (default None)</span>
<span class="sd">            global recovery rate  </span>
<span class="sd">            (incompatible with recovery_label!=None)</span>
<span class="sd">    XY0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XY0[i,j] is probability node i is susceptible and j is </span>
<span class="sd">            infected.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">                randomly according to Y0.</span>
<span class="sd">    XX0 : 2D scipy array (default None)</span>
<span class="sd">            (each dimension has length number of nodes of G)</span>
<span class="sd">            XX0[i,j] is probability nodes i and j are susceptible.</span>
<span class="sd">            if None, then assumes that infections are introduced </span>
<span class="sd">                randomly according to Y0.</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    edge_rate_label : string</span>
<span class="sd">            the label for a weight given to the edges.</span>
<span class="sd">            G.edge[i][j][edge_rate_label] = g_{ij}</span>
<span class="sd">    recovery_label : string</span>
<span class="sd">            a label for a weight given to the nodes for their recovery </span>
<span class="sd">            rates</span>
<span class="sd">            G.node[i][recovery_label] = gamma_i</span>
<span class="sd">            We cannot define both gamma and recovery_label.  </span>
<span class="sd">            This will raise an error.</span>
<span class="sd">    return_full_data : boolean      (default False)</span>
<span class="sd">            if True:</span>
<span class="sd">                returns times, S, I, R, Xs, Ys, Zs, XY, XX</span>
<span class="sd">            if False:</span>
<span class="sd">                returns times, S, I, R</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#note: we do not test whether the nodelist and edgelist are in </span>
    <span class="c1">#fact lists of nodes or edges</span>
    <span class="n">nodelist</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span> <span class="o">=</span> <span class="n">_SIR_pair_based_initialize_node_data</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> 
                                                                <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">)</span>

    <span class="n">index_of_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)}</span>

    <span class="n">edgelist</span><span class="p">,</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">YX0</span><span class="p">,</span> <span class="n">XX0</span> <span class="o">=</span> <span class="n">_SIR_pair_based_initialize_edge_data</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> 
                                                <span class="n">edgelist</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">YX0</span><span class="p">,</span> 
                                                <span class="n">XX0</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">)</span>

    <span class="n">index_of_edge</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgelist</span><span class="p">)}</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgelist</span><span class="p">)</span>
    <span class="c1">#now we define functions which give the transmission rate of edges </span>
    <span class="c1">#and recovery rate of nodes.  </span>
    <span class="n">rec_rate</span><span class="p">,</span> <span class="n">trans_rate</span> <span class="o">=</span> <span class="n">_get_rate_functions</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">recovery_label</span><span class="p">,</span> 
                                                <span class="n">edge_rate_label</span><span class="p">)</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>

    
    <span class="n">V0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="n">XY0</span><span class="p">,</span> <span class="n">YX0</span><span class="p">,</span> <span class="n">XX0</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_pair_based2_</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">index_of_node</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">,</span> 
                                    <span class="n">index_of_edge</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">,</span> <span class="n">rec_rate</span><span class="p">))</span>
                                    
    <span class="c1">#dX, dY, dXY, dYX, dXX</span>
    <span class="n">Xs</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Ys</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ys</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Zs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Xs</span><span class="o">-</span><span class="n">Ys</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Zs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">XY</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">E</span><span class="p">]</span>
        <span class="n">YX</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">E</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">]</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">:]</span>
        <span class="n">YY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">XY</span> <span class="o">-</span> <span class="n">YX</span><span class="o">-</span><span class="n">XX</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">Ys</span><span class="p">,</span> <span class="n">Zs</span><span class="p">,</span> <span class="n">XY</span><span class="p">,</span> <span class="n">YX</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">nodelist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>




<span class="c1">######    HOMOGENEOUS MEANFIELD</span>

<span class="k">def</span> <span class="nf">_dSIS_homogeneous_meanfield_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n_over_N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">dSdt</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">I</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">n_over_N</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dIdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">dSdt</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dSdt</span><span class="p">,</span><span class="n">dIdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span>

<span class="k">def</span> <span class="nf">_dSIR_homogeneous_meanfield_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n_over_N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">dSdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">n_over_N</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dIdt</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">n_over_N</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dSdt</span><span class="p">,</span> <span class="n">dIdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span>

           
<div class="viewcode-block" id="SIS_homogeneous_meanfield"><a class="viewcode-back" href="../methods.html#EoN.SIS_homogeneous_meanfield">[docs]</a><span class="k">def</span> <span class="nf">SIS_homogeneous_meanfield</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (4.8) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [\dot{S}] = \gamma [I] - tau n[S][I]/N</span>
<span class="sd">    [\dot{I}] = \tau n[S][I]/N - \gamma [I]</span>


<span class="sd">    INPUTS</span>
<span class="sd">    --------</span>
<span class="sd">    S0 : number</span>
<span class="sd">         initial number susceptible</span>
<span class="sd">    I0 : number</span>
<span class="sd">         initial number infected</span>
<span class="sd">    n : integer</span>
<span class="sd">        degree of all nodes.</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    times, S, I, all scipy arrays</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    S0 = 999</span>
<span class="sd">    I0 = 1</span>
<span class="sd">    n = 4 #degree</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I = EoN.SIS_homogeneous_meanfield(S0, I0, n, tau, gamma)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">N</span><span class="o">=</span><span class="n">S0</span><span class="o">+</span><span class="n">I0</span>
    <span class="n">X0</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S0</span><span class="p">,</span><span class="n">I0</span><span class="p">])</span>
    <span class="n">times</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_homogeneous_meanfield_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>

<div class="viewcode-block" id="SIR_homogeneous_meanfield"><a class="viewcode-back" href="../methods.html#EoN.SIR_homogeneous_meanfield">[docs]</a><span class="k">def</span> <span class="nf">SIR_homogeneous_meanfield</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (4.9) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [\dot{S}] = - tau n[S][I]/N</span>
<span class="sd">    [\dot{I}] = \tau n[S][I]/N - \gamma [I]</span>
<span class="sd">    [\dot{R}] = \gamma [I]</span>


<span class="sd">    INPUTS</span>
<span class="sd">    --------</span>
<span class="sd">    S0 : number</span>
<span class="sd">         initial number susceptible</span>
<span class="sd">    I0 : number</span>
<span class="sd">         initial number infected</span>
<span class="sd">    R0 : number</span>
<span class="sd">         initial number recovered</span>
<span class="sd">    n : integer</span>
<span class="sd">        degree of each node</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    </span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    times, S, I, R : all scipy arrays</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    S0 = 999</span>
<span class="sd">    I0 = 1</span>
<span class="sd">    n = 4 #degree</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I, R = EoN.SIR_homogeneous_meanfield(S0, I0, 0, n, tau, gamma)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">N</span><span class="o">=</span><span class="n">S0</span><span class="o">+</span><span class="n">I0</span><span class="o">+</span><span class="n">R0</span>
    <span class="n">X0</span><span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S0</span><span class="p">,</span><span class="n">I0</span><span class="p">])</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_homogeneous_meanfield_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">I</span>
    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<span class="c1">####   HOMOGENEOUS PAIRWISE</span>

<span class="k">def</span> <span class="nf">_dSIS_homogeneous_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    [\dot{S}] = gamma [I] - tau [SI]</span>
<span class="sd">    [\dot{I}] = \tau [SI] - \gamma [I] = -[\dot{S}]</span>
<span class="sd">    [\dot{SI}] = \gamma([II]-[SI])+ \tau ((n-1)/n) [SI]([SS]-[SI])/[S] </span>
<span class="sd">                 - \tau [SI]</span>
<span class="sd">    [\dot{SS}] = 2\gamma[SI] - 2\tau ((n-1)/n) [SI][SS]/[S]</span>
<span class="sd">    [\dot{II}] = -2\gamma[II] + 2\tau((n-1)/n) [SI]^2/[S] + 2\tau[SI]</span>

<span class="sd">    conserved quantities: [S]+[I]</span>
<span class="sd">                          [SS]+2[SI]+[II]</span>

<span class="sd">    n([S]+[I]) should equal [SS]+2[SI]+[II], so II will be calculated </span>
<span class="sd">    based on this.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span> <span class="o">=</span> <span class="n">X</span> 
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="n">SS</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">nm1_over_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">dSdt</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">I</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="c1">#dIdt = -dSdt</span>
    <span class="n">dSIdt</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">II</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">nm1_over_n</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">/</span><span class="n">S</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dSSdt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">nm1_over_n</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">SS</span><span class="o">/</span><span class="n">S</span>
    <span class="c1">#dIIdt = -2*gamma*II + 2*tau*nm1_over_n*SI**2/S + 2*tau*SI</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dSdt</span><span class="p">,</span><span class="n">dSIdt</span><span class="p">,</span><span class="n">dSSdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span> 


<span class="k">def</span> <span class="nf">_dSIR_homogeneous_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">S</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">SI</span><span class="p">,</span><span class="n">SS</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">nm1_over_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">dSdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dIdt</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dSIdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">nm1_over_n</span> <span class="o">*</span> <span class="n">SI</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">/</span><span class="n">S</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dSSdt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">nm1_over_n</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">SS</span><span class="o">/</span><span class="n">S</span>
    <span class="n">dX</span> <span class="o">=</span>  <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dSdt</span><span class="p">,</span><span class="n">dIdt</span><span class="p">,</span><span class="n">dSIdt</span><span class="p">,</span><span class="n">dSSdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span>

<div class="viewcode-block" id="SIS_homogeneous_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIS_homogeneous_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIS_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Encodes System (4.10) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    --------</span>
<span class="sd">    S0 : number</span>
<span class="sd">         initial number susceptible</span>
<span class="sd">    I0 : number</span>
<span class="sd">         initial number infected</span>
<span class="sd">    SI0 : number</span>
<span class="sd">          initial number of SI edges</span>
<span class="sd">    SS0 : number</span>
<span class="sd">          initial number of SS edges</span>
<span class="sd">    n : integer</span>
<span class="sd">          (common) degree of nodes.</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">    </span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        t, S, I, SI, SS, II</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        t, S, I</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    S0 = 990</span>
<span class="sd">    I0 = 10</span>
<span class="sd">    SI0 = 50</span>
<span class="sd">    SS0 = 4900</span>
<span class="sd">    n = 5</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I = EoN.SIS_homogeneous_pairwise(S0, I0, SI0, SS0, n, tau, gamma, </span>
<span class="sd">                                            tmax = 20)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">S0</span><span class="o">+</span><span class="n">I0</span>

    <span class="k">if</span> <span class="n">SS0</span> <span class="o">+</span> <span class="n">SI0</span><span class="o">*</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">n</span><span class="o">*</span><span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s1">&#39;Initial condition has more SS, SI, and IS edges than allowed&#39;</span><span class="p">)</span>

    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">])</span>
    
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_homogeneous_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span><span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span>
    
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="n">II</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="n">SS</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">SI</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">II</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>
    
    
<div class="viewcode-block" id="SIR_homogeneous_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIR_homogeneous_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIR_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (4.11) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [\dot{S}] = - tau [SI]</span>
<span class="sd">    [\dot{I}] = \tau [SI] - \gamma [I]</span>
<span class="sd">    [\dot{R}] = \gamma [I]    ;    [R] = N-[S]-[I]</span>
<span class="sd">    [\dot{SI}] = -\gamma [SI]+ \tau ((n-1)/n) [SI]([SS]-[SI])/[S] </span>
<span class="sd">                 - \tau [SI]</span>
<span class="sd">    [\dot{SS}] = - 2\tau ((n-1)/n) [SI][SS]/[S]</span>

<span class="sd">    conserved quantities: [S]+[I]+[R]  also </span>
<span class="sd">                          [SS]+[II]+[RR] + 2([SI] + [SR] + [IR])</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    S0 : Initial number suusceptible</span>
<span class="sd">    I0 : Initial number infected</span>
<span class="sd">    R0 : Initial number recovered</span>
<span class="sd">    SI0 : Initial number of SI edges</span>
<span class="sd">    SS0 : Initial number of SS edges</span>
<span class="sd">    n : Degree of nodes</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">                       if True, then returns times, S, I, R, SI, SS</span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        times, S, I, R, SI, SS</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        times, S, I, R </span>

<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    S0 = 990</span>
<span class="sd">    I0 = 10</span>
<span class="sd">    R0 = 1</span>
<span class="sd">    SI0 = 45</span>
<span class="sd">    SS0 = 4900</span>
<span class="sd">    n = 5</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I, R = EoN.SIR_homogeneous_pairwise(S0, I0, R0, SI0, SS0, n, tau, gamma, </span>
<span class="sd">                                                tmax = 20)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">S0</span><span class="o">+</span><span class="n">I0</span><span class="o">+</span><span class="n">R0</span>
    <span class="k">if</span> <span class="n">SS0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI0</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">*</span><span class="n">N</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s1">&#39;Initial condition has more SS, SI, and IS edges than allowed&#39;</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">])</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_homogeneous_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">I</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<div class="viewcode-block" id="SIS_homogeneous_pairwise_from_graph"><a class="viewcode-back" href="../methods.html#EoN.SIS_homogeneous_pairwise_from_graph">[docs]</a><span class="k">def</span> <span class="nf">SIS_homogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                        <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Calls SIS_homogeneous_pairwise with a graph, disease parameters, and</span>
<span class="sd">    a random fraction rho initially infected.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : networkx Graph</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    rho : number (default 1/N)</span>
<span class="sd">          initial fraction infected </span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       tells whether to just return times, S, I, or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">                       if True, then returns times, S, I, SI, SS</span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        t, S, I, SI, SS, II</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        t, S, I</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.fast_gnp_random_graph(10000,0.0005)</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 3</span>
<span class="sd">    rho = 0.02</span>
<span class="sd">    t, S, I = EoN.SIS_homogeneous_pairwise_from_graph(G, tau, gamma, rho, tmax = 20)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">N</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">S0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">N</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">rho</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SIS_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> 
                                        <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SIR_homogeneous_pairwise_from_graph"><a class="viewcode-back" href="../methods.html#EoN.SIR_homogeneous_pairwise_from_graph">[docs]</a><span class="k">def</span> <span class="nf">SIR_homogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                        <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Calls SIS_homogeneous_pairwise with a graph, disease parameters, and</span>
<span class="sd">    a random fraction rho initially infected.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : networkx Graph</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    rho : number (default 1/N)</span>
<span class="sd">          initial fraction infected </span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">                       if True, then returns times, S, I, R, SI, SS</span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        t, S, I, SI, SS, II</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        t, S, I</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.fast_gnp_random_graph(10000,0.0005)</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 3</span>
<span class="sd">    rho = 0.02</span>
<span class="sd">    t, S, I, R = EoN.SIR_homogeneous_pairwise_from_graph(G, tau, gamma, rho, </span>
<span class="sd">                                                            tmax = 20)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">N</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">S0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">N</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">rho</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span>
    <span class="n">R0</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">return</span> <span class="n">SIR_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span>
                                    <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span></div>




<span class="c1">#######     HETEROGENEOUS MEAN FIELD</span>

<span class="k">def</span> <span class="nf">_dSIS_heterogeneous_meanfield_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">kcount</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">kcount</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="n">kcount</span><span class="p">])</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">kcount</span><span class="p">:])</span>
    <span class="n">pi_I</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">/</span> <span class="n">ks</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">I</span><span class="o">+</span><span class="n">S</span><span class="p">)</span>

    <span class="n">Sdot</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">ks</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">pi_I</span>
    <span class="n">Idot</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">ks</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">pi_I</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sdot</span><span class="p">,</span><span class="n">Idot</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span>
    
<span class="k">def</span> <span class="nf">_dSIR_heterogeneous_meanfield_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">S0</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Rk</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rk</span><span class="p">))</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">S0</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">**</span><span class="n">ks</span><span class="p">)</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">Sk</span> <span class="o">-</span> <span class="n">Rk</span>
    <span class="n">pi_I</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ik</span><span class="p">)</span><span class="o">/</span><span class="n">ks</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span>
    <span class="n">dRkdt</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">Ik</span>
    <span class="n">dThetadt</span> <span class="o">=</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span><span class="n">pi_I</span> <span class="o">*</span> <span class="n">theta</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">dThetadt</span><span class="p">],</span><span class="n">dRkdt</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span>




<div class="viewcode-block" id="SIS_heterogeneous_meanfield"><a class="viewcode-back" href="../methods.html#EoN.SIS_heterogeneous_meanfield">[docs]</a><span class="k">def</span> <span class="nf">SIS_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (5.10) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    Sk0 is an array (or a list). </span>
<span class="sd">    </span>
<span class="sd">    It is not a dict.  </span>
<span class="sd">    </span>
<span class="sd">    Sk0[k] is the *number* of nodes that are susceptible and have degree </span>
<span class="sd">    k (even if some degrees missing).  </span>
<span class="sd">    </span>
<span class="sd">    A dict like this can be converted into an array by</span>
<span class="sd">    Sk0 = scipy.array([Sk0dict.get(k,0) </span>
<span class="sd">                       for k in xrange(max(Sk0dict.keys())+1)])</span>

<span class="sd">    Ik0 is similar to Sk0.</span>


<span class="sd">    [\dot{S}_k] = \gamma [I_k] - \tau k [S_k] \pi_I</span>
<span class="sd">    [\dot{I}_k] = -(above)</span>
<span class="sd">    \pi_I = \sum_k k [I_k] / \sum_k  k [N_k]</span>



<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Sk0 : scipy array</span>
<span class="sd">          number susceptible for each k</span>
<span class="sd">    Ik0 : scipy array</span>
<span class="sd">          number infected for each k</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       tells whether to just return times, S, I or all </span>
<span class="sd">                       calculated data.</span>
<span class="sd">                       if True, returns t, S, I, Sk, Ik</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        times, S, I, Sk  (Sk is scipy 2D arrays)</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        times, S, I      (all scipy arrays)</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    Sk0 = [995, 995, 995, 995, 995]</span>
<span class="sd">    Ik0 = [5, 5, 5, 5, 5]</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I = EoN.SIS_heterogeneous_meanfield(Sk0, Ik0, tau, gamma, tmax = 10)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ik0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s1">&#39;length of Sk0 not equal to length of Ik0&#39;</span><span class="p">)</span>
    <span class="n">Sk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span>

    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span>
    
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sk0</span><span class="p">,</span><span class="n">Ik0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">+</span><span class="n">Ik0</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_heterogeneous_meanfield_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="n">gamma</span><span class="p">))</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">kcount</span><span class="p">])</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">kcount</span><span class="p">:])</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ik</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">Ik</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>
	
    
<div class="viewcode-block" id="SIR_heterogeneous_meanfield"><a class="viewcode-back" href="../methods.html#EoN.SIR_heterogeneous_meanfield">[docs]</a><span class="k">def</span> <span class="nf">SIR_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                    <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes System (5.11) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>


<span class="sd">    Ik0 and Rk0 are similar to Sk0.</span>

<span class="sd">    [S_k] = [S_k](0) theta^k</span>
<span class="sd">    [I_k] = [N_k] - [S_k] - [R_k]</span>
<span class="sd">    [\dot{R}_k] = \gamma [I_k]</span>
<span class="sd">    pi_I = \sum_k k[I_k]</span>


<span class="sd">    INPUTS</span>
<span class="sd">    ------------</span>
<span class="sd">    Sk0 : array</span>
<span class="sd">          Sk0[k] is the number of</span>
<span class="sd">          nodes that are susceptible and have degree k (even if some degrees </span>
<span class="sd">          missing).</span>
<span class="sd">    Ik0 : array</span>
<span class="sd">    Rk0 : array</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        times, S, I, R, Sk, Ik, Rk (the Xk are scipy 2D arrays)</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        times, S, I, R          (all scipy arrays)</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    Sk0 = [995, 995, 995, 995, 995]</span>
<span class="sd">    Ik0 = [5, 5, 5, 5, 5]</span>
<span class="sd">    Rk0 = [0,0,0,0,0]</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I, R = EoN.SIR_heterogeneous_meanfield(Sk0, Ik0, Rk0, tau, gamma, </span>
<span class="sd">                                                    tmax = 10)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Rk0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s1">&#39;length of Sk0, Ik0, and Rk0 must be the same&#39;</span><span class="p">)</span>

    <span class="n">theta0</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">Sk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span>
    <span class="n">Rk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Rk0</span><span class="p">)</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">+</span><span class="n">Ik0</span> <span class="o">+</span><span class="n">Rk0</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">theta0</span><span class="p">],</span><span class="n">Rk0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_heterogeneous_meanfield_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    
    <span class="n">theta</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Rk</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Rk</span><span class="p">))</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">**</span><span class="n">ks</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
    <span class="n">Sk</span><span class="o">=</span><span class="n">Sk0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">L</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">Sk</span><span class="o">-</span><span class="n">Rk</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sk</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ik</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Rk</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">Ik</span><span class="p">,</span> <span class="n">Rk</span></div>
    
<div class="viewcode-block" id="SIS_heterogeneous_meanfield_from_graph"><a class="viewcode-back" href="../methods.html#EoN.SIS_heterogeneous_meanfield_from_graph">[docs]</a><span class="k">def</span> <span class="nf">SIS_heterogeneous_meanfield_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                            <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Takes a graph and an initial proportion infected rho.  </span>
<span class="sd">    Calculates Sk0 and Ik0 and calls the heterogeneous meanfield model</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------------</span>
<span class="sd">    G : networkx Graph</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    rho : number between 0 and 1  (default None)</span>
<span class="sd">          the fraction to be randomly infected at time 0</span>
<span class="sd">          If None, then rho=1/N is used where N = G.order()</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        times, S, I, Sk, Ik, (the Xk are scipy 2D arrays)</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        times, S, I         (all scipy arrays)</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.configuration_model([1,2,3,4]*1000)</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I = EoN.SIS_heterogeneous_meanfield_from_graph(G, tau, gamma, </span>
<span class="sd">                                                            tmax = 15)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="c1">#Pk = get_Pk(G)</span>
    <span class="c1">#maxk = max(Pk.keys())</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="c1">#G.order()*scipy.array([Pk.get(k,0) for k in range(maxk+1)])</span>
    <span class="k">return</span> <span class="n">SIS_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="SIR_heterogeneous_meanfield_from_graph"><a class="viewcode-back" href="../methods.html#EoN.SIR_heterogeneous_meanfield_from_graph">[docs]</a><span class="k">def</span> <span class="nf">SIR_heterogeneous_meanfield_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                            <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Takes a graph and an initial proportion infected rho.  </span>
<span class="sd">    Calculates Sk0 and Ik0 and calls the heterogeneous meanfield model</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------------</span>
<span class="sd">    G : networkx Graph</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    rho : number between 0 and 1  (default None)</span>
<span class="sd">          the fraction to be randomly infected at time 0</span>
<span class="sd">          If None, then rho=1/N is used where N = G.order()</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>


<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True</span>
<span class="sd">        times, Sk, Ik, Rk (the Xk are scipy 2D arrays)</span>
<span class="sd">    if False,</span>
<span class="sd">        times, S, I, R (all scipy arrays)</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    G = nx.configuration_model([1,2,3,4]*1000)</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 2</span>
<span class="sd">    t, S, I, R = EoN.SIR_heterogeneous_meanfield_from_graph(G, tau, gamma, </span>
<span class="sd">                                                             tmax = 10)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">SIR_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> 
                                        <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="c1">#######      HETEROGENEOUS PAIRWISE</span>
<span class="k">def</span> <span class="nf">_dSIS_heterogeneous_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">Ks</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Gives the derivatives</span>


<span class="sd">    [\dot{Sk}] = gamma [Ik] - tau [SkI]</span>
<span class="sd">    [\dot{Ik}] = tau [SkI] - gamma [Ik]   = - [\dot{Sk}]</span>
<span class="sd">    [\dot{SkIl}] = gamma([IkIl] - [SkIl]) + tau([SkSlI] - [ISkIl] </span>
<span class="sd">                                                 - [SkIl])</span>
<span class="sd">    [\dot{SkSl}] = gamma([SkIl]+[IkSl]) - tau ([SkSlI] + [ISkSl])</span>
<span class="sd">    [\dot{IkIl}] = -2 gamma[IkIl] + tau ([SkIl]+[IkSl]+[ISkIl]+[IkSlI])</span>
<span class="sd">    [AlSkI] = ((k-1)/k) [AlSk][SkI]/[Sk]</span>
<span class="sd">    [ISkAl] = ((k-1)/k) [ISk][SkAl]/[Sk]</span>

<span class="sd">    So: [SkSlI] = ((l-1)/l) [SkSl][SlI]/[Sl] </span>
<span class="sd">        [ISkIl] = ((k-1)/k) [ISk] [SkIl]/[Sk]</span>
<span class="sd">        [ISkSl] = ((k-1)/k) [ISk] [SkSl]/[Sk]</span>
<span class="sd">        [IkSlI] = ((l-1)/l) [IkSl][SlI]/[Sl]</span>

<span class="sd">    conserved quantities : [Sk]+[Ik],  [SkSl] + [SkIl] + [IkIl] + [IkSl]</span>

<span class="sd">    identities: [IkSl] = [SlIk], so where IkSl needed, use SlIk.T</span>


<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    X : current values of variables</span>
<span class="sd">    t : current time</span>
<span class="sd">    Nk : The number of nodes of each degree; Nk[i] is the number of </span>
<span class="sd">         nodes with degree Ks[i]</span>
<span class="sd">    NkNl : number of edges of various types.  NkNl[i,j] corresponds to </span>
<span class="sd">           Ks[i] and Ks[j].</span>
<span class="sd">    tau : transmission rate</span>
<span class="sd">    gamma : recovery rate</span>
<span class="sd">    Ks : a scipy array --- gives the observed degrees in increasing </span>
<span class="sd">         order.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="n">kcount</span><span class="p">]</span>
    <span class="n">SkSl</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">kcount</span><span class="p">:</span> <span class="n">kcount</span> <span class="o">+</span> <span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">SkIl</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="n">kcount</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">SkSl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">)</span>
    <span class="n">SkIl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">)</span>

    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">Sk</span>
    <span class="n">SkI</span> <span class="o">=</span> <span class="n">SkIl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="c1">#sum(SkIl.T)</span>
    <span class="n">IkSl</span> <span class="o">=</span> <span class="n">SkIl</span><span class="o">.</span><span class="n">T</span>
    <span class="n">IkIl</span> <span class="o">=</span> <span class="n">NkNl</span> <span class="o">-</span> <span class="n">SkSl</span> <span class="o">-</span> <span class="n">SkIl</span> <span class="o">-</span> <span class="n">IkSl</span>

    <span class="n">Ls</span> <span class="o">=</span> <span class="n">Ks</span> <span class="c1">#easier to keep as l for readability of eqns</span>

    <span class="n">SlI</span> <span class="o">=</span> <span class="n">SkI</span> <span class="c1">#easier in this form for readability</span>
    <span class="n">ISk</span> <span class="o">=</span> <span class="n">SkI</span>

    <span class="n">tmpSk</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="n">Sk</span> <span class="c1">#the 1.* is to make it a copy, not the same object</span>
    <span class="n">tmpSk</span><span class="p">[</span><span class="n">tmpSk</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">SkSlI</span> <span class="o">=</span> <span class="n">SkSl</span> <span class="o">*</span> <span class="p">((</span><span class="n">Ls</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">SlI</span><span class="o">/</span> <span class="p">(</span><span class="n">Ls</span><span class="o">*</span><span class="n">tmpSk</span><span class="p">)</span>
    <span class="n">ISkIl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ISk</span> <span class="o">*</span> <span class="p">((</span><span class="n">Ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">SkIl</span><span class="o">.</span><span class="n">T</span><span class="o">/</span> <span class="p">(</span><span class="n">Ks</span><span class="o">*</span><span class="n">tmpSk</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ISkSl</span> <span class="o">=</span> <span class="n">SkSlI</span><span class="o">.</span><span class="n">T</span> 
    <span class="n">IkSlI</span> <span class="o">=</span> <span class="n">ISkIl</span><span class="o">.</span><span class="n">T</span> 
    
    <span class="n">dSk</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">Ik</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span><span class="n">SkI</span>
    <span class="n">dSkSl</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">SkIl</span> <span class="o">+</span> <span class="n">IkSl</span><span class="p">)</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SkSlI</span> <span class="o">+</span> <span class="n">ISkSl</span><span class="p">)</span>
    <span class="n">dSkIl</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">IkIl</span><span class="o">-</span><span class="n">SkIl</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SkSlI</span> <span class="o">-</span> <span class="n">ISkIl</span> <span class="o">-</span> <span class="n">SkIl</span><span class="p">)</span>

    <span class="n">dSkIl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dSkSl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">dSkSl</span><span class="p">,</span> <span class="n">dSkIl</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dX</span>

<span class="k">def</span> <span class="nf">_dSIR_heterogeneous_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">Ks</span><span class="p">):</span>
    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="n">kcount</span><span class="p">]</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">kcount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="p">]</span>
    <span class="n">SkSl</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">SkIl</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">SkSl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">)</span>
    <span class="n">SkIl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">)</span>

    <span class="n">SkI</span> <span class="o">=</span> <span class="n">SkIl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">IkSl</span> <span class="o">=</span> <span class="n">SkIl</span><span class="o">.</span><span class="n">T</span>

    <span class="n">Ls</span> <span class="o">=</span> <span class="n">Ks</span> <span class="c1">#easier to keep as l for readability of eqns</span>
    <span class="n">SlI</span> <span class="o">=</span> <span class="n">SkI</span>
    <span class="n">ISk</span> <span class="o">=</span> <span class="n">SkI</span>

    <span class="n">tmpSk</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="n">Sk</span> <span class="c1">#the 1.* is to make it a copy, not the same object</span>
    <span class="n">tmpSk</span><span class="p">[</span><span class="n">tmpSk</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">tmpSl</span> <span class="o">=</span> <span class="n">tmpSk</span>

    <span class="n">SkSlI</span> <span class="o">=</span> <span class="n">SkSl</span> <span class="o">*</span> <span class="p">((</span><span class="n">Ls</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">SlI</span><span class="o">/</span> <span class="p">(</span><span class="n">Ls</span><span class="o">*</span><span class="n">tmpSl</span><span class="p">)</span>
    <span class="n">ISkIl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ISk</span> <span class="o">*</span> <span class="p">((</span><span class="n">Ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">SkIl</span><span class="o">.</span><span class="n">T</span><span class="o">/</span> <span class="p">(</span><span class="n">Ks</span><span class="o">*</span><span class="n">tmpSk</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ISkSl</span> <span class="o">=</span> <span class="n">SkSlI</span><span class="o">.</span><span class="n">T</span> 
    <span class="n">IkSlI</span> <span class="o">=</span> <span class="n">ISkIl</span><span class="o">.</span><span class="n">T</span> 

    <span class="n">dSk</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">SkI</span>
    <span class="n">dIk</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">SkI</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">Ik</span>
    <span class="n">dSkIl</span> <span class="o">=</span> <span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">SkIl</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SkSlI</span> <span class="o">-</span> <span class="n">ISkIl</span> <span class="o">-</span> <span class="n">SkIl</span><span class="p">)</span>
    <span class="n">dSkSl</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SkSlI</span> <span class="o">+</span> <span class="n">ISkSl</span><span class="p">)</span>

    <span class="n">dSkIl</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dSkSl</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">dIk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> 
                                <span class="n">dSkSl</span><span class="p">,</span> <span class="n">dSkIl</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dX</span>



<div class="viewcode-block" id="SIS_heterogeneous_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIS_heterogeneous_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIS_heterogeneous_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Ks</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (5.13) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------------</span>
<span class="sd">    Sk0 : array.  Sk0[k] is the number of</span>
<span class="sd">                 nodes that are susceptible and have degree k.  If one </span>
<span class="sd">                 is empty, it becomes 0.</span>
<span class="sd">                 (if Ks is defined, the definition changes slightly, see</span>
<span class="sd">                  below)</span>

<span class="sd">    Ik0 : array</span>
<span class="sd">         similar to Sk0, but for infected.</span>
<span class="sd">        (if Ks is defined, the definition changes slightly, see below)</span>

<span class="sd">    SkSl0, SkIl0, and IkIl0 : 2D arrays</span>
<span class="sd">         SkIl0[k][l] is [S_kI_l]</span>
<span class="sd">             see below for constraints these should satisfy related to </span>
<span class="sd">             Sk0 and Ik0.  </span>
<span class="sd">             The code does not enforce these constraints.</span>
<span class="sd">             (if Ks is defined, the definition changes slightly, </span>
<span class="sd">              see below)</span>

<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>

<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>

<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>

<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>

<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>

<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       If True, return times, Sk, Ik, SkIl, SkSl, IkIl</span>
<span class="sd">                       If False, return times, S, I</span>

<span class="sd">    Ks : scipy array. (default None)</span>
<span class="sd">         (helps prevent memory errors) if some degrees are not</span>
<span class="sd">         observed, then the corresponding entries of these arrays are</span>
<span class="sd">         zero.  This can lead to memory errors in the case of a</span>
<span class="sd">         network with many missing degrees.  So Ks is an (assumed)</span>
<span class="sd">         ordered vector stating which Ks are actually observed.  Then</span>
<span class="sd">         the Sk0[i] is the number of nodes that are susceptible and</span>
<span class="sd">         have degree Ks[i].  Similarly for Ik0 and SkIl0 etc.</span>

<span class="sd">    In principle, there are constraints relating Sk with SkSl and SkIl </span>
<span class="sd">    and similarly relating Ik with IkIl and SkIl.T.  </span>
<span class="sd">    </span>
<span class="sd">    No attempt is made to enforce these.  </span>
<span class="sd">    </span>
<span class="sd">    It is assumed the user will ensure acceptible inputs.</span>

<span class="sd">    We could also remove Sk0 and Ik0 as inputs and infer them from the </span>
<span class="sd">    others, but for consistency with elsewhere, this is not done here.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True:</span>
<span class="sd">        returns times, S, I, Sk, Ik, SkIl, SkSl, IkIl</span>
<span class="sd">    if return_full_data is False:</span>
<span class="sd">        returns times, S, I</span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    import scipy</span>
<span class="sd">    Sk0 = 100 * scipy.ones(4)</span>
<span class="sd">    Ik0 = scipy.zeros(4)</span>
<span class="sd">    Ik0[3]=1</span>
<span class="sd">    SkSl0 = scipy.matrix([[0, 0,0,0],[0,100,0,0],[0,0,200,0],[0,0,0,294]])</span>
<span class="sd">    #only interact within a degree class, so the deg 1 and 2 are safe.</span>
<span class="sd">    SkIl0 = scipy.zeros((4,4))</span>
<span class="sd">    SkIl0[3,3] = 3</span>
<span class="sd">    IkIl0 = scipy.zeros((4,4))</span>
<span class="sd">    tau = 1</span>
<span class="sd">    gamma = 1</span>
<span class="sd">    </span>
<span class="sd">    t, S, I = EoN.SIS_heterogeneous_pairwise(Sk0, Ik0, SkSl0, SkIl0, IkIl0, tau, </span>
<span class="sd">                                                gamma)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">Ks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)))</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">+</span><span class="n">Ik0</span>
    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span>
    <span class="n">NkNl</span> <span class="o">=</span> <span class="n">SkSl0</span> <span class="o">+</span> <span class="n">SkIl0</span> <span class="o">+</span> <span class="n">IkIl0</span> <span class="o">+</span> <span class="n">SkIl0</span><span class="o">.</span><span class="n">T</span>
    <span class="n">SkSl0</span> <span class="o">=</span> <span class="n">SkSl0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">SkIl0</span> <span class="o">=</span> <span class="n">SkIl0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">SkSl0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">SkIl0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sk0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">my_odeint</span><span class="p">(</span><span class="n">_dSIS_heterogeneous_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nk</span><span class="p">,</span> <span class="n">NkNl</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">Ks</span><span class="p">))</span>

    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">kcount</span><span class="p">]</span>
    <span class="nb">print</span> <span class="n">Sk</span><span class="o">.</span><span class="n">size</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span> <span class="n">S</span><span class="o">.</span><span class="n">size</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sk</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ik</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="n">SkSl</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">kcount</span><span class="p">:</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcaount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
	<span class="n">SkIl</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">SkSl</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="n">SkIl</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
	<span class="n">IkIl</span> <span class="o">=</span> <span class="n">NkNl</span> <span class="o">-</span> <span class="n">SkSl</span> <span class="o">-</span> <span class="n">SkIl</span> <span class="o">-</span> <span class="n">SkIl</span><span class="o">.</span><span class="n">T</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">Ik</span><span class="p">,</span> <span class="n">SkIl</span><span class="p">,</span> <span class="n">SkSl</span><span class="p">,</span> <span class="n">IkIl</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>

<div class="viewcode-block" id="SIR_heterogeneous_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIR_heterogeneous_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIR_heterogeneous_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ks</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (5.15) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [\dot{S}_k] = -tau [S_k I]</span>
<span class="sd">    [\dot{I}_k] = tau [S_k I] - gamma [I_k]</span>
<span class="sd">    [\dot{R}_k] = gamma [I_k]  (but using Rk=Nk-Sk-Ik for this equation)</span>
<span class="sd">    [\dot{S_kI_l}] = -gamma[S_k I_l] + tau([S_k S_l I] - [I S_k I_l] </span>
<span class="sd">                                           - [S_k I_l])</span>
<span class="sd">    [\dot{S_kS_l}] = -tau([S_k S_l I] + [I S_k S_l])</span>

<span class="sd">    [A_l S_k I] = ((k-1)/k) [A_l S_k] [S_k I]/ [S_k]</span>
<span class="sd">    [I S_k A_l] = ((k-1)/k) [I S_k] [S_k A_l]/ [S_k]</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ----------</span>
<span class="sd">    Sk0 : scipy array, Sk0[k] is number of degree k susceptible at </span>
<span class="sd">          time 0.</span>
<span class="sd">    Ik0 : scipy array</span>
<span class="sd">    Rk0 : scipy array</span>
<span class="sd">    SkIl0 : scipy 2D array</span>
<span class="sd">    SkSl0 : scipy 2D array</span>

<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       If True, return times, Sk, Ik, Rk, SkIl, SkSl</span>
<span class="sd">                       If False, return times, S, I, R</span>


<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">    Ks : scipy array. (default None)</span>
<span class="sd">         (helps prevent memory errors) if some degrees are not</span>
<span class="sd">         observed, then the corresponding entries of these arrays are</span>
<span class="sd">         zero.  This can lead to memory errors in the case of a</span>
<span class="sd">         network with many missing degrees.  So Ks is an (assumed)</span>
<span class="sd">         ordered vector stating which Ks are actually observed.  Then</span>
<span class="sd">         the Sk0[i] is the number of nodes that are susceptible and</span>
<span class="sd">         have degree Ks[i].  Similarly for Ik0 and SkIl0 etc.        </span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True</span>
<span class="sd">        returns times, S, I, R, Sk, Ik, Rk, SkIl, SkSl</span>
<span class="sd">    if return_full_data is False</span>
<span class="sd">        return times, S, I, R</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">&#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">Ks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)))</span>
<span class="c1">#    print &quot;Ks is &quot;, Ks</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>

    <span class="n">Nk</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">+</span><span class="n">Ik0</span><span class="o">+</span><span class="n">Rk0</span>
    <span class="n">kcount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ks</span><span class="p">)</span>
    <span class="n">SkSl0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">SkIl0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sk0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">Ik0</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">),</span> 
                                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_heterogeneous_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">Ks</span><span class="p">))</span>

    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="n">kcount</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Ik</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">kcount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="p">]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ik</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">SkIl</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">SkSl</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">kcount</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">Rk</span> <span class="o">=</span> <span class="n">Nk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sk</span> <span class="o">-</span> <span class="n">Ik</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Rk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">SkIl</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="n">SkSl</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">kcount</span><span class="p">,</span><span class="n">kcount</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">Ik</span><span class="p">,</span> <span class="n">Rk</span><span class="p">,</span> <span class="n">SkIl</span><span class="p">,</span> <span class="n">SkSl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<span class="k">def</span> <span class="nf">SIS_heterogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span><span class="p">,</span> <span class="n">Ks</span> <span class="o">=</span> \
                <span class="n">get_NkNl_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">withKs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">Sk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ks</span><span class="p">])</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Ik0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ks</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">SIS_heterogeneous_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> 
                                        <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="p">,</span> 
                                        <span class="n">Ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ks</span><span class="p">))</span>

    
<span class="k">def</span> <span class="nf">SIR_heterogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>    
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">NkNl</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">Ks</span> <span class="o">=</span> <span class="n">get_NkNl_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">withKs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                                        <span class="n">SIR</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">Sk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ks</span><span class="p">])</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Ik0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ks</span><span class="p">])</span>
    <span class="n">Rk0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Rk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ks</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">SIR_heterogeneous_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>
                                        <span class="n">tmin</span> <span class="o">=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span>
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">,</span>
                                        <span class="n">Ks</span> <span class="o">=</span> <span class="n">Ks</span><span class="p">)</span>




<span class="c1">#######    COMPACT PAIRWISE</span>


<span class="k">def</span> <span class="nf">_dSIS_compact_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Nk</span><span class="p">,</span> <span class="n">twoM</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span> <span class="o">-</span> <span class="n">Sk</span>
    <span class="n">II</span> <span class="o">=</span> <span class="n">twoM</span> <span class="o">-</span> <span class="n">SS</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span>

    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk</span><span class="p">))</span>
    <span class="n">SX</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span> <span class="o">+</span> <span class="n">SS</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">SX</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ks</span><span class="o">*</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sk</span><span class="p">)</span>

    <span class="n">dSk</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span><span class="n">Ik</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">ks</span> <span class="o">*</span><span class="n">Sk</span> <span class="o">*</span><span class="n">SI</span><span class="o">/</span><span class="n">SX</span>
    <span class="n">dSI</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">II</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">SI</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dSS</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SS</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">Q</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSk</span><span class="p">,</span> <span class="p">[</span><span class="n">dSI</span><span class="p">,</span> <span class="n">dSS</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span>

<span class="k">def</span> <span class="nf">_dSIR_compact_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk</span><span class="p">))</span>
    <span class="n">SX</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sk</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">ks</span><span class="o">*</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sk</span><span class="p">)</span><span class="o">/</span><span class="n">SX</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sk</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span>
    
    <span class="n">dSk</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span> <span class="o">*</span> <span class="n">ks</span> <span class="o">*</span> <span class="n">Sk</span> <span class="o">*</span><span class="n">SI</span><span class="o">/</span><span class="n">SX</span>
    <span class="n">dSS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SS</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">Q</span>
    <span class="n">dSI</span> <span class="o">=</span> <span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">Q</span><span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSk</span><span class="p">,</span> <span class="p">[</span><span class="n">dSS</span><span class="p">,</span><span class="n">dSI</span><span class="p">,</span><span class="n">dR</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span> 


<div class="viewcode-block" id="SIS_compact_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIS_compact_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIS_compact_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (5.18) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [dot{S}_k] = gamma[I_k] - tau k [S_k] [SI]/[SX]</span>
<span class="sd">    [dot{I}_k] = tau * k *[S_k] [SI]/SX - gamma [I_k] = -[dot{S}_k]</span>
<span class="sd">    [dot{SI}] = gamma([II]-[SI]) + tau([SS]-[SI])[SI]Q - tau[SI]</span>
<span class="sd">    [dot{SS}] = 2 gamma[SI] - 2 tau [SS] [SI] Q</span>
<span class="sd">    [dot{II}] = 2 tau[SI] = 2 gamma[II] + 2 tau[SI]^2Q</span>
<span class="sd">    [SX] = sum_k k [S_k]</span>
<span class="sd">    Q = (1/[SX]^2) sum_k (k-1)k[S_k]</span>

<span class="sd">    INPUT</span>
<span class="sd">    -----</span>
<span class="sd">    Sk0 : scipy array</span>
<span class="sd">          number susceptible for each k</span>
<span class="sd">    Ik0 : scipy array</span>
<span class="sd">          number infected for each k</span>
<span class="sd">    SI0 : number</span>
<span class="sd">          number of SI edges</span>
<span class="sd">    SS0 : number</span>
<span class="sd">          number of SS edges</span>
<span class="sd">    II0 : number</span>
<span class="sd">          number of II edges</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       if True, return times, S, I, Sk, Ik, SI, SS, II</span>
<span class="sd">		       if False,  return times, S, I</span>




<span class="sd">    conserved quantities:  [Sk]+[Ik]     ;     SS + II + 2SI</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">+</span><span class="n">Ik0</span>
    <span class="n">twoM</span> <span class="o">=</span> <span class="n">SS0</span><span class="o">+</span><span class="n">II0</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">SI0</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sk0</span><span class="p">,</span> <span class="p">[</span><span class="n">SI0</span><span class="p">,</span><span class="n">SS0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_compact_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nk</span><span class="p">,</span> <span class="n">twoM</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>

    <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">Ik</span> <span class="o">=</span> <span class="n">Nk</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sk</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Ik</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">II</span> <span class="o">=</span> <span class="n">twoM</span> <span class="o">-</span> <span class="n">SS</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span>

    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">Ik</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">II</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>

<div class="viewcode-block" id="SIR_compact_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIR_compact_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIR_compact_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                            <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (5.19) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    [dot{S}_k] = -tau k [S_k] [SI]/[SX]</span>
<span class="sd">    [dot{SS}] = -2 tau [SS] [SI] Q</span>
<span class="sd">    [dot{SI}] = -gamma [SI] + tau([SS]-[SI])[SI]Q - tau [SI]</span>
<span class="sd">    [dot{R} = gamma [I]</span>
<span class="sd">    [SX] = sum_k k[S_k]</span>
<span class="sd">    Q = (1/[SX]^2) sum_k (k-1) k [S_k]</span>
<span class="sd">    [S] = sum [S_k]</span>
<span class="sd">    I = N-[S]-R</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Sk0 : scipy array</span>
<span class="sd">          initial number of suscetibles of each degree k</span>
<span class="sd">    I0 : number</span>
<span class="sd">         initial number infected</span>
<span class="sd">    R0 : number</span>
<span class="sd">         initial number recovered</span>
<span class="sd">    SS0 : number</span>
<span class="sd">          initial number of SS edges</span>
<span class="sd">    SI0 : number</span>
<span class="sd">          initial number of SI edges</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>

<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">I0</span><span class="o">+</span><span class="n">R0</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Sk0</span><span class="p">,</span> <span class="p">[</span><span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">R0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_compact_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">SI</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="n">Sk</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sk</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">R</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">Sk</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<span class="k">def</span> <span class="nf">SIS_compact_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">maxk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">Nk</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Pk</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">Sk0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">Nk</span>
    <span class="n">Ik0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">Nk</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">rho</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">II0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">rho</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxk</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SIS_compact_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span>

    
<span class="k">def</span> <span class="nf">SIR_compact_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)))</span> <span class="c1">#[0,1,2,3,...,k]</span>
    
    <span class="n">I0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">SX0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span><span class="n">ks</span><span class="p">)</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">SX0</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">SX0</span>
    
    <span class="k">return</span> <span class="n">SIR_compact_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span>
                                <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>




<span class="c1">#######SUPER COMPACT PAIRWISE</span>

<span class="k">def</span> <span class="nf">_dSIS_super_compact_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">k_ave</span><span class="p">,</span> <span class="n">ksquare_ave</span><span class="p">,</span> 
                                    <span class="n">kcube_ave</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    [\dot{I}] = tau [SI] - gamma [I]</span>
<span class="sd">    [\dot{SS}] = 2 gamma [SI] - 2 tau [SI] [SS] Q</span>
<span class="sd">    [\dot{SI}] = gamma ([II]-[SI]) + tau [SI] ([SS]-[SI])Q - tau [SI]</span>
<span class="sd">    [\dot{II}] = -2 gamma [II] + 2 tau [SI]^2 Q + 2 tau [SI]</span>
<span class="sd">    Q = ((&lt;K^2&gt;(&lt;K^2&gt;-n_S&lt;K&gt;) + &lt;K^3&gt;(n_S-&lt;K&gt;))</span>
<span class="sd">        /</span>
<span class="sd">        (n_S(&lt;K^2&gt;-&lt;K&gt;^2)) - 1)/n_S[S]</span>
<span class="sd">    n_S = ([SI] + [SS])/(N-[I])</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">I</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">II</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">I</span>
    
    <span class="n">n_S</span> <span class="o">=</span> <span class="p">(</span><span class="n">SS</span><span class="o">+</span><span class="n">SI</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    
    <span class="n">Q</span> <span class="o">=</span> <span class="p">((</span><span class="n">ksquare_ave</span><span class="o">*</span><span class="p">(</span><span class="n">ksquare_ave</span><span class="o">-</span><span class="n">n_S</span><span class="o">*</span><span class="n">k_ave</span><span class="p">)</span> \
            <span class="o">+</span> <span class="n">kcube_ave</span><span class="o">*</span><span class="p">(</span><span class="n">n_S</span><span class="o">-</span><span class="n">k_ave</span><span class="p">))</span> <span class="p">(</span><span class="n">n_S</span><span class="o">*</span><span class="p">(</span><span class="n">ksquare_ave</span><span class="o">-</span><span class="n">k_ave</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">n_S</span><span class="p">)</span>
    <span class="n">dIdt</span> <span class="o">=</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dSSdt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">SS</span><span class="o">*</span><span class="n">Q</span>
    <span class="n">dSIdt</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">II</span> <span class="o">-</span> <span class="n">SI</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dIIdt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">II</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SI</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Q</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SI</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dIdt</span><span class="p">,</span> <span class="n">dSSdt</span><span class="p">,</span> <span class="n">dSIdt</span><span class="p">,</span> <span class="n">dIIdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span>

<span class="k">def</span> <span class="nf">_dSIR_super_compact_pairwise_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> 
                                    <span class="n">psihatDPrime</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">SS</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">SI</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">psihat</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span> <span class="n">R</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">psihatDPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dThetadt</span> <span class="o">=</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="n">dSSdt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">SS</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">Q</span>
    <span class="n">dSIdt</span> <span class="o">=</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">SI</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">SS</span><span class="o">-</span><span class="n">SI</span><span class="p">)</span><span class="o">*</span><span class="n">SI</span><span class="o">*</span><span class="n">Q</span> <span class="o">-</span> <span class="n">tau</span><span class="o">*</span><span class="n">SI</span>
    <span class="n">dRdt</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dThetadt</span><span class="p">,</span> <span class="n">dSSdt</span><span class="p">,</span> <span class="n">dSIdt</span><span class="p">,</span> <span class="n">dRdt</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dX</span>


<div class="viewcode-block" id="SIS_super_compact_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIS_super_compact_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIS_super_compact_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">k_ave</span><span class="p">,</span> 
                                <span class="n">ksquare_ave</span><span class="p">,</span> <span class="n">kcube_ave</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (5.20) of Kiss, Miller, &amp; Simon.  Please cite the </span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    S0 : </span>
<span class="sd">    I0 :</span>
<span class="sd">    SS0 :</span>
<span class="sd">    SI0 :  </span>
<span class="sd">    II0 : </span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    k_ave : number</span>
<span class="sd">            average value of k</span>
<span class="sd">    ksquare_ave : number</span>
<span class="sd">            average value of k**2</span>
<span class="sd">    kcube_ave : number</span>
<span class="sd">            average value of k**3</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">             tells whether to just return times, S, I, R or all </span>
<span class="sd">             calculated data.</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data is True</span>
<span class="sd">        returns times, S, I, SS, SI, II</span>
<span class="sd">    if return_full_data is False</span>
<span class="sd">        returns times, S, I</span>
<span class="sd">        </span>
<span class="sd">    SAMPLE USE</span>
<span class="sd">    ----------</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import EoN</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="p">[</span><span class="n">I0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">II0</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">S0</span><span class="o">+</span><span class="n">I0</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_super_compact_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">k_ave</span><span class="p">,</span> <span class="n">ksquare_ave</span><span class="p">,</span> 
                                    <span class="n">kcube_ave</span><span class="p">))</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">II</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">I</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">II</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>



<div class="viewcode-block" id="SIR_super_compact_pairwise"><a class="viewcode-back" href="../methods.html#EoN.SIR_super_compact_pairwise">[docs]</a><span class="k">def</span> <span class="nf">SIR_super_compact_pairwise</span><span class="p">(</span><span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> 
                                <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">psihatDPrime</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (5.22) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    \dot{theta} = -tau [SI]/N*psihat(theta)</span>
<span class="sd">    [dot{SS}] = -2 tau [SS] [SI] Q</span>
<span class="sd">    [dot{SI}] = -gamma[SI] + tau([SS]-[SI])[SI]Q - tau*[SI]</span>
<span class="sd">    [dot{R}] = gamma*[I]</span>
<span class="sd">    [S] = N psihat(theta)</span>
<span class="sd">    [I] = N-[S]-[R]</span>
<span class="sd">    Q = psihat_xx(theta)/N(psihat_x(theta))^2</span>

<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">            tells whether to just return times, S, I, R or all </span>
<span class="sd">            calculated data.</span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">R0</span><span class="p">])</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_super_compact_pairwise_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> 
                                    <span class="n">psihatDPrime</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">theta</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">psihat</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">R</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>

<span class="k">def</span> <span class="nf">SIS_super_compact_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)))</span> <span class="c1">#[0,1,2,3,...,k]</span>

    <span class="n">S0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">SX0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span><span class="n">ks</span><span class="p">)</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">SX0</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">SX0</span>
    <span class="n">II0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Nk</span><span class="p">,</span><span class="n">ks</span><span class="p">)</span><span class="o">-</span><span class="n">SX0</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">Pks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Pk</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">])</span>
    <span class="n">k_ave</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Pks</span><span class="p">,</span> <span class="n">ks</span><span class="p">)</span>
    <span class="n">ksquare_ave</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Pks</span><span class="p">,</span> <span class="n">ks</span><span class="o">*</span><span class="n">ks</span><span class="p">)</span>
    <span class="n">kcube_ave</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Pks</span><span class="p">,</span> <span class="n">ks</span><span class="o">*</span><span class="n">ks</span><span class="o">*</span><span class="n">ks</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">SIS_super_compact_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                        <span class="n">k_ave</span><span class="p">,</span> <span class="n">ksquare_ave</span><span class="p">,</span> <span class="n">kcube_ave</span><span class="p">,</span> 
                                        <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SIR_super_compact_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)))</span> <span class="c1">#[0,1,2,3,...,k]</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">SX0</span> <span class="o">=</span> <span class="n">Sk0</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span>
    <span class="n">SS0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">SX0</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">SX0</span>

    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psihat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1">#probably faster if vectorized, </span>
                   <span class="c1">#but need to be careful with broadcasting...</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psihatPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psihatDPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>

    <span class="k">return</span>  <span class="n">SIR_super_compact_pairwise</span><span class="p">(</span><span class="n">SS0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> 
                                        <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">psihatDPrime</span><span class="p">,</span> 
                                        <span class="n">tmin</span> <span class="o">=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">tmax</span><span class="p">,</span> 
                                        <span class="n">tcount</span> <span class="o">=</span> <span class="n">tcount</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span> <span class="o">=</span> <span class="n">return_full_data</span><span class="p">)</span>






<span class="c1">########     EFFECTIVE DEGREE</span>


<span class="k">def</span> <span class="nf">_dSIS_effective_degree_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    \dot{S}_{s,i} = - tau i S_{s,i} + gamma*I_{s,i}</span>
<span class="sd">                    + gamma((i+1)S_{s-1,i+1}-iS_{s,i})</span>
<span class="sd">                    + tau[ISS]((s+1)S_{s+1,i-1} - sS_{s,i})/[SS]</span>

<span class="sd">    \dot{I}_{s,i} = tau i S_{s,i} - gamma I_{s,i}</span>
<span class="sd">                    + gamma((i+1)I_{s-1,i+1} - iI_{s,i})</span>
<span class="sd">                    + tau([ISI]/[SI] + 1)((s+1)I_{s+1,i-1} - sI_{s,i})</span>
<span class="sd">    S = sum S_{s,i}</span>
<span class="sd">    I = sum I_{s,i}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#note that dSIR_effective_degree has some commands for vectorizing </span>
    <span class="c1">#tentatively coded (and commented out)</span>
    <span class="n">ksq</span> <span class="o">=</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ssi</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="n">ksq</span><span class="p">]</span>
    <span class="n">Isi</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">ksq</span><span class="p">:]</span>
    <span class="n">Ssi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">original_shape</span>
    <span class="n">Isi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">original_shape</span>

    <span class="n">ISS</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">SS</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">ISI</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">SI</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

    <span class="n">g1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    
    <span class="n">dSsi</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="n">dIsi</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Ssm1ip1</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">Ism1ip1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ssm1ip1</span> <span class="o">=</span> <span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Ism1ip1</span> <span class="o">=</span> <span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">Ssp1im1</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">Isp1im1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ssp1im1</span> <span class="o">=</span> <span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Isp1im1</span> <span class="o">=</span> <span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="n">dSsi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> \
                        <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ssm1ip1</span> <span class="o">-</span> <span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> \
                        <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">ISS</span><span class="o">*</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ssp1im1</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">SS</span>
            <span class="n">dIsi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">tau</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> \
                        <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ism1ip1</span> <span class="o">-</span> <span class="n">i</span><span class="o">*</span><span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> \
                        <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">ISI</span><span class="o">/</span><span class="n">SI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Isp1im1</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">Isi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="c1"># </span>

    <span class="n">dSsi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dIsi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSsi</span><span class="p">,</span> <span class="n">dIsi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span>


<span class="k">def</span> <span class="nf">_dSIR_effective_degree_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ssi</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ssi</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="n">original_shape</span>
    <span class="n">ISS</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">SS</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">sum</span><span class="p">([</span><span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    
    <span class="c1">#commenting out commands for vectorizing this.  </span>
    <span class="c1">#I should do this eventually, but not now.  Apply to SIS version as well.</span>
    <span class="c1">#ultimately I think right option is to pad with zeros and then </span>
    <span class="c1">#cut out appropriate section.</span>
    <span class="c1">#ivec = scipy.array(range(original_shape[1]))</span>
    <span class="c1">#ivec.shape = (1,original_shape[1])</span>
    <span class="c1">#svec = scipy.array(range(original_shape[0]))</span>
    <span class="c1">#svec.shape = (original_shape[0],1)</span>
    <span class="c1">#</span>
    <span class="c1">#Ssip1 = Ssi[:,1:]</span>
    <span class="c1">#scipy.pad(Ssip1, pad_width=((0,0),(0,1)), mode = &#39;constant&#39;, </span>
    <span class="c1">#          constant_values=0)</span>
    <span class="c1">#Ssp1im1 = Ssi[1:,:-1]</span>
    <span class="c1">#scipy.pad(Ssp1im1, pad_width=((0,1),(1,0)), mode = &#39;constant&#39;, </span>
    <span class="c1">#           constant_values=0)</span>
    <span class="c1">#dSsi = - tau* ivec*Ssi + gamma*((ivec+1)*Ssip1 - i*Ssi) </span>
    <span class="c1">#       + tau *ISS*((svec+1)*Sp1im1 - svec*Ssi)/SS</span>

    <span class="n">dSsi</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Ssip1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ssip1</span> <span class="o">=</span> <span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Ssp1im1</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ssp1im1</span> <span class="o">=</span> <span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>            
            <span class="n">dSsi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ssip1</span> <span class="o">-</span> <span class="n">i</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> \
                        <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">ISS</span><span class="o">*</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Ssp1im1</span> <span class="o">-</span> <span class="n">s</span><span class="o">*</span><span class="n">Ssi</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">SS</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Ssi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> 
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">R</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>

    <span class="n">dSsi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSsi</span><span class="p">,</span> <span class="p">[</span><span class="n">dR</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dX</span>



<div class="viewcode-block" id="SIS_effective_degree"><a class="viewcode-back" href="../methods.html#EoN.SIS_effective_degree">[docs]</a><span class="k">def</span> <span class="nf">SIS_effective_degree</span><span class="p">(</span><span class="n">Ssi0</span><span class="p">,</span> <span class="n">Isi0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                            <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (5.36) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>


<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Ssi0 and Isi0 : (square) numpy 2D arrays of same shape.</span>
<span class="sd">                      Entries are initial number susceptible or infected </span>
<span class="sd">                      with given initial number of susceptible/infected </span>
<span class="sd">                      neighbors.</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean (default False)</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">                       if True, </span>
<span class="sd">                           return times, S, I, Ssi, Isi</span>
<span class="sd">                       if False, </span>
<span class="sd">                           return times, S, I</span>
<span class="sd">                       </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span><span class="n">tcount</span><span class="p">)</span> 
    <span class="n">original_shape</span> <span class="o">=</span> <span class="n">Ssi0</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ksq</span> <span class="o">=</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Ssi0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ksq</span><span class="p">)</span>
    <span class="n">Isi0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ksq</span><span class="p">)</span>
    
    <span class="n">X0</span><span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Ssi0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Isi0</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIS_effective_degree_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">Ssi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ksq</span><span class="p">]</span>
    <span class="n">Isi</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">ksq</span><span class="p">:]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Ssi</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">Isi</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">Ssi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tcount</span><span class="p">)</span>
        <span class="n">Isi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">tcount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Ssi</span><span class="p">,</span> <span class="n">Isi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span></div>

<div class="viewcode-block" id="SIR_effective_degree"><a class="viewcode-back" href="../methods.html#EoN.SIR_effective_degree">[docs]</a><span class="k">def</span> <span class="nf">SIR_effective_degree</span><span class="p">(</span><span class="n">S_si0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                            <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (5.38) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    \dot{S}_{s,i} = - tau i S_{s,i}  + gamma((i+1)S_{s,i+1} - i S_{s,i})</span>
<span class="sd">                    + tau [ISS]((s+1)S_{s+1,i-1} - sS_{s,i})/[SS]</span>
<span class="sd">    \dot{R} = gamma I</span>
<span class="sd">    S = \sum_{s,i} S_{s,i}</span>
<span class="sd">    I = N-S-R</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    S_si0 : (square) numpy 2-D array</span>
<span class="sd">            S_{s,i} at time 0</span>
<span class="sd">    I0 : number</span>
<span class="sd">         number of infected individuals at time 0</span>
<span class="sd">    R0 : number</span>
<span class="sd">         number of recovered individuals at time 0</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">S_si0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">+</span><span class="n">I0</span><span class="o">+</span><span class="n">R0</span>
    <span class="n">original_shape</span> <span class="o">=</span> <span class="n">S_si0</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">S_si0</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
    <span class="c1">#note this makes it array([[values...]])</span>
    <span class="n">R0</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R0</span><span class="p">])</span>
    <span class="n">R0</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">S_si0</span><span class="p">,</span> <span class="n">R0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_effective_degree_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">original_shape</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S_si</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S_si</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">R</span> <span class="o">-</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="n">S_si</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">original_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">original_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tcount</span><span class="p">)</span>
	<span class="k">return</span>  <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S_si</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>


<span class="k">def</span> <span class="nf">SIS_effective_degree_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">S_si0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)))</span>
    <span class="n">I_si0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="p">):</span>
            <span class="n">S_si0</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sk0</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> \
                            <span class="o">*</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>
            <span class="n">I_si0</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ik0</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> \
                            <span class="o">*</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>

    <span class="k">return</span> <span class="n">SIS_effective_degree</span><span class="p">(</span><span class="n">S_si0</span><span class="p">,</span> <span class="n">I_si0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="n">tmin</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SIR_effective_degree_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">S_si0</span><span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">)</span><span class="o">-</span><span class="n">s</span><span class="p">):</span>
            <span class="n">S_si0</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sk0</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> \
                            <span class="o">*</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ik0</span><span class="p">)</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Rk0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SIR_effective_degree</span><span class="p">(</span><span class="n">S_si0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>




<span class="c1">#######     COMPACT EFFECTIVE DEGREE</span>


<div class="viewcode-block" id="SIS_compact_effective_degree"><a class="viewcode-back" href="../methods.html#EoN.SIS_compact_effective_degree">[docs]</a><span class="k">def</span> <span class="nf">SIS_compact_effective_degree</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                    <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This model is identical to the SIS compact pairwise model, so it </span>
<span class="sd">    simply calls SIS_compact_pairwise()&#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">SIS_compact_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">II0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">SIS_compact_effective_degree_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                            <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                                            
    <span class="k">return</span> <span class="n">SIS_compact_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="p">,</span> 
                                            <span class="n">tmin</span> <span class="o">=</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> 
                                            <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dSIR_compact_effective_degree_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
    <span class="n">Skappa</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span> <span class="n">R</span><span class="o">-</span> <span class="n">Skappa</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">kappas</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Skappa</span><span class="p">))</span>
    <span class="n">effectiveI</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">)</span> <span class="o">/</span><span class="n">Skappa</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kappas</span><span class="p">)</span>
    <span class="n">dSkappa</span> <span class="o">=</span> <span class="n">effectiveI</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tau</span><span class="o">+</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">kappas</span><span class="o">*</span><span class="n">Skappa</span> \
                <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="n">shift</span><span class="p">(</span><span class="n">kappas</span><span class="o">*</span><span class="n">Skappa</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">dSI</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tau</span><span class="o">+</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">SI</span> \
            <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="p">(</span><span class="n">effectiveI</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">effectiveI</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">kappas</span><span class="o">*</span><span class="p">(</span><span class="n">kappas</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Skappa</span><span class="p">)</span>

    <span class="n">dR</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="n">dX</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dSkappa</span><span class="p">,</span> <span class="p">[</span><span class="n">dR</span><span class="p">,</span> <span class="n">dSI</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">dX</span>
    
<div class="viewcode-block" id="SIR_compact_effective_degree"><a class="viewcode-back" href="../methods.html#EoN.SIR_compact_effective_degree">[docs]</a><span class="k">def</span> <span class="nf">SIR_compact_effective_degree</span><span class="p">(</span><span class="n">Skappa0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                    <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                    <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (5.43) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    \dot{S}_kappa = &lt;I&gt; [-(tau+gamma) kappa S_kappa </span>
<span class="sd">                         + gamma(kappa+1)S_{kappa+1}</span>
<span class="sd">    [\dot{SI}] = -(tau+gamma)[SI] </span>
<span class="sd">                + tau(&lt;I&gt; - 2 &lt;I&gt;^2) sum_{kappa} kappa(kappa-1) S_kappa</span>
<span class="sd">    \dot{R} = gamma I</span>
<span class="sd">    &lt;I&gt; = [SI]/sum_kappa kappa S_kappa</span>
<span class="sd">    S = sum_kappa S_kappa</span>
<span class="sd">    I = N - S - R</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Skappa0 : scipy array</span>
<span class="sd">              from S_0(0) up to S_kappamax(0) of number susceptible with </span>
<span class="sd">                  each effective degree</span>
<span class="sd">              Skappa = number of nodes that are susceptible and have </span>
<span class="sd">                       kappa non-recovered neighbors</span>
<span class="sd">    I0 : number</span>
<span class="sd">         number of infected individuals at time 0</span>
<span class="sd">    R0 : number</span>
<span class="sd">         initial number recovered</span>
<span class="sd">    SI0 : number</span>
<span class="sd">          initial number of SI edges</span>
<span class="sd">    tau : number</span>
<span class="sd">          transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">            recovery rate</span>
<span class="sd">    tmin : number (default 0)</span>
<span class="sd">           minimum report time</span>
<span class="sd">    tmax : number (default 100)</span>
<span class="sd">           maximum report time </span>
<span class="sd">    tcount : integer (default 1001)</span>
<span class="sd">             number of reports</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       tells whether to just return times, S, I, R or </span>
<span class="sd">                       all calculated data.</span>
<span class="sd">    </span>
<span class="sd">    RETURNS (if return_full_data==False):</span>
<span class="sd">    --------</span>
<span class="sd">    times : scipy.array of times</span>
<span class="sd">    S : scipy.array of number susceptible</span>
<span class="sd">    I : scipy.array of number infected</span>
<span class="sd">    R : scipy.array of number recovered</span>

<span class="sd">    if return_full_data==True</span>
<span class="sd">    --------------------------</span>
<span class="sd">    times : as before</span>
<span class="sd">    Skappa : array of arrays, each subarray gives particular S_kappa</span>
<span class="sd">    I : number infected</span>
<span class="sd">    R : number recovered</span>
<span class="sd">    SI : number of SI edges</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">Skappa0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">+</span><span class="n">I0</span><span class="o">+</span><span class="n">R0</span>
    <span class="n">X0</span><span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Skappa0</span><span class="p">,[</span><span class="n">R0</span><span class="p">,</span><span class="n">SI0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dSIR_compact_effective_degree_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="n">Skappa</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Skappa</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">R</span><span class="p">,</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">S</span> <span class="o">-</span><span class="n">R</span>
    <span class="k">if</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Skappa</span><span class="p">,</span> <span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span></div>

<span class="k">def</span> <span class="nf">SIR_compact_effective_degree_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                            <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                            <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">Nk</span><span class="p">,</span> <span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span> <span class="o">=</span> <span class="n">get_Nk_and_IC_as_arrays</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">SIR</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Skappa0</span> <span class="o">=</span> <span class="n">Sk0</span>
    <span class="n">I0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span><span class="o">*</span><span class="n">rho</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">SI0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">k</span><span class="o">*</span><span class="n">Skappa0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">rho</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sk0</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">SIR_compact_effective_degree</span><span class="p">(</span><span class="n">Skappa0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                        <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>






<span class="c1">#######################################</span>
<span class="c1">#    EBCM and other related results   #</span>
<span class="c1">#######################################</span>

<div class="viewcode-block" id="Epi_Prob_discrete"><a class="viewcode-back" href="../methods.html#EoN.Epi_Prob_discrete">[docs]</a><span class="k">def</span> <span class="nf">Epi_Prob_discrete</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (6.2) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Pk : scipy array Pk[k] is probability a node has degree k.</span>

<span class="sd">    p : transmission probability</span>

<span class="sd">    number_its : number of iterations before assumed converged.</span>
<span class="sd">                 default value is 100</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ----------</span>
<span class="sd">    Calculated Epidemic probability (assuming configuration model)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pk</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pk</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">ks</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ks</span><span class="o">*</span><span class="n">Pk</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p</span>
    <span class="n">k_ave</span> <span class="o">=</span> <span class="n">psiPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_its</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p</span> <span class="o">+</span><span class="n">p</span> <span class="o">*</span><span class="n">psiPrime</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="n">k_ave</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span></div>

<div class="viewcode-block" id="Epi_Prob_cts_time"><a class="viewcode-back" href="../methods.html#EoN.Epi_Prob_cts_time">[docs]</a><span class="k">def</span> <span class="nf">Epi_Prob_cts_time</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">umin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">umax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ucount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> 
                        <span class="n">number_its</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes System (6.3) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    The equations are rescaled by setting $u=\gamma T$.  Then it becomes</span>

<span class="sd">    P = 1- \int_0^\infty \psi(\alpha(u/\gamma)) e^{-u} du</span>
<span class="sd">    alpha_d(u/\gamma) = 1- p(u/\gamma)</span>
<span class="sd">                        + p(u/\gamma)</span>
<span class="sd">                          \int_0^\infty </span>
<span class="sd">                                (\psiPrime(\alpha(\hat{u}/\gamma))/&lt;K&gt;)</span>
<span class="sd">                                e^{-u}du</span>

<span class="sd">    where p(u/\gamma) = 1 - e^{-\tau u/\gamma}</span>

<span class="sd">    Define </span>
<span class="sd">        \hat{p}(u) = p(u/\gamma), and \hat{\alpha}(u) = \alpha(u/\gamma)</span>
<span class="sd">    and then drop hats to get</span>

<span class="sd">    P = 1-\int_0^\infty \psi(\alpha(u)) e^{-u} du</span>
<span class="sd">    \alpha(u) = 1-p(u) + p(u) </span>
<span class="sd">                         \int_0^\infty </span>
<span class="sd">                              (\psiPrime(\alpha(u))/&lt;K&gt;)e^{-u} du</span>

<span class="sd">    with initial guess </span>
<span class="sd">        \alpha_1(u) = e^{-\tau u/\gamma} </span>
<span class="sd">    and </span>
<span class="sd">        p(u) = 1-e^{-\tau u/\gamma}</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Pk : scipy array Pk[k] is probability a node has degree k.</span>

<span class="sd">    tau : transmission rate</span>

<span class="sd">    gamma : recovery rate</span>

<span class="sd">    umin : minimal value of \gamma T used in calculation</span>
<span class="sd">    umax : maximum value of \gamma T used in calculation</span>
<span class="sd">    ucount : number of points taken for integral.</span>
<span class="sd">             So this integrates from umin to umax using simple Riemann </span>
<span class="sd">             sum.</span>

<span class="sd">    number_its : number of iterations before assumed converged.</span>
<span class="sd">                 default value is 100</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ----------</span>
<span class="sd">    Calculated Epidemic probability (assuming configuration model)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pk</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pk</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">ks</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">ks</span><span class="o">*</span><span class="n">Pk</span>
        <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ks</span><span class="o">*</span><span class="n">Pk</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">us</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span> <span class="n">ucount</span><span class="p">)</span> 
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">us</span><span class="o">/</span><span class="n">gamma</span><span class="p">)</span>  <span class="c1">#initial guess for alpha(u)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">us</span><span class="o">/</span><span class="n">gamma</span><span class="p">)</span>    <span class="c1">#initial guess for p(u)</span>
    <span class="n">exp_neg_u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">us</span><span class="p">)</span>        <span class="c1">#e^{-u}</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">number_its</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span> <span class="p">(</span><span class="n">psiPrime</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="n">kave</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_neg_u</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ucount</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_neg_u</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ucount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Epi_Prob_non_Markovian"><a class="viewcode-back" href="../methods.html#EoN.Epi_Prob_non_Markovian">[docs]</a><span class="k">def</span> <span class="nf">Epi_Prob_non_Markovian</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">Pxidxi</span><span class="p">,</span> <span class="n">po</span><span class="p">,</span> <span class="n">umin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">umax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> 
                            <span class="n">ucount</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (6.5) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ---------</span>
<span class="sd">    Pk : scipy array Pk[k] is probability a node has degree k.</span>

<span class="sd">    tau : transmission rate</span>

<span class="sd">    gamma : recovery rate</span>

<span class="sd">    Pxidxi : a dict.  Returns P(xi)dxi for user-selected xi.  The </span>
<span class="sd">             algorithm will replace the integral with</span>
<span class="sd">             \sum_{xi \in Pxidxi.keys()} \psi(\alpha(xi)) Pxidxi(xi)</span>

<span class="sd">    po : a function.</span>
<span class="sd">         returns p_o(xi), the probability a node will transmit to a </span>
<span class="sd">         random neighbor given xi.</span>
<span class="sd">    umin : minimal value of \gamma T used in calculation</span>
<span class="sd">    umax : maximum value of \gamma T used in calculation</span>
<span class="sd">    ucount : number of points taken for integral.</span>
<span class="sd">             So this integrates from umin to umax using simple Riemann </span>
<span class="sd">             sum.</span>

<span class="sd">    number_its : number of iterations before assumed converged.</span>
<span class="sd">                 default value is 100</span>

<span class="sd">    RETURNS</span>
<span class="sd">    ----------</span>
<span class="sd">    Calculated Epidemic probability (assuming configuration model)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pk</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pk</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">ks</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ks</span><span class="o">*</span><span class="n">Pk</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">ks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">xis</span> <span class="o">=</span> <span class="n">Pxidxi</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="n">po</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xis</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">number_its</span><span class="p">):</span>
        <span class="n">newalpha</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xis</span><span class="p">:</span>
            <span class="n">newalpha</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">po</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>  \
                            <span class="o">+</span> <span class="n">po</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">psiPrime</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">xihat</span><span class="p">])</span><span class="o">*</span><span class="n">Pxidxi</span><span class="p">(</span><span class="n">xihat</span><span class="p">)</span> 
                                                <span class="k">for</span> <span class="n">xihat</span> <span class="ow">in</span> <span class="n">xis</span><span class="p">)</span><span class="o">/</span><span class="n">kave</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">newalpha</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">psi</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span><span class="o">*</span><span class="n">Pxidxi</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Attack_rate_discrete"><a class="viewcode-back" href="../methods.html#EoN.Attack_rate_discrete">[docs]</a><span class="k">def</span> <span class="nf">Attack_rate_discrete</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">number_its</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Sk0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                            <span class="n">phiS0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phiR0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Encodes systems (6.6) and (6.10) of Kiss, Miller, &amp; Simon.  Please </span>
<span class="sd">    cite the book if using this algorithm.</span>

<span class="sd">    To use system (6.6), leave rho and Sk0 as None.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">        Pk[k] is the probability a randomly selected node has degree k.</span>
<span class="sd">    tau : number</span>
<span class="sd">        per-edge transmission rate.</span>
<span class="sd">    gamma : number</span>
<span class="sd">        per-node recovery rate</span>
<span class="sd">    number_its : The solution is found iteratively, so this determines </span>
<span class="sd">                 the number of iterations.</span>
<span class="sd">    rho : Number (default None)</span>
<span class="sd">    Sk0 : dict (default None)</span>
<span class="sd">          only one of rho and Sk0 can be defined.  </span>
<span class="sd">          The other (or both) should remain None.</span>
<span class="sd">          rho gives the fraction of nodes randomly infected.</span>
<span class="sd">          Sk0 is a dict such that Sk0[k] is the probability that a </span>
<span class="sd">              degree k node is susceptible at start.</span>
<span class="sd">    phiS0 : number (default None)</span>
<span class="sd">          Should only be used if Sk0 is not None.  </span>
<span class="sd">          If it is None, then assumes that initial introduction is </span>
<span class="sd">          randomly introduced</span>
<span class="sd">    phiR0 : number (default 0)</span>
<span class="sd">          As with phiS0, only used if Sk0 is not None.</span>
<span class="sd">    OUTPUT</span>
<span class="sd">    ------</span>
<span class="sd">    A : number</span>
<span class="sd">        the predicted fraction infected.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Sk0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;at most one of rho and Sk0 can be defined&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Sk0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rho</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Epi_Prob_discrete</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">number_its</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Sk0</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">def</span> <span class="nf">psihat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">psihatPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">phiS0</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phiS0</span> <span class="o">=</span> <span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">phiR0</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phiR0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">theta</span>  <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">number_its</span><span class="p">):</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="n">phiR0</span> <span class="o">+</span>  <span class="n">phiS0</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">psihat</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">Attack_rate_discrete_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                        <span class="n">Sk0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pks</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Attack_rate_discrete_from_graph</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span> <span class="n">number_its</span><span class="p">,</span> 
                                            <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="p">,</span> <span class="n">Sk0</span> <span class="o">=</span> <span class="n">Sk0</span><span class="p">)</span>

<div class="viewcode-block" id="Attack_rate_cts_time"><a class="viewcode-back" href="../methods.html#EoN.Attack_rate_cts_time">[docs]</a><span class="k">def</span> <span class="nf">Attack_rate_cts_time</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">Sk0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">phiS0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phiR0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1">#tested in test_SIR_final_sizes</span>
    <span class="sd">&#39;&#39;&#39;Encodes system (6.7) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    </span>
<span class="sd">    This system predicts the fraction of nodes infected if an epidemic </span>
<span class="sd">    occurs in a Configuration Model network assuming a continuous-time </span>
<span class="sd">    Markovian SIR disease.  </span>
<span class="sd">    </span>
<span class="sd">    This gives the limit of the attack rate of epidemics as the initial </span>
<span class="sd">    fraction infected approaches 0.</span>

<span class="sd">    If we look for the limit of a nonzero initial fraction infected, we </span>
<span class="sd">    introduce rho or Sk0</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    Pk : dict</span>
<span class="sd">        Pk[k] is the probability a randomly selected node has degree k.</span>
<span class="sd">    tau : number</span>
<span class="sd">        per-edge transmission rate.</span>
<span class="sd">    gamma : number</span>
<span class="sd">        per-node recovery rate</span>
<span class="sd">    number_its : The solution is found iteratively, so this determines </span>
<span class="sd">                 the number of iterations.</span>
<span class="sd">    rho : Number (default None)</span>
<span class="sd">    Sk0 : dict (default None)</span>
<span class="sd">          only one of rho and Sk0 can be defined.  </span>
<span class="sd">          The other (or both) should remain None.</span>
<span class="sd">          rho gives the fraction of nodes randomly infected.</span>
<span class="sd">          Sk0 is a dict such that Sk0[k] is the probability that a </span>
<span class="sd">              degree k node is susceptible at start.</span>

<span class="sd">    OUTPUT</span>
<span class="sd">    ------</span>
<span class="sd">    A : number</span>
<span class="sd">        the predicted fraction infected.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Sk0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EoNError</span><span class="p">(</span><span class="s2">&quot;at most one of rho and Sk0 can be defined&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Sk0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Sk0</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">def</span> <span class="nf">psihat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">psihatPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">Sk0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">phiS0</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phiS0</span> <span class="o">=</span> <span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">phiR0</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phiR0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">kave</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">/</span><span class="p">(</span><span class="n">gamma</span><span class="o">+</span><span class="n">tau</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">counter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_its</span><span class="p">):</span>
        <span class="nb">print</span> <span class="n">omega</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">/</span><span class="p">(</span><span class="n">gamma</span><span class="o">+</span><span class="n">tau</span><span class="p">)</span> \
                <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">phiS0</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">gamma</span><span class="o">+</span><span class="n">tau</span><span class="p">))</span> \
                <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">phiR0</span><span class="o">/</span><span class="p">(</span><span class="n">gamma</span><span class="o">+</span><span class="n">tau</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">psihat</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span></div>

<div class="viewcode-block" id="Attack_rate_cts_time_from_graph"><a class="viewcode-back" href="../methods.html#EoN.Attack_rate_cts_time_from_graph">[docs]</a><span class="k">def</span> <span class="nf">Attack_rate_cts_time_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>  <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">Sk0</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Given a graph, predicts the attack rate for Configuration Model </span>
<span class="sd">    networks with the given degree distribution.</span>
<span class="sd">    </span>
<span class="sd">    First calculates the degree distribution and then calls </span>
<span class="sd">    Attack_rate_cts_time</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Attack_rate_cts_time</span><span class="p">(</span><span class="n">Pk</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">number_its</span> <span class="o">=</span> <span class="n">number_its</span><span class="p">,</span> 
                                <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">Sk0</span><span class="o">=</span><span class="n">Sk0</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Attack_rate_non_Markovian"><a class="viewcode-back" href="../methods.html#EoN.Attack_rate_non_Markovian">[docs]</a><span class="k">def</span> <span class="nf">Attack_rate_non_Markovian</span><span class="p">():</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (6.8) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="EBCM_discrete"><a class="viewcode-back" href="../methods.html#EoN.EBCM_discrete">[docs]</a><span class="k">def</span> <span class="nf">EBCM_discrete</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">phiS0</span><span class="p">,</span> <span class="n">phiR0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                    <span class="n">return_full_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_basic_discrete_SIR_epidemic</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (6.11) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    theta(t) = (1-p) + p(phi_R(0) </span>
<span class="sd">               + phi_S(0) psihatPrime(theta(t-1))/psihatPrime(1))</span>
<span class="sd">    R(t) = R(t-1) + I(t-1)</span>
<span class="sd">    S(t) = N psihat(theta(t))</span>
<span class="sd">    I(t) = N-S-R</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    N : number</span>
<span class="sd">        size of population</span>
<span class="sd">    psihat : function</span>
<span class="sd">        psihat(x) = \sum_k S(k,0) x^k</span>
<span class="sd">    psihatPrime : function</span>
<span class="sd">        psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</span>
<span class="sd">    p : number</span>
<span class="sd">        per edge transmission probability</span>
<span class="sd">    phiS0 : number</span>
<span class="sd">            initial proportion of edges (of susceptible nodes) </span>
<span class="sd">            connecting to susceptible nodes</span>
<span class="sd">    phiR0 : number</span>
<span class="sd">            initial proportion of edges (of susceptible nodes) </span>
<span class="sd">            connecting to recovered nodes</span>
<span class="sd">    R0 : number</span>
<span class="sd">        number of recovered nodes at time 0</span>
<span class="sd">    tmax : number</span>
<span class="sd">        maximum time</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">                       if False, </span>
<span class="sd">                           return t, S, I, R</span>
<span class="sd">                       if True </span>
<span class="sd">                           return t, S, I, R, and theta</span>

<span class="sd">    OUTPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data == False:</span>
<span class="sd">        returns t, S, I, R, all scipy arrays</span>
<span class="sd">    if ...== True</span>
<span class="sd">        returns t, S, I, R and theta, all scipy arrays</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">[</span><span class="n">R0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="o">*</span><span class="n">psihat</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">tmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">newtheta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span><span class="p">(</span><span class="n">phiR0</span> 
                                <span class="o">+</span> <span class="n">phiS0</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">newR</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newS</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">psihat</span><span class="p">(</span><span class="n">newtheta</span><span class="p">)</span>
        <span class="n">newI</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">newR</span><span class="o">-</span><span class="n">newS</span>
        <span class="n">theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newtheta</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newR</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newS</span><span class="p">)</span>
        <span class="n">I</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newI</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                    <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> \
                    <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="EBCM_discrete_uniform_introduction"><a class="viewcode-back" href="../methods.html#EoN.EBCM_discrete_uniform_introduction">[docs]</a><span class="k">def</span> <span class="nf">EBCM_discrete_uniform_introduction</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">psiPrime</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_basic_discrete_SIR_epidemic</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Handles the case that the disease is introduced uniformly as opposed</span>
<span class="sd">    to depending on degree.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    N : Number</span>
<span class="sd">        number of nodes</span>
<span class="sd">    psi : function</span>
<span class="sd">        psi(x) = \sum P(k) x^k</span>
<span class="sd">    psiPrime : function</span>
<span class="sd">        psiPrime(x)=d psi(x)/dx = \sum kP(k) x^{k-1}</span>
<span class="sd">    p : number</span>
<span class="sd">        per edge transmission probability</span>
<span class="sd">    rho : number</span>
<span class="sd">        initial proportion of infected nodes</span>
<span class="sd">    tmax : number</span>
<span class="sd">        maximum time</span>
<span class="sd">    return_full-data : boolean</span>
<span class="sd">        if False, </span>
<span class="sd">            return t, S, I, R</span>
<span class="sd">        if True </span>
<span class="sd">            return t, S, I, R, and theta</span>

<span class="sd">    OUTPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data == False:</span>
<span class="sd">        returns t, S, I, R, all scipy arrays</span>
<span class="sd">    if ...== True</span>
<span class="sd">        returns t, S, I, R and theta, all scipy arrays</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">psihat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psihatPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">EBCM_discrete</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> 
                            <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">EBCM_discrete_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_basic_discrete_SIR_epidemic</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes a given graph, finds the degree distribution </span>
<span class="sd">    (from which it gets psi),</span>
<span class="sd">    assumes a constant proportion of the population is infected at time </span>
<span class="sd">    0, </span>
<span class="sd">    and then uses the discrete EBCM model.</span>
<span class="sd">    </span>
<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    G : Networkx Graph</span>
<span class="sd">    p : number</span>
<span class="sd">        per edge transmission probability</span>
<span class="sd">    rho : number</span>
<span class="sd">        initial proportion of infected nodes</span>
<span class="sd">    tmax : number</span>
<span class="sd">        maximum time</span>
<span class="sd">    return_full-data : boolean</span>
<span class="sd">        if False, </span>
<span class="sd">            return t, S, I, R and if True return t, S, I, R, and theta</span>

<span class="sd">    OUTPUTS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data == False:</span>
<span class="sd">        returns t, S, I, R, all scipy arrays</span>
<span class="sd">    if ...== True</span>
<span class="sd">        returns t, S, I, R and theta, all scipy arrays</span>
<span class="sd"> &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EBCM_discrete_uniform_introduction</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">psi</span><span class="p">,</span> <span class="n">psiPrime</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> 
                                                <span class="n">rho</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> 
                                                <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dEBCM_</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">phiS0</span><span class="p">,</span> <span class="n">phiR0</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">dtheta</span> <span class="o">=</span> <span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">theta</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">phiS0</span><span class="o">*</span><span class="n">psihatPrime</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">psihatPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> \
                <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau</span><span class="o">*</span><span class="n">phiR0</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">psihat</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">R</span>
    <span class="n">dR</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dtheta</span><span class="p">,</span> <span class="n">dR</span><span class="p">])</span>
    
<div class="viewcode-block" id="EBCM"><a class="viewcode-back" href="../methods.html#EoN.EBCM">[docs]</a><span class="k">def</span> <span class="nf">EBCM</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">phiS0</span><span class="p">,</span> <span class="n">phiR0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">R0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
            <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Encodes system (6.12) of Kiss, Miller, &amp; Simon.  Please cite the</span>
<span class="sd">    book if using this algorithm.</span>

<span class="sd">    note : R0 is R(0), not the reproductive number</span>


<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    N : number</span>
<span class="sd">        size of population</span>
<span class="sd">    psihat : function</span>
<span class="sd">             psihat(x) = \sum_k S(k,0) x^k</span>
<span class="sd">    psihatPrime : function</span>
<span class="sd">               psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</span>
<span class="sd">    tau : number</span>
<span class="sd">        per edge transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">        per node recovery rate</span>
<span class="sd">    phiS0 : number</span>
<span class="sd">            initial proportion of edges (of susceptible nodes) </span>
<span class="sd">            connecting to susceptible nodes</span>
<span class="sd">    phiR0 : number</span>
<span class="sd">            initial proportion of edges (of susceptible nodes) </span>
<span class="sd">            connecting to recovered nodes</span>
<span class="sd">    R0 : number</span>
<span class="sd">        number of recovered nodes at time 0</span>
<span class="sd">    tmin : number</span>
<span class="sd">        start time</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    tcount : integer</span>
<span class="sd">        number of distinct times to calculate</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">        if False, </span>
<span class="sd">            return t, S, I, R</span>
<span class="sd">        if True </span>
<span class="sd">            return t, S, I, R, and theta</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data == False:</span>
<span class="sd">        returns t, S, I, R, all scipy arrays</span>
<span class="sd">    if ...== True</span>
<span class="sd">        returns t, S, I, R and theta, all scipy arrays</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="p">)</span>
    <span class="n">X0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">R0</span><span class="p">])</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">_dEBCM_</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> 
                            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">phiS0</span><span class="p">,</span> 
                                        <span class="n">phiR0</span><span class="p">))</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">psihat</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="n">S</span><span class="o">-</span><span class="n">R</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_full_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="EBCM_uniform_introduction"><a class="viewcode-back" href="../methods.html#EoN.EBCM_uniform_introduction">[docs]</a><span class="k">def</span> <span class="nf">EBCM_uniform_introduction</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">psiPrime</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> 
                                <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">    Handles the case that the disease is introduced uniformly as opposed</span>
<span class="sd">    to depending on degree.</span>

<span class="sd">    INPUTS</span>
<span class="sd">    ------</span>
<span class="sd">    N : number</span>
<span class="sd">        size of population</span>
<span class="sd">    psi : function</span>
<span class="sd">        psihat(x) = \sum_k S(k,0) x^k</span>
<span class="sd">    psiPrime : function</span>
<span class="sd">        psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</span>
<span class="sd">    tau : number</span>
<span class="sd">        per edge transmission rate</span>
<span class="sd">    gamma : number</span>
<span class="sd">        per node recovery rate</span>
<span class="sd">    rho : number</span>
<span class="sd">        initial proportion infected</span>
<span class="sd">    tmin : number</span>
<span class="sd">        start time</span>
<span class="sd">    tmax : number</span>
<span class="sd">        stop time</span>
<span class="sd">    tcount : integer</span>
<span class="sd">        number of distinct times to calculate</span>
<span class="sd">    return_full_data : boolean</span>
<span class="sd">        if False,</span>
<span class="sd">            return t, S, I, R </span>
<span class="sd">        if True </span>
<span class="sd">            return t, S, I, R, and theta</span>

<span class="sd">    RETURNS</span>
<span class="sd">    -------</span>
<span class="sd">    if return_full_data == False:</span>
<span class="sd">        returns t, S, I, R, all scipy arrays</span>
<span class="sd">    if ...== True</span>
<span class="sd">        returns t, S, I, R and theta, all scipy arrays</span>
<span class="sd">&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">psihat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psihatPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">EBCM</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">psihat</span><span class="p">,</span> <span class="n">psihatPrime</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> 
                <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">tcount</span><span class="o">=</span><span class="n">tcount</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">EBCM_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                        <span class="n">tcount</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span> <span class="n">return_full_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1">#tested in test_SIR_dynamics</span>
    <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
    <span class="n">Pk</span> <span class="o">=</span> <span class="n">get_Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">psiPrime</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">Pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Pk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EBCM_uniform_introduction</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">psi</span><span class="p">,</span> <span class="n">psiPrime</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                        <span class="n">rho</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> 
                                        <span class="n">return_full_data</span><span class="o">=</span><span class="n">return_full_data</span><span class="p">)</span>

<div class="viewcode-block" id="EBCM_discrete_from_graph"><a class="viewcode-back" href="../methods.html#EoN.EBCM_discrete_from_graph">[docs]</a><span class="k">def</span> <span class="nf">EBCM_discrete_from_graph</span><span class="p">():</span>
    <span class="sd">r&#39;&#39;&#39;Nothing to see here </span>
<span class="sd">    - just a place holder until this code is written&#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="EBCM_deg_corr"><a class="viewcode-back" href="../methods.html#EoN.EBCM_deg_corr">[docs]</a><span class="k">def</span> <span class="nf">EBCM_deg_corr</span><span class="p">():</span>
    <span class="sd">r&#39;&#39;&#39;Nothing to see here </span>
<span class="sd">    - just a place holder until this code is written&#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="EBCM_deg_corr_discrete"><a class="viewcode-back" href="../methods.html#EoN.EBCM_deg_corr_discrete">[docs]</a><span class="k">def</span> <span class="nf">EBCM_deg_corr_discrete</span><span class="p">():</span>
    <span class="sd">r&#39;&#39;&#39;Nothing to see here </span>
<span class="sd">    - just a place holder until this code is written&#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="EBCM_deg_corr_from_graph"><a class="viewcode-back" href="../methods.html#EoN.EBCM_deg_corr_from_graph">[docs]</a><span class="k">def</span> <span class="nf">EBCM_deg_corr_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">r&#39;&#39;&#39;Nothing to see here </span>
<span class="sd">    - just a place holder until this code is written&#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="EBCM_deg_corr_discrete_from_graph"><a class="viewcode-back" href="../methods.html#EoN.EBCM_deg_corr_discrete_from_graph">[docs]</a><span class="k">def</span> <span class="nf">EBCM_deg_corr_discrete_from_graph</span><span class="p">():</span>
    <span class="sd">r&#39;&#39;&#39;Nothing to see here </span>
<span class="sd">    - just a place holder until this code is written&#39;&#39;&#39;</span>
    <span class="k">pass</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">These are the systems I want to include based on their numbering in the </span>
<span class="sd">book:</span>

<span class="sd">coded (3.7) SIS individual based</span>
<span class="sd">(3.30) SIR individual based</span>
<span class="sd">NOT coded (3.26) SIS pair based</span>
<span class="sd">(3.39) SIR pair based</span>

<span class="sd">chapter 4?</span>

<span class="sd">(5.13) SIS heterogeneous pairwise</span>
<span class="sd">(5.15) SIR heterogeneous pairwise</span>
<span class="sd">(5.18) SIS compact pairwise</span>
<span class="sd">(5.19) SIR compact pairwise</span>
<span class="sd">(5.20) SIS super compact pairwise</span>
<span class="sd">(5.22) SIR super compact pairwise</span>
<span class="sd">(5.36) SIS effective degree</span>
<span class="sd">(5.38) SIR effective degree</span>
<span class="sd">(5.43) SIR compact effective degree</span>
<span class="sd">(5.44) SIS compact effective degree = SIS compact pairwise</span>

<span class="sd">(6.2) Epidemic probability discrete time</span>
<span class="sd">(6.3) Epidemic probability continuous time</span>
<span class="sd">(6.5) Epidemic probability non-Markovian</span>
<span class="sd">(6.6) Epidemic size discrete time</span>
<span class="sd">(6.7) Epidemic size continuous time</span>
<span class="sd">(6.8) Epidemic size non-Markovian</span>
<span class="sd">(6.10) Epidemic size discrete time (large IC)</span>
<span class="sd">(6.11) Discrete-time EBCM model</span>
<span class="sd">(6.12) Continuous time EBCM model</span>

<span class="sd">(8.1) SIS pairwise contact conserving rewiring</span>
<span class="sd">(8.5) SIS eff. deg. contact conserving rewiring</span>
<span class="sd">(8.7) SIS pairwise random activation/deletion</span>
<span class="sd">(8.13) SIS eff. deg. random activation/deletion</span>
<span class="sd">(8.15) SIS pairwise link-status dependent act/del</span>
<span class="sd">(8.16) SIS link deactivation-activation on fixed networks.</span>
<span class="sd">(8.19) EBCM dynamic network</span>

<span class="sd">(9.5) SI^{K}R multistage pairwise for homogeneous</span>
<span class="sd">(9.27) SIR pairwise, constant infection duration.</span>
<span class="sd">(9.35) SIR homogeneous pairwise, general recovery</span>
<span class="sd">(9.36) SIR EBCM non-Markovian trans/recovery</span>

<span class="sd">add models that take in graph, measure degree distribution and run EBCM</span>
<span class="sd">similarly for EBCM with neighbor degrees (see barabasi_SIR.py)</span>

<span class="sd">consider explicitly defining toast graph etc.</span>

<span class="sd">SIR_pair_based --- which of 2 versions to keep, and comments need to </span>
<span class="sd">                   explain it a bit better.</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Epidemics on Networks 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Joel Miller, Istvan Kiss, Peter Simon.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>