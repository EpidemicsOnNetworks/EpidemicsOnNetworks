<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>EON documentation &#8212; Epidemics on Networks 0.91 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.91',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="QuickStart Guide" href="quickstart.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="QuickStart Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Epidemics on Networks 0.91 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-EoN">
<span id="eon-documentation"></span><h1>EON documentation<a class="headerlink" href="#module-EoN" title="Permalink to this headline">¶</a></h1>
<p>epidemicsonnetworks &#8211; EoN</p>
<p>&#8220;Epidemics on Networks&#8221;</p>
<p>EoN is a Python package for the simulation of epidemics on networks 
and ODE models of disease spread.</p>
<p>The algorithms are based on the book</p>
<p><cite>Mathematics of epidemics on networks: from exact to approximate 
models</cite>
by Kiss, Miller &amp; Simon</p>
<blockquote>
<div><a class="reference external" href="http://www.springer.com/book/9783319508047">http://www.springer.com/book/9783319508047</a></div></blockquote>
<p>Please cite the book if using these algorithms</p>
<p>For simulations, we assume that input networks are <strong>NetworkX</strong> 
graphs; see <a class="reference external" href="https://networkx.github.io/">https://networkx.github.io/</a></p>
<dl class="docutils">
<dt>This is a preliminary version of the code:</dt>
<dd><ul class="first last simple">
<li>The algorithms have not been tested in Python 3 (tested only in 2.7)</li>
<li>At present the ODE models are not fully tested.</li>
<li>Additional algorithms may be added beyond those in the book.</li>
</ul>
</dd>
</dl>
<p>Distributed under MIT license.  See license.txt for full details.</p>
<dl class="function">
<dt id="EoN.Attack_rate_cts_time">
<code class="descclassname">EoN.</code><code class="descname">Attack_rate_cts_time</code><span class="sig-paren">(</span><em>Pk</em>, <em>tau</em>, <em>gamma</em>, <em>number_its=100</em>, <em>rho=None</em>, <em>Sk0=None</em>, <em>phiS0=None</em>, <em>phiR0=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Attack_rate_cts_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Attack_rate_cts_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (6.7) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This system predicts the fraction of nodes infected if an epidemic 
occurs in a Configuration Model network assuming a continuous-time 
Markovian SIR disease.</p>
<p>This gives the limit of the attack rate of epidemics as the initial 
fraction infected approaches 0.</p>
<p>If we look for the limit of a nonzero initial fraction infected, we 
introduce rho or Sk0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Pk : dict</p>
<p>the probability a randomly selected node has degree k.</p>
<p>tau : number
per-edge transmission rate.</p>
<p>gamma : number
per-node recovery rate</p>
<p>number_its : int
The solution is found iteratively, so this determines 
the number of iterations.</p>
<p>rho : number, optional
The initial proportion infected (defaults to None)</p>
<p>Sk0 : dict (default None)
only one of rho and Sk0 can be defined.  
The other (or both) should remain None.
rho gives the fraction of nodes randomly infected.
Sk0 is a dict such that Sk0[k] is the probability that a 
degree k node is susceptible at start.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>the predicted fraction infected.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.Attack_rate_cts_time_from_graph">
<code class="descclassname">EoN.</code><code class="descname">Attack_rate_cts_time_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>number_its=100</em>, <em>rho=None</em>, <em>Sk0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Attack_rate_cts_time_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Attack_rate_cts_time_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a graph, predicts the attack rate for Configuration Model 
networks with the given degree distribution.  This does not account 
for any structure in G beyond degree distribution.</p>
<p>First calculates the degree distribution and then calls 
Attack_rate_cts_time.</p>
<p>SEE ALSO
estimate_SIR_prob_size(G, p) - accounts for entire structure of G</p>
</dd></dl>

<dl class="function">
<dt id="EoN.Attack_rate_discrete">
<code class="descclassname">EoN.</code><code class="descname">Attack_rate_discrete</code><span class="sig-paren">(</span><em>Pk</em>, <em>p</em>, <em>number_its=100</em>, <em>rho=None</em>, <em>Sk0=None</em>, <em>phiS0=None</em>, <em>phiR0=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Attack_rate_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Attack_rate_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes systems (6.6) and (6.10) of Kiss, Miller, &amp; Simon.  Please 
cite the book if using this algorithm.</p>
<p>To use system (6.6), leave rho and Sk0 as None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Pk <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Pk[k] is the probability a randomly selected node has degree k.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per-edge transmission rate.</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per-node recovery rate</dd>
<dt>number_its <span class="classifier-delimiter">:</span> <span class="classifier">The solution is found iteratively, so this determines </span></dt>
<dd>the number of iterations.</dd>
</dl>
<p>rho : Number (default None)
Sk0 : dict (default None)</p>
<blockquote>
<div><p>only one of rho and Sk0 can be defined.  
The other (or both) should remain None.
rho gives the fraction of nodes randomly infected.
Sk0 is a dict such that Sk0[k] is the probability that a</p>
<blockquote>
<div>degree k node is susceptible at start.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>phiS0 <span class="classifier-delimiter">:</span> <span class="classifier">number (default None)</span></dt>
<dd>Should only be used if Sk0 is not None.  
If it is None, then assumes that initial introduction is 
randomly introduced</dd>
<dt>phiR0 <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>As with phiS0, only used if Sk0 is not None.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>A <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>the predicted fraction infected.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.Attack_rate_non_Markovian">
<code class="descclassname">EoN.</code><code class="descname">Attack_rate_non_Markovian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Attack_rate_non_Markovian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Attack_rate_non_Markovian" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (6.8) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM">
<code class="descclassname">EoN.</code><code class="descname">EBCM</code><span class="sig-paren">(</span><em>N</em>, <em>psihat</em>, <em>psihatPrime</em>, <em>tau</em>, <em>gamma</em>, <em>phiS0</em>, <em>phiR0=0</em>, <em>R0=0</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (6.12) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>note : R0 is R(0), not the reproductive number</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>size of population</dd>
<dt>psihat <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihat(x) = sum_k S(k,0) x^k</dd>
<dt>psihatPrime <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per edge transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per node recovery rate</dd>
<dt>phiS0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of edges (of susceptible nodes) 
connecting to susceptible nodes</dd>
<dt>phiR0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of edges (of susceptible nodes) 
connecting to recovered nodes</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of recovered nodes at time 0</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>start time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>stop time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>number of distinct times to calculate</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>if False, </dt>
<dd>return t, S, I, R</dd>
<dt>if True </dt>
<dd>return t, S, I, R, and theta</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data == False:</dt>
<dd>returns t, S, I, R, all scipy arrays</dd>
<dt>if ...== True</dt>
<dd>returns t, S, I, R and theta, all scipy arrays</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_deg_corr">
<code class="descclassname">EoN.</code><code class="descname">EBCM_deg_corr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_deg_corr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_deg_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Nothing to see here 
- just a place holder until this code is written</p>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_deg_corr_discrete">
<code class="descclassname">EoN.</code><code class="descname">EBCM_deg_corr_discrete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_deg_corr_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_deg_corr_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Nothing to see here 
- just a place holder until this code is written</p>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_deg_corr_discrete_from_graph">
<code class="descclassname">EoN.</code><code class="descname">EBCM_deg_corr_discrete_from_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_deg_corr_discrete_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_deg_corr_discrete_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Nothing to see here 
- just a place holder until this code is written</p>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_deg_corr_from_graph">
<code class="descclassname">EoN.</code><code class="descname">EBCM_deg_corr_from_graph</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_deg_corr_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_deg_corr_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Nothing to see here 
- just a place holder until this code is written</p>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_discrete">
<code class="descclassname">EoN.</code><code class="descname">EBCM_discrete</code><span class="sig-paren">(</span><em>N</em>, <em>psihat</em>, <em>psihatPrime</em>, <em>p</em>, <em>phiS0</em>, <em>phiR0=0</em>, <em>R0=0</em>, <em>tmax=100</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (6.11) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<dl class="docutils">
<dt>theta(t) = (1-p) + p(phi_R(0) </dt>
<dd><ul class="first last simple">
<li>phi_S(0) psihatPrime(theta(t-1))/psihatPrime(1))</li>
</ul>
</dd>
</dl>
<p>R(t) = R(t-1) + I(t-1)
S(t) = N psihat(theta(t))
I(t) = N-S-R</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>size of population</dd>
<dt>psihat <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihat(x) = sum_k S(k,0) x^k</dd>
<dt>psihatPrime <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per edge transmission probability</dd>
<dt>phiS0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of edges (of susceptible nodes) 
connecting to susceptible nodes</dd>
<dt>phiR0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of edges (of susceptible nodes) 
connecting to recovered nodes</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of recovered nodes at time 0</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>maximum time</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>if False, </dt>
<dd>return t, S, I, R</dd>
<dt>if True </dt>
<dd>return t, S, I, R, and theta</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data == False:</dt>
<dd>returns t, S, I, R, all scipy arrays</dd>
<dt>if ...== True</dt>
<dd>returns t, S, I, R and theta, all scipy arrays</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_discrete_from_graph">
<code class="descclassname">EoN.</code><code class="descname">EBCM_discrete_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>p</em>, <em>rho=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_discrete_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_discrete_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a given graph, finds the degree distribution 
(from which it gets psi),
assumes a constant proportion of the population is infected at time 
0, 
and then uses the discrete EBCM model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx Graph
p : number</p>
<blockquote>
<div>per edge transmission probability</div></blockquote>
<dl class="docutils">
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of infected nodes</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>maximum time</dd>
<dt>return_full-data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>if False, </dt>
<dd>return t, S, I, R and if True return t, S, I, R, and theta</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data == False:</dt>
<dd>returns t, S, I, R, all scipy arrays</dd>
<dt>if ...== True</dt>
<dd>returns t, S, I, R and theta, all scipy arrays</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_discrete_uniform_introduction">
<code class="descclassname">EoN.</code><code class="descname">EBCM_discrete_uniform_introduction</code><span class="sig-paren">(</span><em>N</em>, <em>psi</em>, <em>psiPrime</em>, <em>p</em>, <em>rho</em>, <em>tmax=100</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_discrete_uniform_introduction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_discrete_uniform_introduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the case that the disease is introduced uniformly as opposed
to depending on degree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">Number</span></dt>
<dd>number of nodes</dd>
<dt>psi <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psi(x) = sum P(k) x^k</dd>
<dt>psiPrime <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psiPrime(x)=d psi(x)/dx = sum kP(k) x^{k-1}</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per edge transmission probability</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion of infected nodes</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>maximum time</dd>
<dt>return_full-data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>if False, </dt>
<dd>return t, S, I, R</dd>
<dt>if True </dt>
<dd>return t, S, I, R, and theta</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data == False:</dt>
<dd>returns t, S, I, R, all scipy arrays</dd>
<dt>if ...== True</dt>
<dd>returns t, S, I, R and theta, all scipy arrays</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.EBCM_uniform_introduction">
<code class="descclassname">EoN.</code><code class="descname">EBCM_uniform_introduction</code><span class="sig-paren">(</span><em>N</em>, <em>psi</em>, <em>psiPrime</em>, <em>tau</em>, <em>gamma</em>, <em>rho</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#EBCM_uniform_introduction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EBCM_uniform_introduction" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the case that the disease is introduced uniformly as opposed
to depending on degree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>size of population</dd>
<dt>psi <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihat(x) = sum_k S(k,0) x^k</dd>
<dt>psiPrime <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>psihatPrime(x) = d psihat(x)/dx = sum_k k S(k,0) x^{k-1}</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per edge transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>per node recovery rate</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial proportion infected</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>start time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>stop time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>number of distinct times to calculate</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>if False,</dt>
<dd>return t, S, I, R</dd>
<dt>if True </dt>
<dd>return t, S, I, R, and theta</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data == False:</dt>
<dd>returns t, S, I, R, all scipy arrays</dd>
<dt>if ...== True</dt>
<dd>returns t, S, I, R and theta, all scipy arrays</dd>
</dl>
</dd></dl>

<dl class="exception">
<dt id="EoN.EoNError">
<em class="property">exception </em><code class="descclassname">EoN.</code><code class="descname">EoNError</code><a class="reference internal" href="_modules/EoN.html#EoNError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.EoNError" title="Permalink to this definition">¶</a></dt>
<dd><p>this will be the basic error type for EoN</p>
</dd></dl>

<dl class="function">
<dt id="EoN.Epi_Prob_cts_time">
<code class="descclassname">EoN.</code><code class="descname">Epi_Prob_cts_time</code><span class="sig-paren">(</span><em>Pk</em>, <em>tau</em>, <em>gamma</em>, <em>umin=0</em>, <em>umax=10</em>, <em>ucount=1001</em>, <em>number_its=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Epi_Prob_cts_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Epi_Prob_cts_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (6.3) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>The equations are rescaled by setting $u=gamma T$.  Then it becomes</p>
<p>P = 1- int_0^infty psi(alpha(u/gamma)) e^{-u} du
alpha_d(u/gamma) = 1- p(u/gamma)</p>
<blockquote>
<div><ul>
<li><p class="first">p(u/gamma)
int_0^infty</p>
<blockquote>
<div><p>(psiPrime(alpha(hat{u}/gamma))/&lt;K&gt;)
e^{-u}du</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>where p(u/gamma) = 1 - e^{-tau u/gamma}</p>
<dl class="docutils">
<dt>Define </dt>
<dd>hat{p}(u) = p(u/gamma), and hat{alpha}(u) = alpha(u/gamma)</dd>
</dl>
<p>and then drop hats to get</p>
<p>P = 1-int_0^infty psi(alpha(u)) e^{-u} du
alpha(u) = 1-p(u) + p(u)</p>
<blockquote>
<div><dl class="docutils">
<dt>int_0^infty </dt>
<dd>(psiPrime(alpha(u))/&lt;K&gt;)e^{-u} du</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>with initial guess </dt>
<dd>alpha_1(u) = e^{-tau u/gamma}</dd>
<dt>and </dt>
<dd>p(u) = 1-e^{-tau u/gamma}</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Pk : scipy array Pk[k] is probability a node has degree k.</p>
<p>tau : transmission rate</p>
<p>gamma : recovery rate</p>
<p>umin : minimal value of gamma T used in calculation
umax : maximum value of gamma T used in calculation
ucount : number of points taken for integral.</p>
<blockquote>
<div>So this integrates from umin to umax using simple Riemann 
sum.</div></blockquote>
<dl class="docutils">
<dt>number_its <span class="classifier-delimiter">:</span> <span class="classifier">number of iterations before assumed converged.</span></dt>
<dd>default value is 100</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Calculated Epidemic probability (assuming configuration model)</p>
</dd></dl>

<dl class="function">
<dt id="EoN.Epi_Prob_discrete">
<code class="descclassname">EoN.</code><code class="descname">Epi_Prob_discrete</code><span class="sig-paren">(</span><em>Pk</em>, <em>p</em>, <em>number_its=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Epi_Prob_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Epi_Prob_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (6.2) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Pk : scipy array Pk[k] is probability a node has degree k.</p>
<p>p : transmission probability</p>
<dl class="docutils">
<dt>number_its <span class="classifier-delimiter">:</span> <span class="classifier">number of iterations before assumed converged.</span></dt>
<dd>default value is 100</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Calculated Epidemic probability (assuming configuration model)</p>
</dd></dl>

<dl class="function">
<dt id="EoN.Epi_Prob_non_Markovian">
<code class="descclassname">EoN.</code><code class="descname">Epi_Prob_non_Markovian</code><span class="sig-paren">(</span><em>Pk</em>, <em>tau</em>, <em>gamma</em>, <em>Pxidxi</em>, <em>po</em>, <em>umin=0</em>, <em>umax=10</em>, <em>ucount=1001</em>, <em>number_its=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Epi_Prob_non_Markovian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Epi_Prob_non_Markovian" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (6.5) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Pk : scipy array Pk[k] is probability a node has degree k.</p>
<p>tau : transmission rate</p>
<p>gamma : recovery rate</p>
<dl class="docutils">
<dt>Pxidxi <span class="classifier-delimiter">:</span> <span class="classifier">a dict.  Returns P(xi)dxi for user-selected xi.  The </span></dt>
<dd>algorithm will replace the integral with
sum_{xi in Pxidxi.keys()} psi(alpha(xi)) Pxidxi(xi)</dd>
<dt>po <span class="classifier-delimiter">:</span> <span class="classifier">a function.</span></dt>
<dd>returns p_o(xi), the probability a node will transmit to a 
random neighbor given xi.</dd>
</dl>
<p>umin : minimal value of gamma T used in calculation
umax : maximum value of gamma T used in calculation
ucount : number of points taken for integral.</p>
<blockquote>
<div>So this integrates from umin to umax using simple Riemann 
sum.</div></blockquote>
<dl class="docutils">
<dt>number_its <span class="classifier-delimiter">:</span> <span class="classifier">number of iterations before assumed converged.</span></dt>
<dd>default value is 100</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Calculated Epidemic probability (assuming configuration model)</p>
</dd></dl>

<dl class="class">
<dt id="EoN.Event">
<em class="property">class </em><code class="descclassname">EoN.</code><code class="descname">Event</code><span class="sig-paren">(</span><em>time</em>, <em>function</em>, <em>args=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Event"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used in event-driven simulations (fast_SIR and 
fast_SIS) as an event which will be put into a priority queue.</p>
<p>It is sortable based on event time.</p>
<p>An event object consists of
self.time 
self.function
self.args</p>
<dl class="docutils">
<dt>When self.function is called, it is called by:</dt>
<dd>self.function(self.time, <a href="#id1"><span class="problematic" id="id2">*</span></a>self.args)</dd>
</dl>
<p>I wonder about whether it would be better to do this as a dict.</p>
<p>The ability to sort based on time is why I am leaving it as a class.</p>
</dd></dl>

<dl class="function">
<dt id="EoN.Gillespie_SIR">
<code class="descclassname">EoN.</code><code class="descname">Gillespie_SIR</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>initial_infecteds=None</em>, <em>rho=None</em>, <em>tmax=inf</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Gillespie_SIR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Gillespie_SIR" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure A.1 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>Assumes that the network is unweighted.</p>
<p>Thus the risks are quantized: equal to tau times the number of 
infected neighbors of a node.</p>
<p>This would not be as good if the edges were weighted, but we could 
put the at_risk nodes into bands.</p>
<p>The event-driven simulation is almost certainly faster in all cases, 
and the benefit would increase if the network were weighted.</p>
<p>At present, this does not accept recovery or transmission weights.
This is because including that will force us to sum up these weights
more frequently rather than just counting how many exist
which will slow the code down.  For weights, try fast_SIR</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SEE ALSO:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>fast_SIR which has the same inputs but uses a different method to 
run much faster</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The underlying network</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate per edge</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate per node</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then choose randomly based on rho.  If rho is also
None, a random single node is chosen.
If both initial_infecteds and rho are assigned, then there
is an error.</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial fraction infected. number is int(round(G.order()*rho))</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>stop time</dd>
<dt>return_full_data: boolean</dt>
<dd>Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts, infection_time and 
recovery_time.
infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>times, S, I, R <span class="classifier-delimiter">:</span> <span class="classifier">each a scipy array</span></dt>
<dd>giving times and number in each status for corresponding time</dd>
</dl>
<p>OR if return_full_data=True:
times, S, I, R, infection_time, recovery_time</p>
<blockquote>
<div>first four are scipy arrays as above.  New objects are dicts
with entries just for those nodes that were infected ever
infection_time[node] is time of infection
recovery_time[node] is time of recovery</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">fast_SIR</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                            <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_size</span><span class="p">))</span>
                            
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.Gillespie_SIS">
<code class="descclassname">EoN.</code><code class="descname">Gillespie_SIS</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>initial_infecteds=None</em>, <em>rho=None</em>, <em>tmax=100</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#Gillespie_SIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.Gillespie_SIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on figure A.1 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This could be made more efficient if we divide the at_risk nodes 
into groups based on how at risk they are.</p>
<p>This would not be as good if the edges were weighted, but we could 
put the at_risk nodes into bands.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">WARNING:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>self-edges will cause this to die.  
You can remove self-edges by G.remove_edges_from(G.selfloop_edges())</p>
<p>At present, this does not accept recovery or transmission weights.
This is because including that will force us to sum up these weights
more frequently rather than just counting how many exist
which will slow the code down.  For weights, try fast_SIS</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SEE ALSO:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>fast_SIS which has the same inputs but uses a much faster method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The underlying network</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate per edge</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate per node</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then choose randomly based on rho.  If rho is also
None, a random single node is chosen.
If both initial_infecteds and rho are assigned, then there
is an error.</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial fraction infected. number is int(round(G.order()*rho))</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>stop time</dd>
<dt>return_full_data: boolean</dt>
<dd>Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts, infection_time and 
recovery_time.
infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">Gillespie_SIS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                            <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_size</span><span class="p">))</span>
                        
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_compact_effective_degree">
<code class="descclassname">EoN.</code><code class="descname">SIR_compact_effective_degree</code><span class="sig-paren">(</span><em>Skappa0</em>, <em>I0</em>, <em>R0</em>, <em>SI0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_compact_effective_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_compact_effective_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.43) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<dl class="docutils">
<dt>dot{S}_kappa = &lt;I&gt; [-(tau+gamma) kappa S_kappa </dt>
<dd><ul class="first last simple">
<li>gamma(kappa+1)S_{kappa+1}</li>
</ul>
</dd>
<dt>[dot{SI}] = -(tau+gamma)[SI] </dt>
<dd><ul class="first last simple">
<li>tau(&lt;I&gt; - 2 &lt;I&gt;^2) sum_{kappa} kappa(kappa-1) S_kappa</li>
</ul>
</dd>
</dl>
<p>dot{R} = gamma I
&lt;I&gt; = [SI]/sum_kappa kappa S_kappa
S = sum_kappa S_kappa
I = N - S - R</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Skappa0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd><dl class="first last docutils">
<dt>from S_0(0) up to S_kappamax(0) of number susceptible with </dt>
<dd>each effective degree</dd>
<dt>Skappa = number of nodes that are susceptible and have </dt>
<dd>kappa non-recovered neighbors</dd>
</dl>
</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of infected individuals at time 0</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number recovered</dd>
<dt>SI0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number of SI edges</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
<p>times : scipy.array of times
S : scipy.array of number susceptible
I : scipy.array of number infected
R : scipy.array of number recovered</p>
<p>times : as before
Skappa : array of arrays, each subarray gives particular S_kappa
I : number infected
R : number recovered
SI : number of SI edges</p>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_compact_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIR_compact_pairwise</code><span class="sig-paren">(</span><em>Sk0</em>, <em>I0</em>, <em>R0</em>, <em>SS0</em>, <em>SI0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_compact_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_compact_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.19) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>[dot{S}_k] = -tau k [S_k] [SI]/[SX]
[dot{SS}] = -2 tau [SS] [SI] Q
[dot{SI}] = -gamma [SI] + tau([SS]-[SI])[SI]Q - tau [SI]
[dot{R} = gamma [I]
[SX] = sum_k k[S_k]
Q = (1/[SX]^2) sum_k (k-1) k [S_k]
[S] = sum [S_k]
I = N-[S]-R</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>initial number of suscetibles of each degree k</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number infected</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number recovered</dd>
<dt>SS0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number of SS edges</dd>
<dt>SI0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number of SI edges</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_effective_degree">
<code class="descclassname">EoN.</code><code class="descname">SIR_effective_degree</code><span class="sig-paren">(</span><em>S_si0</em>, <em>I0</em>, <em>R0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_effective_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_effective_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.38) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<dl class="docutils">
<dt>dot{S}_{s,i} = - tau i S_{s,i}  + gamma((i+1)S_{s,i+1} - i S_{s,i})</dt>
<dd><ul class="first last simple">
<li>tau [ISS]((s+1)S_{s+1,i-1} - sS_{s,i})/[SS]</li>
</ul>
</dd>
</dl>
<p>dot{R} = gamma I
S = sum_{s,i} S_{s,i}
I = N-S-R</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>S_si0 <span class="classifier-delimiter">:</span> <span class="classifier">(square) numpy 2-D array</span></dt>
<dd>S_{s,i} at time 0</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of infected individuals at time 0</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of recovered individuals at time 0</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_heterogeneous_meanfield">
<code class="descclassname">EoN.</code><code class="descname">SIR_heterogeneous_meanfield</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>Rk0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_heterogeneous_meanfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_heterogeneous_meanfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (5.11) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;heterogeneous mean-field model closed at the level of pairs&#8221;</p>
<p>Ik0 and Rk0 are similar to Sk0.</p>
<p>[S_k] = [S_k](0) theta^k
[I_k] = [N_k] - [S_k] - [R_k]
[dot{R}_k] = gamma [I_k]
pi_I = sum_k k[I_k]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>Sk0[k] is the number of
nodes that are susceptible and have degree k (even if some degrees 
missing).</dd>
</dl>
<p>Ik0 : array
Rk0 : array
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>times, S, I, R, Sk, Ik, Rk (the Xk are scipy 2D arrays)</dd>
<dt>if return_full_data is False:</dt>
<dd>times, S, I, R          (all scipy arrays)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">Sk0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">]</span>
<span class="n">Ik0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">Rk0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">Rk0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                                <span class="n">tmax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_heterogeneous_meanfield_from_graph">
<code class="descclassname">EoN.</code><code class="descname">SIR_heterogeneous_meanfield_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>rho=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_heterogeneous_meanfield_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_heterogeneous_meanfield_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a graph and an initial proportion infected rho.  
Calculates Sk0 and Ik0 and calls the heterogeneous meanfield model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx Graph
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number between 0 and 1  (default None)</span></dt>
<dd>the fraction to be randomly infected at time 0
If None, then rho=1/N is used where N = G.order()</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True</dt>
<dd>times, Sk, Ik, Rk (the Xk are scipy 2D arrays)</dd>
<dt>if False,</dt>
<dd>times, S, I, R (all scipy arrays)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_heterogeneous_meanfield_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                                        <span class="n">tmax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_heterogeneous_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIR_heterogeneous_pairwise</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>Rk0</em>, <em>SkSl0</em>, <em>SkIl0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em>, <em>Ks=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_heterogeneous_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_heterogeneous_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (5.15) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;heterogeneous mean-field model closed at the level of triples&#8221;</p>
<p>[dot{S}_k] = -tau [S_k I]
[dot{I}_k] = tau [S_k I] - gamma [I_k]
[dot{R}_k] = gamma [I_k]  (but using Rk=Nk-Sk-Ik for this equation)
[dot{S_kI_l}] = -gamma[S_k I_l] + tau([S_k S_l I] - [I S_k I_l]</p>
<blockquote>
<div><ul class="simple">
<li>[S_k I_l])</li>
</ul>
</div></blockquote>
<p>[dot{S_kS_l}] = -tau([S_k S_l I] + [I S_k S_l])</p>
<p>[A_l S_k I] = ((k-1)/k) [A_l S_k] [S_k I]/ [S_k]
[I S_k A_l] = ((k-1)/k) [I S_k] [S_k A_l]/ [S_k]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array, Sk0[k] is number of degree k susceptible at </span></dt>
<dd>time 0.</dd>
</dl>
<p>Ik0 : scipy array
Rk0 : scipy array
SkIl0 : scipy 2D array
SkSl0 : scipy 2D array</p>
<dl class="docutils">
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>If True, return times, Sk, Ik, Rk, SkIl, SkSl
If False, return times, S, I, R</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
<dt>Ks <span class="classifier-delimiter">:</span> <span class="classifier">scipy array. (default None)</span></dt>
<dd>(helps prevent memory errors) if some degrees are not
observed, then the corresponding entries of these arrays are
zero.  This can lead to memory errors in the case of a
network with many missing degrees.  So Ks is an (assumed)
ordered vector stating which Ks are actually observed.  Then
the Sk0[i] is the number of nodes that are susceptible and
have degree Ks[i].  Similarly for Ik0 and SkIl0 etc.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True</dt>
<dd>returns times, S, I, R, Sk, Ik, Rk, SkIl, SkSl</dd>
<dt>if return_full_data is False</dt>
<dd>return times, S, I, R</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_homogeneous_meanfield">
<code class="descclassname">EoN.</code><code class="descname">SIR_homogeneous_meanfield</code><span class="sig-paren">(</span><em>S0</em>, <em>I0</em>, <em>R0</em>, <em>n</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_homogeneous_meanfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_homogeneous_meanfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (4.9) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;mean-field model closed at the level of pairs&#8221;</p>
<p>[dot{S}] = - tau n[S][I]/N
[dot{I}] =         au n[S][I]/N - gamma [I]
[dot{R}] = gamma [I]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>S0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number susceptible</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number infected</dd>
<dt>R0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number recovered</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>degree of each node</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>times, S, I, R : all scipy arrays</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">S0</span> <span class="o">=</span> <span class="mi">999</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">#degree</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_homogeneous_meanfield</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_homogeneous_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIR_homogeneous_pairwise</code><span class="sig-paren">(</span><em>S0</em>, <em>I0</em>, <em>R0</em>, <em>SI0</em>, <em>SS0</em>, <em>n</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_homogeneous_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_homogeneous_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (4.11) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;mean-field model closed at the level of triples&#8221;</p>
<p>[dot{S}] = - tau [SI]
[dot{I}] =         au [SI] - gamma [I]
[dot{R}] = gamma [I]    ;    [R] = N-[S]-[I]
[dot{SI}] = -gamma [SI]+  au ((n-1)/n) [SI]([SS]-[SI])/[S]</p>
<blockquote>
<div><ul class="simple">
<li>au [SI]</li>
</ul>
</div></blockquote>
<p>[dot{SS}] = - 2    au ((n-1)/n) [SI][SS]/[S]</p>
<dl class="docutils">
<dt>conserved quantities: [S]+[I]+[R]  also </dt>
<dd>[SS]+[II]+[RR] + 2([SI] + [SR] + [IR])</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>S0 : Initial number suusceptible
I0 : Initial number infected
R0 : Initial number recovered
SI0 : Initial number of SI edges
SS0 : Initial number of SS edges
n : Degree of nodes
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.
if True, then returns times, S, I, R, SI, SS</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>times, S, I, R, SI, SS</dd>
<dt>if return_full_data is False:</dt>
<dd>times, S, I, R</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">S0</span> <span class="o">=</span> <span class="mi">990</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">R0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SI0</span> <span class="o">=</span> <span class="mi">45</span>
<span class="n">SS0</span> <span class="o">=</span> <span class="mi">4900</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                            <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_homogeneous_pairwise_from_graph">
<code class="descclassname">EoN.</code><code class="descname">SIR_homogeneous_pairwise_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>rho=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_homogeneous_pairwise_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_homogeneous_pairwise_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls SIS_homogeneous_pairwise with a graph, disease parameters, and
a random fraction rho initially infected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx Graph
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number (default 1/N)</span></dt>
<dd>initial fraction infected</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.
if True, then returns times, S, I, R, SI, SS</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>t, S, I, SI, SS, II</dd>
<dt>if return_full_data is False:</dt>
<dd>t, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mf">0.0005</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_homogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> 
                                                        <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_individual_based">
<code class="descclassname">EoN.</code><code class="descname">SIR_individual_based</code><span class="sig-paren">(</span><em>G</em>, <em>nodelist</em>, <em>X0</em>, <em>Y0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_individual_based"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_individual_based" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.30) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>See also:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx graph</p>
<dl class="docutils">
<dt>X0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial susceptibility probabilities</dd>
<dt>Y0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial infection probabilities</dd>
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in X0 and Y0</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number      (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer       (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data       (default False)</dt>
<dd>If True, returns times, S, I, R, Ss, Is, Rs
if False, returns times, S, I, R</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd><dl class="first last docutils">
<dt>returns times, Ss, Is, Rs</dt>
<dd>where times is a scipy array of times, Ss is a 2D scipy array
Ss[i,j] gives probability nodelist[i] is susceptible at time
times[j].
Similarly for Is ans Rs</dd>
</dl>
</dd>
<dt>if return_full data is False:</dt>
<dd><dl class="first last docutils">
<dt>returns times, S, I, R</dt>
<dd>all are scipy arrays.  gives times, and expected number 
susceptible, expected number infected, and expected number
recovered</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
<p>nodelist = G.nodes()
X = (1-rho)*scipy.ones(N)
Y = rho*scipy.ones(N)</p>
<p>t, S, I, R = EoN.SIR_individual_based(G, nodelist, X, Y, tau, gamma=gamma, tmax = 20)
plt.plot(t,I)</p>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_individual_based_pure_IC">
<code class="descclassname">EoN.</code><code class="descname">SIR_individual_based_pure_IC</code><span class="sig-paren">(</span><em>G</em>, <em>index_nodes</em>, <em>nodelist</em>, <em>tau</em>, <em>gamma</em>, <em>initial_susceptible=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_individual_based_pure_IC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_individual_based_pure_IC" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.30) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>The difference between this and SIR_individual_based is that this 
one assumes a &#8220;pure initial condition&#8221;, that is, we know exactly 
what the statuses of the nodes are at the initial time.</p>
<p>&lt;dot{Y}_i&gt; = tau sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx graph</p>
<dl class="docutils">
<dt>index_nodes <span class="classifier-delimiter">:</span> <span class="classifier">list or set</span></dt>
<dd>the set of nodes initially infected</dd>
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number      (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>initial_susceptible <span class="classifier-delimiter">:</span> <span class="classifier">list or set  (default None)</span></dt>
<dd>initially susceptible nodes
if equal to None, then all non-index nodes are initially 
susceptible.</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer       (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
</dl>
<p>return_full_data : boolean      (default False)</p>
<dl class="docutils">
<dt>if return_full_data is True,</dt>
<dd>returns times, S, I, R, Ss, Is, Rs</dd>
<dt>if return_full_data is False,</dt>
<dd>returns times, S, I, R</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_pair_based">
<code class="descclassname">EoN.</code><code class="descname">SIR_pair_based</code><span class="sig-paren">(</span><em>G</em>, <em>nodelist</em>, <em>Y0</em>, <em>tau</em>, <em>gamma</em>, <em>X0=None</em>, <em>XY0=None</em>, <em>XX0=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_pair_based"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_pair_based" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.39) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This system solves equations for an SIR disease model spreading on a
given graph.  It captures the dependence with pairs, but not 
triples.</p>
<p>It will be exact for a tree.</p>
<p>There are NO CORRECTIONS for the existence of TRIANGLES or any other
CYCLES.</p>
<p>Some corrections for triangles are provided in the text, but not 
implemented here.</p>
<p>See also:
Hadjichrysanthou and Sharkey
Epidemic control analysis: Desigining targeted intervention</p>
<blockquote>
<div>strategies against epidemics propagated on contact networks,</div></blockquote>
<p>Journal of Theoretical Biology</p>
<p>G : Networkx graph</p>
<dl class="docutils">
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>Y0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial infection probabilities for each node in 
order as in nodelist</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>X0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array (default None)</span></dt>
<dd>probability a random node is initially susceptible.
the probability of initially recovered will be 1-X0-Y0.  By 
default we assume no initial recoveries, so X0=1-Y0 will be 
assumed in this case.</dd>
<dt>XY0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd><p class="first">(each dimension has length number of nodes of G)
XY0[i,j] is probability node i is susceptible and j is</p>
<blockquote>
<div>infected.</div></blockquote>
<dl class="last docutils">
<dt>if None, then assumes that infections are introduced </dt>
<dd>randomly according to Y0.</dd>
</dl>
</dd>
<dt>XX0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd><p class="first">(each dimension has length number of nodes of G)
XX0[i,j] is probability nodes i and j are susceptible.
if None, then assumes that infections are introduced</p>
<blockquote class="last">
<div>randomly according to Y0.</div></blockquote>
</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean      (default False)</span></dt>
<dd><dl class="first last docutils">
<dt>if True:</dt>
<dd>returns times, S, I, R, Xs, Ys, Zs, XY, XX</dd>
<dt>if False:</dt>
<dd>returns times, S, I, R</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>returns times, S, I, R, Xs, Ys, Zs, XY, XX</dd>
<dt>if False:</dt>
<dd>returns times, S, I, R</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.004</span><span class="p">)</span>
<span class="n">nodelist</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="n">Y0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">node</span><span class="o">&lt;</span><span class="mi">10</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span> <span class="c1">#infect first 10</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIR_pair_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_pair_based2">
<code class="descclassname">EoN.</code><code class="descname">SIR_pair_based2</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>rho=None</em>, <em>nodelist=None</em>, <em>X0=None</em>, <em>Y0=None</em>, <em>edgelist=None</em>, <em>XY0=None</em>, <em>YX0=None</em>, <em>XX0=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_pair_based2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_pair_based2" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Encodes System (3.39) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This system solves equations for an SIR disease model spreading on a 
given graph.  It captures the dependence with pairs, but not 
triples.</p>
<p>It will be exact for a tree.</p>
<p>There are NO CORRECTIONS for the existence of TRIANGLES or any other 
CYCLES.</p>
<p>Some corrections for triangles are provided in the text, but not 
implemented here.</p>
<p>See also:
Hadjichrysanthou and Sharkey
Epidemic control analysis: Desigining targeted intervention 
strategies against epidemics propagated on contact networks,
Journal of Theoretical Biology</p>
<p>&lt;dot{Y}_i&gt; = tau sum_j g_{ij} &lt;XY&gt;&gt;  -  gamma_i &lt;Y_i&gt;
&lt;dot{XY}&gt; = tau sum_{k</p>
</div></blockquote>
<dl class="docutils">
<dt>eq i} g_{jk} &lt;XX&gt;&lt;XjYk&gt;/&lt;Xj&gt;</dt>
<dd><blockquote class="first">
<div><ul class="simple">
<li>tau sum_{k neq j} g_{ik} &lt;YkXi&gt;&lt;XY&gt;/&lt;Xi&gt;</li>
<li>tau g_{ij}&lt;XY&gt; - gamma_j &lt;XIYj&gt;</li>
</ul>
</div></blockquote>
<p>&lt;dot{XX}&gt; = 
&lt;&gt;
The equations as coded involve all pairs rather than just the pairs 
that are in edges.</p>
<p>Those that are not part of an edge are set to zero and their 
derivatives are zero.</p>
<p>So the code could run faster, but I think for most cases this is a 
small contribution.</p>
<p>Before I forced the initial conditions for these nonedges to be 0, 
they caused quite a bit of numerical headaches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx graph</p>
<dl class="last docutils">
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>Y0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial infection probabilities for each node in 
order as in nodelist</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>XY0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd><p class="first">(each dimension has length number of nodes of G)
XY0[i,j] is probability node i is susceptible and j is 
infected.
if None, then assumes that infections are introduced</p>
<blockquote class="last">
<div>randomly according to Y0.</div></blockquote>
</dd>
<dt>XX0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd><p class="first">(each dimension has length number of nodes of G)
XX0[i,j] is probability nodes i and j are susceptible.
if None, then assumes that infections are introduced</p>
<blockquote class="last">
<div>randomly according to Y0.</div></blockquote>
</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean      (default False)</span></dt>
<dd><dl class="first last docutils">
<dt>if True:</dt>
<dd>returns times, S, I, R, Xs, Ys, Zs, XY, XX</dd>
<dt>if False:</dt>
<dd>returns times, S, I, R</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.SIR_super_compact_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIR_super_compact_pairwise</code><span class="sig-paren">(</span><em>SS0</em>, <em>SI0</em>, <em>R0</em>, <em>N</em>, <em>tau</em>, <em>gamma</em>, <em>psihat</em>, <em>psihatPrime</em>, <em>psihatDPrime</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIR_super_compact_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIR_super_compact_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.22) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>dot{theta} = -tau [SI]/N*psihat(theta)
[dot{SS}] = -2 tau [SS] [SI] Q
[dot{SI}] = -gamma[SI] + tau([SS]-[SI])[SI]Q - tau*[SI]
[dot{R}] = gamma*[I]
[S] = N psihat(theta)
[I] = N-[S]-[R]
Q = psihat_xx(theta)/N(psihat_x(theta))^2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or all 
calculated data.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_compact_effective_degree">
<code class="descclassname">EoN.</code><code class="descname">SIS_compact_effective_degree</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>SI0</em>, <em>SS0</em>, <em>II0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_compact_effective_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_compact_effective_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.44) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This model is identical to the SIS compact pairwise model, so it 
simply calls SIS_compact_pairwise()</p>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_compact_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIS_compact_pairwise</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>SI0</em>, <em>SS0</em>, <em>II0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_compact_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_compact_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.18) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>[dot{S}_k] = gamma[I_k] - tau k [S_k] [SI]/[SX]
[dot{I}_k] = tau * k <a href="#id3"><span class="problematic" id="id4">*</span></a>[S_k] [SI]/SX - gamma [I_k] = -[dot{S}_k]
[dot{SI}] = gamma([II]-[SI]) + tau([SS]-[SI])[SI]Q - tau[SI]
[dot{SS}] = 2 gamma[SI] - 2 tau [SS] [SI] Q
[dot{II}] = 2 tau[SI] = 2 gamma[II] + 2 tau[SI]^2Q
[SX] = sum_k k [S_k]
Q = (1/[SX]^2) sum_k (k-1)k[S_k]</p>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>number susceptible for each k</dd>
<dt>Ik0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>number infected for each k</dd>
<dt>SI0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of SI edges</dd>
<dt>SS0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of SS edges</dd>
<dt>II0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>number of II edges</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>if True, return times, S, I, Sk, Ik, SI, SS, II
if False,  return times, S, I</dd>
</dl>
<p>conserved quantities:  [Sk]+[Ik]     ;     SS + II + 2SI</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_effective_degree">
<code class="descclassname">EoN.</code><code class="descname">SIS_effective_degree</code><span class="sig-paren">(</span><em>Ssi0</em>, <em>Isi0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_effective_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_effective_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.36) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Ssi0 and Isi0 <span class="classifier-delimiter">:</span> <span class="classifier">(square) numpy 2D arrays of same shape.</span></dt>
<dd>Entries are initial number susceptible or infected 
with given initial number of susceptible/infected 
neighbors.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd><p class="first">tells whether to just return times, S, I, R or 
all calculated data.
if True,</p>
<blockquote>
<div>return times, S, I, Ssi, Isi</div></blockquote>
<dl class="last docutils">
<dt>if False, </dt>
<dd>return times, S, I</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_heterogeneous_meanfield">
<code class="descclassname">EoN.</code><code class="descname">SIS_heterogeneous_meanfield</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_heterogeneous_meanfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_heterogeneous_meanfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (5.10) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;heterogeneous mean-field model closed at the level of pairs&#8221;</p>
<p>a few notes on the inputs:
Sk0 is an array (or a list).</p>
<p>It is not a dict.</p>
<p>Sk0[k] is the <em>number</em> of nodes that are susceptible and have degree 
k (even if some degrees missing).</p>
<p>A dict like this can be converted into an array by
Sk0 = scipy.array([Sk0dict.get(k,0)</p>
<blockquote>
<div>for k in xrange(max(Sk0dict.keys())+1)])</div></blockquote>
<p>Ik0 is similar to Sk0.</p>
<p>[dot{S}_k] = gamma [I_k] -        au k [S_k] pi_I
[dot{I}_k] = -(above)
pi_I = sum_k k [I_k] / sum_k  k [N_k]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>number susceptible for each k</dd>
<dt>Ik0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>number infected for each k</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>tells whether to just return times, S, I or all 
calculated data.
if True, returns t, S, I, Sk, Ik</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>times, S, I, Sk  (Sk is scipy 2D arrays)</dd>
<dt>if return_full_data is False:</dt>
<dd>times, S, I      (all scipy arrays)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">Sk0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">,</span> <span class="mi">995</span><span class="p">]</span>
<span class="n">Ik0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_heterogeneous_meanfield</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_heterogeneous_meanfield_from_graph">
<code class="descclassname">EoN.</code><code class="descname">SIS_heterogeneous_meanfield_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>rho=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_heterogeneous_meanfield_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_heterogeneous_meanfield_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a graph and an initial proportion infected rho.  
Calculates Sk0 and Ik0 and calls the heterogeneous meanfield model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx Graph
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number between 0 and 1  (default None)</span></dt>
<dd>the fraction to be randomly infected at time 0
If None, then rho=1/N is used where N = G.order()</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or 
all calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>times, S, I, Sk, Ik, (the Xk are scipy 2D arrays)</dd>
<dt>if return_full_data is False:</dt>
<dd>times, S, I         (all scipy arrays)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_heterogeneous_meanfield_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                                        <span class="n">tmax</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_heterogeneous_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIS_heterogeneous_pairwise</code><span class="sig-paren">(</span><em>Sk0</em>, <em>Ik0</em>, <em>SkSl0</em>, <em>SkIl0</em>, <em>IkIl0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em>, <em>Ks=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_heterogeneous_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_heterogeneous_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (5.13) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;heterogeneous mean-field model closed at the level of triples&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">array.  Sk0[k] is the number of</span></dt>
<dd><p class="first">nodes that are susceptible and have degree k.  If one 
is empty, it becomes 0.
(if Ks is defined, the definition changes slightly, see</p>
<blockquote class="last">
<div>below)</div></blockquote>
</dd>
<dt>Ik0 <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><blockquote class="first">
<div>similar to Sk0, but for infected.</div></blockquote>
<p class="last">(if Ks is defined, the definition changes slightly, see below)</p>
</dd>
<dt>SkSl0, SkIl0, and IkIl0 <span class="classifier-delimiter">:</span> <span class="classifier">2D arrays</span></dt>
<dd><dl class="first last docutils">
<dt>SkIl0[k][l] is [S_kI_l]</dt>
<dd><p class="first">see below for constraints these should satisfy related to 
Sk0 and Ik0.  
The code does not enforce these constraints.
(if Ks is defined, the definition changes slightly,</p>
<blockquote class="last">
<div>see below)</div></blockquote>
</dd>
</dl>
</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>If True, return times, Sk, Ik, SkIl, SkSl, IkIl
If False, return times, S, I</dd>
<dt>Ks <span class="classifier-delimiter">:</span> <span class="classifier">scipy array. (default None)</span></dt>
<dd>(helps prevent memory errors) if some degrees are not
observed, then the corresponding entries of these arrays are
zero.  This can lead to memory errors in the case of a
network with many missing degrees.  So Ks is an (assumed)
ordered vector stating which Ks are actually observed.  Then
the Sk0[i] is the number of nodes that are susceptible and
have degree Ks[i].  Similarly for Ik0 and SkIl0 etc.</dd>
</dl>
<p>In principle, there are constraints relating Sk with SkSl and SkIl 
and similarly relating Ik with IkIl and SkIl.T.</p>
<p>No attempt is made to enforce these.</p>
<p>It is assumed the user will ensure acceptible inputs.</p>
<p>We could also remove Sk0 and Ik0 as inputs and infer them from the 
others, but for consistency with elsewhere, this is not done here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>returns times, S, I, Sk, Ik, SkIl, SkSl, IkIl</dd>
<dt>if return_full_data is False:</dt>
<dd>returns times, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="n">Sk0</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Ik0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Ik0</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">SkSl0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">294</span><span class="p">]])</span>
<span class="c1">#only interact within a degree class, so the deg 1 and 2 are safe.</span>
<span class="n">SkIl0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">SkIl0</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">IkIl0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_heterogeneous_pairwise</span><span class="p">(</span><span class="n">Sk0</span><span class="p">,</span> <span class="n">Ik0</span><span class="p">,</span> <span class="n">SkSl0</span><span class="p">,</span> <span class="n">SkIl0</span><span class="p">,</span> <span class="n">IkIl0</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> 
                                            <span class="n">gamma</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_homogeneous_meanfield">
<code class="descclassname">EoN.</code><code class="descname">SIS_homogeneous_meanfield</code><span class="sig-paren">(</span><em>S0</em>, <em>I0</em>, <em>n</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_homogeneous_meanfield"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_homogeneous_meanfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (4.8) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;mean-field model closed at the level of pairs&#8221;</p>
<p>[dot{S}] = gamma [I] - tau n[S][I]/N
[dot{I}] =         au n[S][I]/N - gamma [I]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>S0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number susceptible</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number infected</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>degree of all nodes.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>times, S, I, all scipy arrays</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">S0</span> <span class="o">=</span> <span class="mi">999</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">#degree</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_homogeneous_meanfield</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_homogeneous_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIS_homogeneous_pairwise</code><span class="sig-paren">(</span><em>S0</em>, <em>I0</em>, <em>SI0</em>, <em>SS0</em>, <em>n</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_homogeneous_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_homogeneous_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (4.10) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>In the text this is often referred to as the 
&#8220;mean-field model closed at the level of triples&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>S0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number susceptible</dd>
<dt>I0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number infected</dd>
<dt>SI0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number of SI edges</dd>
<dt>SS0 <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial number of SS edges</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd>(common) degree of nodes.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I or 
all calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>t, S, I, SI, SS, II</dd>
<dt>if return_full_data is False:</dt>
<dd>t, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">S0</span> <span class="o">=</span> <span class="mi">990</span>
<span class="n">I0</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">SI0</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">SS0</span> <span class="o">=</span> <span class="mi">4900</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_homogeneous_pairwise</span><span class="p">(</span><span class="n">S0</span><span class="p">,</span> <span class="n">I0</span><span class="p">,</span> <span class="n">SI0</span><span class="p">,</span> <span class="n">SS0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                                        <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_homogeneous_pairwise_from_graph">
<code class="descclassname">EoN.</code><code class="descname">SIS_homogeneous_pairwise_from_graph</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>rho=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_homogeneous_pairwise_from_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_homogeneous_pairwise_from_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls SIS_homogeneous_pairwise with a graph, disease parameters, and
a random fraction rho initially infected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx Graph
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number (default 1/N)</span></dt>
<dd>initial fraction infected</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean (default False)</span></dt>
<dd>tells whether to just return times, S, I, or 
all calculated data.
if True, then returns times, S, I, SI, SS</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>t, S, I, SI, SS, II</dd>
<dt>if return_full_data is False:</dt>
<dd>t, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mf">0.0005</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_homogeneous_pairwise_from_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_individual_based">
<code class="descclassname">EoN.</code><code class="descname">SIS_individual_based</code><span class="sig-paren">(</span><em>G</em>, <em>nodelist</em>, <em>Y0</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_individual_based"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_individual_based" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.7) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>See also:
Hadjichrysanthou and Sharkey
Epidemic control analysis: Desigining targeted intervention</p>
<blockquote>
<div>strategies against epidemics propagated on contact networks,</div></blockquote>
<p>Journal of Theoretical Biology</p>
<p>&lt;dot{Y}_i&gt; = tau sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx graph</p>
<dl class="docutils">
<dt>Y0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial infection probabilities</dd>
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number </span></dt>
<dd>global recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer       (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data       (default False)</dt>
<dd>If True, returns times, Ss, Is
if False, returns times, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd><dl class="first last docutils">
<dt>returns times, Ss, Is</dt>
<dd>where times is a scipy array of times, Ss is a 2D scipy array
Ss[i,j] gives probability nodelist[i] is susceptible at time
times[j].
Similarly for Is.</dd>
</dl>
</dd>
<dt>if return_full data is False:</dt>
<dd><dl class="first last docutils">
<dt>returns times, S, I</dt>
<dd>all are scipy arrays.  gives times, and expected number 
susceptible and expected number infected.</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span> <span class="k">as</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">nodelist</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">N</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
            <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_individual_based_pure_IC">
<code class="descclassname">EoN.</code><code class="descname">SIS_individual_based_pure_IC</code><span class="sig-paren">(</span><em>G</em>, <em>index_nodes</em>, <em>nodelist</em>, <em>tau</em>, <em>gamma</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_individual_based_pure_IC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_individual_based_pure_IC" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.7) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>The difference between this and SIS_individual_based is that this 
one assumes a &#8220;pure initial condition&#8221;, that is, we know exactly 
what the statuses of the nodes are at the initial time.</p>
<p>&lt;dot{Y}_i&gt; = tau sum_j g_{ij} (1-&lt;Y_i&gt;)&lt;Y_j&gt;  -  gamma_i &lt;Y_i&gt;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx graph
index_nodes : list or set</p>
<blockquote>
<div>the set of nodes initially infected</div></blockquote>
<dl class="docutils">
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number      (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number       (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer       (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
</dl>
<p>return_full_data : boolean      (default False)</p>
<blockquote>
<div><dl class="docutils">
<dt>if return_full_data is True,</dt>
<dd>returns times, Ss, Is</dd>
<dt>if return_full_data is False,</dt>
<dd>returns times, S, I</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">nodelist</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="n">index_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_individual_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">index_nodes</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span>  
            <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_pair_based">
<code class="descclassname">EoN.</code><code class="descname">SIS_pair_based</code><span class="sig-paren">(</span><em>G</em>, <em>nodelist</em>, <em>Y0</em>, <em>tau</em>, <em>gamma</em>, <em>XY0=None</em>, <em>XX0=None</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_pair_based"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_pair_based" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes System (3.26) of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This system solves equations for an SIS disease model spreading on a 
given graph.</p>
<p>It captures the dependence with pairs, but not triples.</p>
<p>It does not include corrections for triangles (or any other cycles).</p>
<p>The corrections for triangles are provided in the text, but not 
implemented here.</p>
<dl class="docutils">
<dt>There are some inefficiencies in the implementation:</dt>
<dd><p class="first">we track all pairs, rather than just those pairs in edges, but 
this is unlikely to significantly affect the calculation time.</p>
<p>This makes it much easier to vectorize things.</p>
<p class="last">We track pairs in both directions: e.g., XX[1,2] and XX[2,1].</p>
</dd>
</dl>
<p>G : Networkx graph</p>
<dl class="docutils">
<dt>nodelist <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of nodes in G in the same order as in Y0</dd>
<dt>Y0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>the array of initial infection probabilities for each node in 
order as in nodelist</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate of disease</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number (default None)</span></dt>
<dd>global recovery rate</dd>
<dt>XY0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd>(each dimension has length number of nodes of G)
XY0[i,j] is probability node i is susceptible and j is 
infected.
if None, then assumes that infections are introduced 
randomly according to Y0.</dd>
<dt>XX0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array (default None)</span></dt>
<dd>(each dimension has length number of nodes of G)
XX0[i,j] is probability nodes i and j are susceptible.
if None, then assumes that infections are introduced 
randomly according to Y0.</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>the label for a weight given to the edges.
G.edge[i][j][transmission_weight] = g_{ij}</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean      (default False)</span></dt>
<dd><dl class="first last docutils">
<dt>if True:</dt>
<dd>returns times, S, I, R, Xs, Ys, Zs, XY, XX</dd>
<dt>if False:</dt>
<dd>returns times, S, I, R</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True:</dt>
<dd>returns times, S, I, Xs, Ys, XY, XX</dd>
<dt>if False:</dt>
<dd>returns times, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.004</span><span class="p">)</span>
<span class="n">nodelist</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
<span class="n">Y0</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">node</span><span class="o">&lt;</span><span class="mi">10</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span> <span class="c1">#infect first 10</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">SIS_pair_based</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">,</span> <span class="n">Y0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">tcount</span> <span class="o">=</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.SIS_super_compact_pairwise">
<code class="descclassname">EoN.</code><code class="descname">SIS_super_compact_pairwise</code><span class="sig-paren">(</span><em>S0</em>, <em>I0</em>, <em>SS0</em>, <em>SI0</em>, <em>II0</em>, <em>tau</em>, <em>gamma</em>, <em>k_ave</em>, <em>ksquare_ave</em>, <em>kcube_ave</em>, <em>tmin=0</em>, <em>tmax=100</em>, <em>tcount=1001</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#SIS_super_compact_pairwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.SIS_super_compact_pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes system (5.20) of Kiss, Miller, &amp; Simon.  Please cite the 
book if using this algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>S0 : 
I0 :
SS0 :
SI0 :  
II0 : 
tau : number</p>
<blockquote>
<div>transmission rate</div></blockquote>
<dl class="docutils">
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>k_ave <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>average value of k</dd>
<dt>ksquare_ave <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>average value of k**2</dd>
<dt>kcube_ave <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>average value of k**3</dd>
<dt>tmin <span class="classifier-delimiter">:</span> <span class="classifier">number (default 0)</span></dt>
<dd>minimum report time</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number (default 100)</span></dt>
<dd>maximum report time</dd>
<dt>tcount <span class="classifier-delimiter">:</span> <span class="classifier">integer (default 1001)</span></dt>
<dd>number of reports</dd>
<dt>return_full_data <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>tells whether to just return times, S, I, R or all 
calculated data.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is True</dt>
<dd>returns times, S, I, SS, SI, II</dd>
<dt>if return_full_data is False</dt>
<dd>returns times, S, I</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>import networkx as nx
import EoN</p>
</dd></dl>

<dl class="function">
<dt id="EoN.basic_discrete_SIR_epidemic">
<code class="descclassname">EoN.</code><code class="descname">basic_discrete_SIR_epidemic</code><span class="sig-paren">(</span><em>G</em>, <em>p</em>, <em>initial_infecteds=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#basic_discrete_SIR_epidemic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.basic_discrete_SIR_epidemic" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.8 of Kiss, Miller, &amp; Simon.  Please cite the book if 
using this algorithm.</p>
<p>Does a simulation of the simple case of all nodes transmitting
with probability p independently to each neighbor and then
recovering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission probability</dd>
<dt>initial_infecteds: node or iterable of nodes  (default None)</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then a randomly chosen node is initially infected.</dd>
<dt>return_full_data: boolean (default False)</dt>
<dd><p class="first">Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts,</p>
<blockquote>
<div>infection_time and recovery_time</div></blockquote>
<p class="last">infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is False:</dt>
<dd>the scipy arrays: t, S, I, R</dd>
<dt>else:</dt>
<dd>the scipy arrays: t, S, I, R 
and the dicts infection_time and recovery_time</dd>
</dl>
<p>these scipy arrays give all the times observed and the number in 
each state at each time.  The dicts give times at which each node 
changed status.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">basic_discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p>This sample may be boring if the randomly chosen initial infection
doesn&#8217;t trigger an epidemic.</p>
</dd></dl>

<dl class="function">
<dt id="EoN.directed_percolate_network">
<code class="descclassname">EoN.</code><code class="descname">directed_percolate_network</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#directed_percolate_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.directed_percolate_network" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.13 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>This adds node and edge attributes in the percolated network which 
are not at present in the figure in the book.</p>
<p>This option is discussed in the text.</p>
<p>This performs directed percolation corresponding to an SIR epidemic
assuming that transmission is at rate tau and recovery at rate 
gamma</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SEE ALSO:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>nonMarkov_directed_percolate_network which allows for more complex
transmission and recovery rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">networkx DiGraph  (directed graph)</span></dt>
<dd><p class="first">a u-&gt;v edge exists in H if u would transmit to v if ever 
infected.</p>
<p>The edge has a time attribute (time_to_infect) which gives the 
delay from infection of u until transmission occurs.</p>
<p class="last">Each node u has a time attribute (duration) which gives the 
duration of its infectious period.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">directed_percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.discrete_SIR_epidemic">
<code class="descclassname">EoN.</code><code class="descname">discrete_SIR_epidemic</code><span class="sig-paren">(</span><em>G</em>, <em>test_transmission=&lt;function _simple_test_transmission_&gt;</em>, <em>args=()</em>, <em>initial_infecteds=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#discrete_SIR_epidemic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.discrete_SIR_epidemic" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.8 of Kiss, Miller, &amp; Simon.  Please cite the book
if using this algorithm.</p>
<p>Return details of epidemic curve from a discrete time simulation.</p>
<p>It assumes that individuals are infected for exactly one unit of 
time and then recover with immunity.</p>
<dl class="docutils">
<dt>This is defined to handle a user-defined function</dt>
<dd>test_transmission(node1,node2,*args)</dd>
</dl>
<p>which determines whether transmission occurs.</p>
<p>So elaborate rules can be created as desired by the user.</p>
<dl class="docutils">
<dt>By default it uses </dt>
<dd>_simple_test_transmission_</dd>
</dl>
<p>in which case args should be entered as (p,)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G: NetworkX Graph (or some other structure which quacks like a </dt>
<dd>NetworkX Graph)
The network on which the epidemic will be simulated.</dd>
<dt>test_transmission: function(u,v,*args)</dt>
<dd><p class="first">(see below for args definition)
A function that determines whether u transmits to v.
It returns True if transmission happens and False otherwise.
The default will return True with probability p, where args=(p,)</p>
<p>This function can be user-defined.
It is called like:</p>
<blockquote>
<div>test_transmission(u,v,*args)</div></blockquote>
<p>Note that if args is not entered, then args=(), and this call is 
equivalent to</p>
<blockquote class="last">
<div>test_transmission(u,v)</div></blockquote>
</dd>
<dt>args: a list or tuple</dt>
<dd><p class="first">The arguments of test_transmission coming after the nodes.  If 
simply having transmission with probability p it should be 
entered as</p>
<blockquote>
<div>args=(p,)</div></blockquote>
<p class="last">[note the comma is needed to tell Python that this is really a 
tuple]</p>
</dd>
<dt>initial_infecteds: node or iterable of nodes (default is None)</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then a randomly chosen node is initially infected.</dd>
<dt>return_full_data: boolean  (default False)</dt>
<dd><dl class="first docutils">
<dt>Tells whether the infection and recovery times of each </dt>
<dd>individual node should be returned.</dd>
<dt>It is returned in the form of two dicts, </dt>
<dd>infection_time and recovery_time</dd>
</dl>
<p class="last">infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is False:</dt>
<dd>the scipy arrays: t, S, I, R</dd>
<dt>else:</dt>
<dd>the scipy arrays: t, S, I, R 
and the dicts infection_time and recovery_time</dd>
</dl>
<p>these arrays give all the times observed and the number in each 
state at each time.  The dicts give times at which each node changed 
status.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.6</span><span class="p">,),</span> 
                                    <span class="n">initial_infecteds</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p>Because this sample uses the defaults, it is equivalent to a call to 
basic_discrete_SIR_epidemic</p>
</dd></dl>

<dl class="function">
<dt id="EoN.estimate_SIR_prob_size">
<code class="descclassname">EoN.</code><code class="descname">estimate_SIR_prob_size</code><span class="sig-paren">(</span><em>G</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#estimate_SIR_prob_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.estimate_SIR_prob_size" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.12 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>Provies an estimate of epidemic probability and size assuming a 
fixed transmission probability p.</p>
<p>The estimate is found by performing bond percolation and then 
finding the largest connected component in the remaining network.</p>
<p>This assumes that there is a single giant component above threshold.</p>
<p>It will not be an appropriate measure if the network is made up of 
several densely connected components with very weak connections 
between these components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission probability</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>PE, AR <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd><dl class="first last docutils">
<dt>(numbers) estimates of the probability and proportion </dt>
<dd>infected (attack rate) in epidemics</dd>
<dt>(the two are equal, but each given for consistency with </dt>
<dd>estimate_directed_SIR_prob_size)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">PE</span><span class="p">,</span> <span class="n">AR</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">estimate_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.estimate_SIR_prob_size_from_dir_perc">
<code class="descclassname">EoN.</code><code class="descname">estimate_SIR_prob_size_from_dir_perc</code><span class="sig-paren">(</span><em>H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#estimate_SIR_prob_size_from_dir_perc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.estimate_SIR_prob_size_from_dir_perc" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.17 of Kiss, Miller, &amp; Simon.  Please cite the book if 
using this algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>H:  directed graph (assumed to be from directed percolation on </dt>
<dd>previous graph G)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>PE, AR <span class="classifier-delimiter">:</span> <span class="classifier">numbers</span></dt>
<dd>Estimates of epidemic probability and attack rate found by 
finding largest strongly connected component and finding in/out 
components.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.003</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">some_user_defined_operation_to_do_percolation</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
<span class="n">PE</span><span class="p">,</span> <span class="n">AR</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">estimate_SIR_prob_size_from_dir_perc</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.estimate_directed_SIR_prob_size">
<code class="descclassname">EoN.</code><code class="descname">estimate_directed_SIR_prob_size</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#estimate_directed_SIR_prob_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.estimate_directed_SIR_prob_size" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.17 of Kiss, Miller, &amp; Simon.  Please cite the book if 
using this algorithm</p>
<p>Predicts probability and attack rate assuming continuous-time 
Markovian SIR disease on network G</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SEE ALSO:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>estimate_nonMarkov_SIR_prob_size which handles nonMarkovian versions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>PE, AR <span class="classifier-delimiter">:</span> <span class="classifier">numbers (between 0 and 1)</span></dt>
<dd>Estimates of epidemic probability and attack rate found by 
performing directed percolation, finding largest strongly 
connected component and finding its in/out components.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.003</span><span class="p">)</span>
<span class="n">PE</span><span class="p">,</span> <span class="n">AR</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">estimate_directed_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.estimate_nonMarkov_SIR_prob_size">
<code class="descclassname">EoN.</code><code class="descname">estimate_nonMarkov_SIR_prob_size</code><span class="sig-paren">(</span><em>G</em>, <em>xi</em>, <em>zeta</em>, <em>transmission</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#estimate_nonMarkov_SIR_prob_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.estimate_nonMarkov_SIR_prob_size" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not directly described in Kiss, Miller, &amp; Simon.  It uses
nonMarkov_directed_percolate_network  (fig 6.18) to predict 
epidemic probability and size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The input graph</dd>
<dt>xi <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>xi[u] gives all necessary information to determine what u&#8217;s 
infectiousness is.</dd>
<dt>zeta <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>zeta[v] gives everything needed about v&#8217;s susceptibility</dd>
<dt>transmission <span class="classifier-delimiter">:</span> <span class="classifier">user-defined function</span></dt>
<dd>transmission(xi[u], zeta[v]) determines whether u transmits to 
v.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>PE, AR <span class="classifier-delimiter">:</span> <span class="classifier">numbers (between 0 and 1)</span></dt>
<dd>Estimates of epidemic probability and attack rate found by 
finding largest strongly connected component and finding in/out 
components.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#mimicking the standard version with transmission rate tau</span>
<span class="c1">#and recovery rate gamma</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>

<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">xi</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span><span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>  
<span class="c1">#xi[node] is duration of infection of node.</span>

<span class="n">zeta</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">tau</span><span class="p">)</span> <span class="c1">#every node has zeta=tau, so same </span>
                                <span class="c1">#transmission rate</span>

<span class="k">def</span> <span class="nf">my_transmission</span><span class="p">(</span><span class="n">infection_duration</span><span class="p">,</span> <span class="n">trans_rate</span><span class="p">):</span>
    <span class="c1">#infect if duration is longer than time to infection.</span>
    <span class="k">if</span> <span class="n">infection_duration</span> <span class="o">&gt;</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="n">trans_rate</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>  
        <span class="k">return</span> <span class="kc">False</span>

<span class="n">PE</span><span class="p">,</span> <span class="n">AR</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">estimate_nonMarkov_SIR_prob_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> 
                                                <span class="n">my_transmission</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.fast_SIR">
<code class="descclassname">EoN.</code><code class="descname">fast_SIR</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>initial_infecteds=None</em>, <em>rho=None</em>, <em>tmax=inf</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#fast_SIR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.fast_SIR" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure A.3 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<p>fast SIR simulation assuming exponentially distributed infection and
recovery times</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The underlying network</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate per edge</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate per node</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then choose randomly based on rho.  If rho is also
None, a random single node is chosen.
If both initial_infecteds and rho are assigned, then there
is an error.</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial fraction infected. number is int(round(G.order()*rho))</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number   (default float(&#8216;Inf&#8217;))</span></dt>
<dd>maximum time after which simulation will stop.
the default of running to infinity is okay for SIR, 
but not for SIS.</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
transmission rate is
G.edge[i][j][transmission_weight]*tau</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data: boolean</dt>
<dd>Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts, infection_time and 
recovery_time.
infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>times, S, I, R <span class="classifier-delimiter">:</span> <span class="classifier">each a scipy array</span></dt>
<dd>giving times and number in each status for corresponding time</dd>
</dl>
<p>OR if return_full_data=True:
times, S, I, R, infection_time, recovery_time</p>
<blockquote>
<div>first four are scipy arrays as above.  New objects are dicts
with entries just for those nodes that were infected ever
infection_time[node] is time of infection
recovery_time[node] is time of recovery</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">fast_SIR</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> 
                            <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_size</span><span class="p">))</span>
                            
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.fast_SIS">
<code class="descclassname">EoN.</code><code class="descname">fast_SIS</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>initial_infecteds=None</em>, <em>rho=None</em>, <em>tmax=100</em>, <em>transmission_weight=None</em>, <em>recovery_weight=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#fast_SIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.fast_SIS" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure A.5 of Kiss, Miller, &amp; Simon.  Please cite the
book if using this algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The underlying network</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate per edge</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate per node</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then choose randomly based on rho.  If rho is also
None, a random single node is chosen.
If both initial_infecteds and rho are assigned, then there
is an error.</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial fraction infected. number is int(round(G.order()*rho))</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>stop time</dd>
<dt>transmission_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd>the label for a weight given to the edges.
transmission rate is
G.edge[i][j][transmission_weight]*tau</dd>
<dt>recovery_weight <span class="classifier-delimiter">:</span> <span class="classifier">string       (default None)</span></dt>
<dd><p class="first">a label for a weight given to the nodes to scale their 
recovery rates</p>
<blockquote class="last">
<div>gamma_i = G.node[i][recovery_weight]*gamma</div></blockquote>
</dd>
<dt>return_full_data: boolean</dt>
<dd>Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts, infection_time and 
recovery_time.
infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>times, S, I <span class="classifier-delimiter">:</span> <span class="classifier">each a scipy array</span></dt>
<dd>giving times and number in each status for corresponding time</dd>
</dl>
<p>or if return_full_data=True:
times, S, I, infection_time, recovery_time</p>
<blockquote>
<div>first four are scipy arrays as above.  New objects are dicts
with entries just for those nodes that were infected ever
infection_time[node] is a list of times of infection
recovery_time[node] is a list of times of recovery</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">initial_size</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">fast_SIS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                            <span class="n">initial_infecteds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_size</span><span class="p">))</span>
                            
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.fast_nonMarkov_SIR">
<code class="descclassname">EoN.</code><code class="descname">fast_nonMarkov_SIR</code><span class="sig-paren">(</span><em>G</em>, <em>process_trans=&lt;function _process_trans_SIR_&gt;</em>, <em>args=()</em>, <em>initial_infecteds=None</em>, <em>rho=None</em>, <em>tmax=inf</em>, <em>return_full_data=False</em>, <em>Q=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#fast_nonMarkov_SIR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.fast_nonMarkov_SIR" title="Permalink to this definition">¶</a></dt>
<dd><p>A modification of the algorithm in figure A.3 of Kiss, Miller, &amp; 
Simon to allow for user-defined rules governing time of 
transmission.</p>
<p>Please cite the book if using this algorithm.</p>
<p>This is useful if the transmission rule is non-Markovian in time, or
for more elaborate models.</p>
<p>For example if there is a mass action style transmission this can be
incorporated into the process_trans command defined by user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : Networkx Graph</p>
<dl class="docutils">
<dt>process_trans <span class="classifier-delimiter">:</span> <span class="classifier">a function that handles a transmission event.</span></dt>
<dd><dl class="first docutils">
<dt>Called by </dt>
<dd><dl class="first last docutils">
<dt>process_trans(G, time, node, times, S, I, R, Q, </dt>
<dd>status, rec_time, pred_inf_time, <a href="#id5"><span class="problematic" id="id6">*</span></a>args)</dd>
</dl>
</dd>
</dl>
<p>must update :   status, rec_time, times, S, I, R,
must also update : Q, pred_inf_time.
In updating these last two, it calculates the</p>
<blockquote>
<div>recovery time, and adds the event to Q.</div></blockquote>
<dl class="last docutils">
<dt>It then calculates predicted times of transmission </dt>
<dd>to neighbors.</dd>
<dt>If before current earliest prediction, it will add</dt>
<dd>appropriate transmission event to Q and update 
this prediction.</dd>
</dl>
</dd>
<dt>args: The final arguments going into process_trans.  </dt>
<dd>If there is some reason to collect data about node that is 
only calculated when transmission occurs it can modify a dict 
or something similar that is passed as an argument.</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then choose randomly based on rho.  If rho is also
None, a random single node is chosen.
If both initial_infecteds and rho are assigned, then there
is an error.</dd>
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>initial fraction infected. number is int(round(G.order()*rho))</dd>
<dt>tmax <span class="classifier-delimiter">:</span> <span class="classifier">(default infinity)</span></dt>
<dd>final time</dd>
<dt>return_full_data: boolean</dt>
<dd><p class="first">Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts, infection_time and 
recovery_time.
infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>If Q is defined:</dt>
<dd>Then initial_infecteds consists of those nodes infected 
<strong>PRIOR</strong> to t=0.  
Those infected at t=0 will be handled by being in Q 
already.</dd>
</dl>
</div></blockquote>
</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">If user wants to predefine some events, this can be done.  This </span></dt>
<dd><p class="first">can be input as a heap or as a list (it will be heapified and 
modified).</p>
<p>User should understand the Event class and use it.</p>
<p>Currently there is no guarantee this is properly supported,
so much so that right now I&#8217;m going to force the user to edit 
the source code before trying it.</p>
<p>I am reasonably confident it will work.</p>
<p>When Q is input, initial_infecteds should be the of nodes in 
I class <strong>PRIOR</strong> to t=0, and the events in Q must have all of 
their recoveries.</p>
<p class="last">The best way to handle nodes that should be already recovered is 
to put them in initial_infecteds and give them a recovery event 
at t=0.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>times, S, I, R <span class="classifier-delimiter">:</span> <span class="classifier">each a scipy array</span></dt>
<dd>giving times and number in each status for corresponding time</dd>
</dl>
<p>OR if return_full_data=True:
times, S, I, R, infection_time, recovery_time</p>
<blockquote>
<div>first four are scipy arrays as above.  New objects are dicts
with entries just for those nodes that were infected ever
infection_time[node] is time of infection
recovery_time[node] is time of recovery</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="EoN.get_NkNl_and_IC_as_arrays">
<code class="descclassname">EoN.</code><code class="descname">get_NkNl_and_IC_as_arrays</code><span class="sig-paren">(</span><em>G</em>, <em>rho</em>, <em>withKs=False</em>, <em>SIR=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_NkNl_and_IC_as_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_NkNl_and_IC_as_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>In some of the differential equations models, we need to know how
many edges exist between nodes of given degrees in a graph.</p>
<p>This finds that and the initial conditions for numbers of the
various edges assuming a fraction rho is initially infected.</p>
<p>G : networkx graph
rho : number between 0 and 1</p>
<blockquote>
<div>fraction of nodes to infect at time 0.</div></blockquote>
<dl class="docutils">
<dt>withKs <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first">flag to say whether we are restricting our attention to 
just those degrees observed in the network or to all 
degrees.
If True,</p>
<blockquote>
<div>then we only consider those degrees that are observed.</div></blockquote>
<dl class="last docutils">
<dt>If False, </dt>
<dd>then we treat it as if all degrees from 0 to kmax are 
observed.</dd>
</dl>
</dd>
<dt>SIR <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>says whether the system will be SIR or SIS.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>NkNl <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array</span></dt>
<dd>NUMBER (not proportion) of edges between each pair of degrees.</dd>
<dt>SkSl0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array</span></dt>
<dd>initial NUMBER of edges between pair of susceptibel nodes of 
each degree type.
= (1-rho)^2 NkNl</dd>
<dt>SkIl0 <span class="classifier-delimiter">:</span> <span class="classifier">2D scipy array    </span></dt>
<dd>initial NUMBER of edges from a susceptible to an infected node 
of the given degrees.
= rho(1-rho) NkNl</dd>
</dl>
<p>if not SIR, also returns
IkIl0 : 2D scipy array</p>
<blockquote>
<div>initial NUMBER of edges between 2 infected nodes.  This is not 
needed for SIR model.
= rho^2*NkNl</div></blockquote>
<p>if withKs, also returns
Ks : scipy array</p>
<blockquote>
<div>The observed degrees in the population.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="EoN.get_Nk_and_IC_as_arrays">
<code class="descclassname">EoN.</code><code class="descname">get_Nk_and_IC_as_arrays</code><span class="sig-paren">(</span><em>G</em>, <em>rho</em>, <em>SIR=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_Nk_and_IC_as_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_Nk_and_IC_as_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the graph and initial proportion infected this finds the 
initial conditions and number of nodes of each degree as needed
by many of the differential equations models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx graph</p>
<dl class="docutils">
<dt>rho <span class="classifier-delimiter">:</span> <span class="classifier">number between 0 and 1</span></dt>
<dd>fraction of nodes to infect at time 0.</dd>
<dt>SIR <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>says whether the system will be SIR or SIS.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Nk <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>NUMBER (not proportion) of nodes of each degree.</dd>
<dt>Sk0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array</span></dt>
<dd>NUMBER of susceptible nodes of each degree at t=0, 
= (1-rho)Nk</dd>
<dt>Ik0 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array    </span></dt>
<dd>NUMBER of infected nodes of each degree at t=0,   
= rho Nk</dd>
</dl>
<p>if SIR, also returns
Rk0 : scipy array</p>
<blockquote>
<div>NUMBER of recovered nodes of each degree at t=0,    
= 0 Nk</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="EoN.get_Pk">
<code class="descclassname">EoN.</code><code class="descname">get_Pk</code><span class="sig-paren">(</span><em>G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_Pk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_Pk" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in several places so that we can input a graph and then we 
can call the methods that depend on the degree distribution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : networkx Graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Pk <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Pk[k] is the proportion of nodes with degree k.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.get_Psi">
<code class="descclassname">EoN.</code><code class="descname">get_Psi</code><span class="sig-paren">(</span><em>Pk</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_Psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a degree distribution (as a dict), returns the function psi</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Pk <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Pk[k] is the proportion of nodes with degree k.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>psi <span class="classifier-delimiter">:</span> <span class="classifier">function.</span></dt>
<dd>psi(x) = sum_k Pk[k] x^k</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.get_PsiDPrime">
<code class="descclassname">EoN.</code><code class="descname">get_PsiDPrime</code><span class="sig-paren">(</span><em>Pk</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_PsiDPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_PsiDPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a degree distribution (as a dict) returns the function</p>
<p>d^2Psi(x)/dx^2</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Pk <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Pk[k] is the proportion of nodes with degree k.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>psiDPrime <span class="classifier-delimiter">:</span> <span class="classifier">function.</span></dt>
<dd>sum_k k(k-1)Pk[k] x^{k-2}</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.get_PsiPrime">
<code class="descclassname">EoN.</code><code class="descname">get_PsiPrime</code><span class="sig-paren">(</span><em>Pk</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_PsiPrime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_PsiPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a degree distribution (as a dict) returns the function
dPsi(x)/dx</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Pk <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Pk[k] is the proportion of nodes with degree k.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>psiPrime <span class="classifier-delimiter">:</span> <span class="classifier">function.</span></dt>
<dd>sum_k k Pk[k] x^{k-1}</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="EoN.get_infected_nodes">
<code class="descclassname">EoN.</code><code class="descname">get_infected_nodes</code><span class="sig-paren">(</span><em>G</em>, <em>tau</em>, <em>gamma</em>, <em>initial_infecteds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_infected_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_infected_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.15 of Kiss, Miller, &amp; Simon.  Please cite the book if 
using this algorithm</p>
<p>Finds all eventually infected nodes in a simulation, assuming that 
the intial infecteds are as given and transmission occurs with rate 
tau and recovery with rate gamma.</p>
<p>Uses a percolation-based approach.</p>
<p>Note that the output of this algorithm is stochastic.</p>
<p>This code has similar run-time whether an epidemic occurs or not.
There are much faster ways to implement an algorithm giving the same 
output, for example by actually running an epidemic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">WARNING:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>why are you using this command? If it&#8217;s to better understand some
concept, that&#8217;s fine.  But this command IS NOT an efficient way to
calculate anything.  Don&#8217;t do it like this.  Use one of the other
algorithms.  Try fast_SIR, for example.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission rate</dd>
<dt>gamma <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>recovery rate</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then a randomly chosen node is initially infected.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>infected_nodes <span class="classifier-delimiter">:</span> <span class="classifier">set</span></dt>
<dd>the set of nodes infected eventually in a simulation.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"><p class="first">import networkx as nx
import EoN</p>
<p class="last">G = nx.fast_gnp_random_graph(1000,0.002)
finalR = EoN.get_infected_nodes(G, 2, 1, initial_infecteds=[0, 5])</p>
</td>
</tr>
</tbody>
</table>
<p>finds the nodes infected if 0 and 5 are the initial nodes infected
and tau=2, gamma=1</p>
</dd></dl>

<dl class="function">
<dt id="EoN.get_time_shift">
<code class="descclassname">EoN.</code><code class="descname">get_time_shift</code><span class="sig-paren">(</span><em>times</em>, <em>L</em>, <em>threshold</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#get_time_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.get_time_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Identifies the first time at which L crosses a threshold.  
Useful for shifting times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">list or scipy array (ordered)</span></dt>
<dd>the times we have observations</dd>
<dt>L <span class="classifier-delimiter">:</span> <span class="classifier">a list or scipy array</span></dt>
<dd>order of L corresponds to times</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>a threshold value</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>the first time at which L reaches or exceeds a threshold.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="EoN.myQueue">
<em class="property">class </em><code class="descclassname">EoN.</code><code class="descname">myQueue</code><span class="sig-paren">(</span><em>tmax=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#myQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.myQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to store a priority queue of events
for event-driven simulations.</p>
</dd></dl>

<dl class="function">
<dt id="EoN.my_odeint">
<code class="descclassname">EoN.</code><code class="descname">my_odeint</code><span class="sig-paren">(</span><em>dfunc</em>, <em>V0</em>, <em>times</em>, <em>args=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#my_odeint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.my_odeint" title="Permalink to this definition">¶</a></dt>
<dd><p>For some of the systems odeint will switch to the BDF solver.
In large enough systems, it then gets stuck trying to estimate the 
Jacobian.</p>
<p>This routine has identical inputs to integrate.odeint, but relies on 
integrate.ode.  It avoids BDF.</p>
<p>In particular, this seems to be important for SIS heterogeneous 
pairwise where the number of equations is very large.  I have found 
that near equilibrium, this often is interpreted as being a stiff 
system and it switches to bdf, which requires calculating a 
Jacobian.  In some systems this is impractically large.</p>
<dl class="docutils">
<dt>See this question: </dt>
<dd><a class="reference external" href="http://stackoverflow.com/q/40317096/2966723">http://stackoverflow.com/q/40317096/2966723</a>,</dd>
<dt>with the answer by </dt>
<dd>Phillip: <a class="reference external" href="http://stackoverflow.com/users/1881610/phillip">http://stackoverflow.com/users/1881610/phillip</a></dd>
</dl>
<p>INPUT and OUTPUT are as integrate.odeint</p>
</dd></dl>

<dl class="function">
<dt id="EoN.nonMarkov_directed_percolate_network">
<code class="descclassname">EoN.</code><code class="descname">nonMarkov_directed_percolate_network</code><span class="sig-paren">(</span><em>G</em>, <em>xi</em>, <em>zeta</em>, <em>transmission</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#nonMarkov_directed_percolate_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.nonMarkov_directed_percolate_network" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.18 of Kiss, Miller, &amp; Simon.  
Please cite the book if using this algorithm.</p>
<p>xi and zeta are dictionaries of whatever data is needed so that 
xi[u] and zeta[v] 
are enough to determine the probability of a u-v transmission.</p>
<p>transmissision is a user-defined function taking xi[u] and zeta[v] 
and returning True if a transmission would occur</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The input graph</dd>
<dt>xi <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>xi[u] gives all necessary information to determine what us 
infectiousness is.</dd>
<dt>zeta <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>zeta[v] gives everything needed about vs susceptibility</dd>
<dt>transmission <span class="classifier-delimiter">:</span> <span class="classifier">user-defined function</span></dt>
<dd>transmission(xi[u], zeta[v]) determines whether u transmits to 
v.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>networkx DiGraph (directed graph) H.  
Edge u,v exists in H if it will transmit given the opportunity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>for now, I&#8217;m being lazy.  
Look at the sample for estimate_nonMarkov_SIR_prob_size to infer it.</p>
</dd></dl>

<dl class="function">
<dt id="EoN.percolate_network">
<code class="descclassname">EoN.</code><code class="descname">percolate_network</code><span class="sig-paren">(</span><em>G</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#percolate_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.percolate_network" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.10 of Kiss, Miller, &amp; Simon.  Please cite the book
if using this algorithm.</p>
<p>Performs bond percolation on the network G, keeping edges with 
probability p</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>G : NetworkX Graph
p : number between 0 and 1</p>
<blockquote>
<div>the probability of keeping edge</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>H <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>A network with same nodes as G, but with each edge retained 
independently with probability p.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">percolate_network</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>

<span class="c1">#H is now a graph with 60% of the edges of G</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="EoN.percolation_based_discrete_SIR_epidemic">
<code class="descclassname">EoN.</code><code class="descname">percolation_based_discrete_SIR_epidemic</code><span class="sig-paren">(</span><em>G</em>, <em>p</em>, <em>initial_infecteds=None</em>, <em>return_full_data=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#percolation_based_discrete_SIR_epidemic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.percolation_based_discrete_SIR_epidemic" title="Permalink to this definition">¶</a></dt>
<dd><p>From figure 6.10 of Kiss, Miller, &amp; Simon.  Please cite the book
if using this algorithm.</p>
<p>The simple case of all nodes transmitting with probability p 
independently to each neighbor and then recovering, but using a 
percolation-based approach.</p>
<p>See basic_discrete_SIR_epidemic which should produce equivalent 
outputs.</p>
<p>That algorithm will be faster than this one.</p>
<p>The value of this function is that by performing many simulations we 
can see that the outputs of the two are equivalent.</p>
<p>This algorithm leads to a better understanding of the theory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>G <span class="classifier-delimiter">:</span> <span class="classifier">NetworkX Graph</span></dt>
<dd>The network the disease will transmit through.</dd>
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd>transmission probability</dd>
<dt>initial_infecteds: node or iterable of nodes</dt>
<dd>if a single node, then this node is initially infected
if an iterable, then whole set is initially infected
if None, then a randomly chosen node is initially infected.</dd>
<dt>return_full_data: boolean</dt>
<dd><p class="first">Tells whether the infection and recovery times of each 
individual node should be returned.  
It is returned in the form of two dicts,</p>
<blockquote>
<div>infection_time and recovery_time</div></blockquote>
<p class="last">infection_time[node] is the time of infection and 
recovery_time[node] is the recovery time</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>if return_full_data is False:</dt>
<dd>the lists: t, S, I, R</dd>
<dt>else:</dt>
<dd>the lists: t, S, I, R 
and the dicts infection_time and recovery_time</dd>
<dt>these lists give all the times observed and the number in each state </dt>
<dd>at each time.</dd>
</dl>
<p>The dicts give times at which each node changed status.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">SAMPLE USE:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">EoN</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">fast_gnp_random_graph</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">EoN</span><span class="o">.</span><span class="n">percolation_based_discrete_SIR_epidemic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to basic_discrete_epidemic (but many simulations
may be needed before it&#8217;s clear, since these are stochastic)</p>
</dd></dl>

<dl class="function">
<dt id="EoN.subsample">
<code class="descclassname">EoN.</code><code class="descname">subsample</code><span class="sig-paren">(</span><em>report_times</em>, <em>times</em>, <em>status1</em>, <em>status2=None</em>, <em>status3=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/EoN.html#subsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#EoN.subsample" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Given </dt>
<dd>S, I, and/or R as lists (or other iterable) of numbers of nodes of
given status at given times</dd>
<dt>returns them </dt>
<dd>subsampled at specific report_times.</dd>
</dl>
<p>If more than one argument is given, does so as a list in order given, but 
skipping whichever was not included (if any not included)</p>
<p>If only one is given then returns just that.</p>
<p>If report_times goes longer than times, then this simply assumes the 
system freezes in the final state.</p>
<p>This uses a recursive approach if multiple arguments are defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">INPUTS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>report_times <span class="classifier-delimiter">:</span> <span class="classifier">iterable (ordered)</span></dt>
<dd>times at which we want to know state of system</dd>
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">iterable (ordered)</span></dt>
<dd>times at which we have the system state (assumed no change 
between these times)</dd>
<dt>statusX (X one of 1, 2 or 3) <span class="classifier-delimiter">:</span> <span class="classifier">iterable (order corresponds to times)</span></dt>
<dd>generally S, I, or R
number of nodes in given status.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">RETURNS:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>If only status1 is defined</dt>
<dd><dl class="first last docutils">
<dt>report_status1 <span class="classifier-delimiter">:</span> <span class="classifier">scipy array gives status1 subsampled just at </span></dt>
<dd>report_times.</dd>
</dl>
</dd>
<dt>If more are defined then it returns a list, either</dt>
<dd>[report_status1, report_status2]</dd>
<dt>or</dt>
<dd>[report_status1, report_status2, report_status3]</dd>
</dl>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="quickstart.html"
                        title="previous chapter">QuickStart Guide</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/methods.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="QuickStart Guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Epidemics on Networks 0.91 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Joel Miller, Istvan Kiss, Peter Simon.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>